<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nomoshen</title>
  <subtitle>尽可能努力一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-10T00:50:55.872Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>nomoshen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021规划</title>
    <link href="http://yoursite.com/2021/01/06/2021%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2021/01/06/2021规划/</id>
    <published>2021-01-05T22:46:47.000Z</published>
    <updated>2021-01-10T00:50:55.872Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.nomoshen.com/light-1834289_1280.jpg" alt="light-1834289_1280"></p>
<blockquote>
<p>人在遥望未来的时候总是充满着希望，而希望总是给人带来着动力往前努力发展，这可能就是希望的作用吧，即使是微弱的光也值得人类不断的去追求.</p>
</blockquote>
<p>2020年是一个魔幻的一年，不光是全球疫情还有我的整个工作经历、精神转变和接触面的扩张，整个世界都在经历着痛苦，而自己整个精神也在承受着不一样的折磨；回顾在阿里的大半年，个人的预期不断被刷新,</p>
<ul>
<li>从充满向往</li>
<li>貌似没什么事情可做,远不是什么高精尖</li>
<li>开始主动做点零散的活找存在感</li>
<li>想止损,走</li>
<li>莫名325</li>
<li>痛苦的1个月</li>
<li>调整自己心态,努力证明自己</li>
<li>1Q的绩效为3.5+,老板说能上线就半年3.75</li>
<li>原来之前325不是我的问题，那就离开了这个让人蛋疼的公司吧</li>
</ul>
<p>325之后我非常的痛苦,我不断怀疑自己；因为作为一流的阿里给你打上了325的标签是否表示着你的水平真的不行，为此我不断的反思自己不断的让自己的工作模式更加符合阿里的.但是最后我发现，其实不是我的能力出了问题，而是我不适应阿里这种模式的工作和评判标准，于是我就选择离开阿里.经历过这段时光我发现，人一定要想明白自己想要什么的，钱、成长、未来、健康还是生活, 而对于我来说如果在阿里继续走下去，时间、成长、健康、生活都会慢慢走向不利的方向，所以我选择离开。</p>
<p>最近和阿里、pdd的好朋友吃饭，不得不感叹他们的待遇远比我的要好很多很多，double都不止吧；但是我远比之前要坚定的多，因为经历过才知道为了这些你需要付出什么.人过30貌似是一个坎，什么都在往下走，体力、精力、注意力，所以还是要抓住这些东西让它们在自己想要的方向发展.</p>
<p>离开阿里，有两个offer，一个是朋友的创业公司做中间件leader，一个是做存储开发的一线工程师; 大概是中心有所担心，一是怕能力不足，二是怕压力太大，所以去了存储做一线工程师.有后悔吗？到也没有，之后在现在想来可能去了问题也不会太大,还是不自信了点。来七牛云我的目标其实很明确:</p>
<ol>
<li>接触计算机最为基础的核心部件，并且了解它是如何运转，并且商用赚钱的; 七牛给了我一个机会，这个机会如果在阿里或者其他大公司估计就不会给. </li>
<li>时间上充裕可以让我做更多其他方面的成长，这个成长是技术、人生、软实力还是其他的，给我一个相对自由的空间能让我按照自己的意图去发展</li>
<li>给自己时间期限，2年或者3年，之后能达到怎么样的水平，然后尝试转型到我的目标，开始接触业务，做一个技术和业务的粘合剂. 技术的上限我一直很明白，但是作为基础，我觉得它有多扎实我后面成长就会有多快. 我在为自己的奇点做准备吧. </li>
</ol>
<p>最近看到一个文章，说中年人总共四个事情牵绊着，这也是导致中年危机的原因吧;</p>
<ul>
<li>身体</li>
<li>事业</li>
<li>子女教育</li>
<li>家庭</li>
</ul>
<p>那就从这个四个方面也规划自己的2021年吧; 其实这几个中最难的是子女教育，我自己感受也是很明显的，妞妞的成长有点快，我貌似已经不知道怎么样去教育她了，她的自我意识不断的成长，脾气也开始不断的倔强，我都不知道如何引导她去正确的成长.最重要的自己的身体，身体是革命的本钱，这句话你可能现在感受不到，但是出了问题你就发现尤其的深刻，所以我特别讨厌996。家庭的话分为父母和夫妻，父母的话只要身体不出问题，我觉得基本就是个钱的问题，而夫妻本身大家目标一致大部分的时候钱也是能解决问题的. 事业吗，本事就是自我需要不断去努力和探索的，所以是一个不得不需要考虑的问题。</p>
<p>最近我的一个好朋友小群中一致在说想创业，打工人没前途这个事情。咋说呢？之前的自己可能也是这么认为的，只有自己做老板了才能自由；但是一年下来我觉得吗，并不是只有这条出路，而且这条出路的死亡率有点略高，不想明白去创业基本是死，想明白去创业也不一定活得下来。所以对于普通人的我来说，创业是选择但不是唯一选择，这可能是我目前心中坚定的一个想法。<strong>打工人</strong>这个自黑我其实并不喜欢，因为让人觉得你就是工作的机器，我越加觉得事业可能是更加适合我们的；事业是不一定是工作，事业是你想要完成或者实现的某一个价值的体现，群中小伙伴有点过于的左右极端，一方面是给我钱我就愿意不断的996，一方面是我不想上班，我想创业。其实我觉得本质上还是在于正确找到自己的方向或者事业吧。而且公司和个人其实是平等的，当然在中国有点扭曲吧，但是本质上还是双向选择的过程，我想要的方向和公司给予我的方向是否能达到共同进步的，如果能或者加快那就是ok的。</p>
<p>最近我越加越觉得<strong>商业的本质是互利</strong>这句话的真谛；你并不能一味的让别人为你付出，而对应的你也不是一味的为别人付出；健康的状态是互利共赢，而你和公司本身就应该是这种健康的态势。你说996什么的，的确是整个中国不一样的地方，但是但是你是否有思考过，你为什么就选择单一了呢？是不是自己被困住了，你思考清楚自己想要什么，然后努力为此奋斗。中国有着中国不一样的地方，说真的只是因为我们生活在这个时代，上次听了老齐讲美国40-60年代的时候，你会发现依然很乱，甚至比我们还乱，所以社会进步是由一个过程的，如果你不想经历这个过程，你是否应该思考如何去美国、欧洲呢？其实选择就在，只是大部分会被自己给框住。</p>
<blockquote>
<p>这个方面我非常敬佩从前的<strong>大神</strong>，作为妹子她有着自己的理想，在2020年她和她丈夫一起去了新加坡，当然疫情都不是那么顺利，她现在还是没找到特别符合预期的工作，好在她丈夫找到了工作了，总的来说应该算是慢慢落地的过程。你需要为自己的选择去努力，而且这个过程并不会那么顺利，但是你不觉得这就是一个不一样的开始吗。最近一个百阿认识的一个朋友也选择裸辞去了澳洲，我觉得她肯定是心怀梦想很久，而且也是忍不住这种高强度的工作了。</p>
</blockquote>
<p>人生<strong>永远</strong>是双向选择的，只不过大部分人走着走着就走成了一条路. </p>
<h3 id="1-规划1-身体"><a href="#1-规划1-身体" class="headerlink" title="1. 规划1 - 身体"></a>1. 规划1 - 身体</h3><p>其实这几年一直都有在锻炼，5年的健身卡已经过去两年了，这两年我还是一直在去锻炼，整个感觉还算是可以的。最近由于没管住嘴，身体的体重又缓缓上来了。今年身体上的目标为:</p>
<ul>
<li>体重上控制在140差不多，这个有点难，因为目前大概在152差不多; 这个可能需要花费很多的精力去完成;</li>
<li>身材上: 我请了私教,所以今年的目标是1. 有腹肌 2. 俯卧撑一次40个，能做4组 3. 能做5个引体向上;</li>
<li>自我体系的建立: 学了2年了私教，今年的目标是想要自己学会为自己安排训练计划。这个可能需要不断的去总结每次锻炼之后的，然后不断去修正. 这块我准备每次做动作拍照然后记录有什么作用，主要训练什么部位等,也希望和教练慢慢磨合好这块.</li>
<li>尽可能不熬夜： 10-11点睡觉，6-7起床；这样早上我也可以好好学习。其他的时间段就效率高一些就好.</li>
<li>饮食上控制: 1. 每天水果、牛奶、蛋白 2. 少吃不健康的饮食，当然偶尔问题也不大, 不然多难受 3. 晚上可能还是选择吃吃全麦面包吧，我觉得这个还是靠谱的；其他的就是营养要补齐;</li>
</ul>
<h3 id="2-规划2-家庭"><a href="#2-规划2-家庭" class="headerlink" title="2. 规划2 - 家庭"></a>2. 规划2 - 家庭</h3><p>家庭上,关注点在于和老婆之间的目标上。目前我们两个已经完成了整体的大方向的目标，而且可以看到很多的问题都会考虑到和目标是否一致；大方向上是为了财富自由而奋斗，目前老婆大人这边工作也挺稳定的，并且待遇相对来说也还好，主要是周六是要去上班的；但自由程度上应该可以接受。</p>
<p>自己父母的话，主要关心几件事情；</p>
<ol>
<li>爸爸的打呼声音，目前主要是疫情影响太大了，没办法也做检测，等后面控制的差不多，给他安排一个呼吸机来保证他的健康；</li>
<li>今年妈妈想买车；虽然我极力不同意，因为现在并不好赚钱，他们的钱留下来还可以给弟弟做个基础，你花在车上我觉得真的不值得。说一点私心，你现在花在车上，弟弟后面不是要我这边来帮助吗。哎…成年人的世界我觉得总的来说要为自己的决策负责，即使是父母.</li>
</ol>
<p>家庭主要侧重点在于和妻子的交流; 2021年主要还是以积累自己的财富为主.</p>
<h3 id="3-规划3-子女教育"><a href="#3-规划3-子女教育" class="headerlink" title="3. 规划3 - 子女教育"></a>3. 规划3 - 子女教育</h3><p>对于女儿的教育呢，目前自己缺少中心思想，也不知道如何教育现在小姑娘；这个方面主要是自己没有怎么用心，没有特别好的<strong>引导</strong>小姑娘的发展方向；小姑娘目前有一些比较明显的问题：</p>
<ul>
<li>独立性有点差；其实在学校里她的表现会好一些，但是在家里非常喜欢依赖我们，估计在她心里这是爱我们的表现。到目前为止还不能分床睡觉，起床、刷牙、洗脸等日常习惯还不能主动来完成，需要我们不断的催她。</li>
<li>注意力还不错，但是感觉我没有给她找到一个东西可以锻炼她的意志力的问题；</li>
<li>有点容易放弃；关于这点其实有两个原因；1. 我通常有点过于保护她 2. 觉得难，自己完成不了，完成不了就直接放弃</li>
<li>运动量有点少；这个怪我们，小姑娘有点胖了，这是我不想看到的，因为胖是有惯性的；之前的游泳是运动量还不错的，但是这段时间游泳馆倒闭了，导致我们很长时间没去给他游泳了，准备到后期还是继续吧；在这件事情我看到了她的自信心，她觉得她比别人厉害。</li>
</ul>
<p>其实这些问题有的时候觉得是孩子所以我也不注意，但是人是有惯性的，现在不主动的引导，后面估计就更难了。所以2021自己还是希望在这块上和她一起进步。对她的希望和目标是: </p>
<ol>
<li>身体健康; 小姑娘小时候有先天性心脏病,后面自我修复了, 所以我希望通过适合的运动来增加她身体的能力，当然要问问医生看，是否合适</li>
<li>自信心的打造; 关于这块,我希望通过不断的帮她克服各种事情，从而增加她的自我信心，觉得我一个人也能完成</li>
<li>放手;父母对孩子过于保护会让她失去自我努力并且获得成功的机会; 而妞妞其实有很强的独立能力，只不过我有点过于保护;</li>
<li>引导注意力往更加有意义的方向去努力。这目标我不知道对不对，主要是想让她在长期有意义上事情上花更多的时间吧.</li>
</ol>
<p>上面这些是希望，至于我自己的话，最近可能需要补充更多的教育方面的知识点，来慢慢的融入到与孩子生活中; </p>
<p><strong>TODO:</strong></p>
<ol>
<li>找一些比较有方向性的书进行阅读</li>
<li>找一些靠谱的公开课进行观看</li>
<li>和老婆大人讨论，并且制定教育妞妞的原则性的方向，并且计划妞妞未来一年需要完成的事情</li>
<li>陪着她，而不仅仅只是陪着她;</li>
</ol>
<h3 id="4-规划4-事业"><a href="#4-规划4-事业" class="headerlink" title="4. 规划4 - 事业"></a>4. 规划4 - 事业</h3><p>在回顾2020年的时候，我说过自己的事业和自己做的工作不一定是一模一样; 事业是对自己来说的而非公司，公司在这里面主要是为了让你更加好的去完成事业。自己定了一个40岁的目标是: <strong>除去房产之后有600w的资产,并且在40岁的时候有选择退休的权利</strong>;可能你觉得我这个有点肤浅，一点都不高大上；其实这不是过程这是一个你要的结果，具体的结果；至于你是如何达到这样的结果就看你自己。我朋友会选择创业，但我自己分析了自己的能力和抗风险的能力，我极大可能不会选择去创业，起码现在的我还没做好这个准备。</p>
<blockquote>
<p>3～5年的事业方向是: 成为业务模型与技术方案之间的中间层,你可以认为是架构师，提供解决方案的人，反正的意图在于解决业务增长过程中不断遇到新的问题，如何用业务、技术来解决这些问题。还有一点就是遇见业务的增长，用有成长性的方案来帮组公司在未来的时候能扛住更大的成长.</p>
</blockquote>
<blockquote>
<p>为什么选择这个方向呢？ 自己的思考是：将自己作为一款产品，你需要有自己的定位，如果你的定位只是和年轻人一样，加班、拼体力的话，那你35岁就应该被淘汰，因为作为商品你已经到了被丢弃的时间点了。所以我要做差异性，我比年轻人强在什么地方；我觉得是产品经验，各开源框架的熟悉程度，各种场景的方法论问题，各种疑难杂症的总结。这是我强的地方，我需要将自己打造成，一眼就能看出你业务的难点困难点和极容易在后期出现瓶颈的点，并且用合适的方式去规避到这些问题. 不管任何时代，不管合适空间，能在困难场景下一眼找到主要矛盾并且解决的人都是人才。</p>
</blockquote>
<p>自己在这条道路上还刚起来，但是我不着急，我给了自己2～3年的时间，让自己能成长到符合自己预期的那种程度;目前有很多的不足，所以今年的目标是慢慢补齐:</p>
<h4 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h4><p>最近在读很多偏理论上的书，可能你觉得实战比较重要，但是越到后期理论上的理解会影响你对知识的掌控；所以你需要的理论和实战不断的去融合:</p>
<ol>
<li><p>操作系统: 这块一直是弱点;尤其在分析一些更加偏原理能问题的时候就越加吃力; 今年的目标是将<a href="https://www.epubit.com/bookDetails?id=N16113" target="_blank" rel="noopener">操作系统</a>这本书给看到2～3遍差不多。最近学习有了一个新的思路，就是按照专题来进行学习，其实我对操作系统很多知识点都有掌握，但是我实际用的时候就会模糊掉，所以我先通过对某一个问题进行展开然后掌握:</p>
<ul>
<li>为什么说线程切换很好性能? 协程和异步到底解决了什么问题? </li>
<li><p>同步异步、阻塞非阻塞本质是什么？ </p>
<p>类似于这种困扰自己的很久的问题然后进行展开，不断的深入并且与现实进行结合，比如异步协程可以找golang和rust async await来思考; 我觉得这种方式会让你有一种个方面连起来的感觉</p>
</li>
</ul>
</li>
<li><p>计算机网络: 又是一个坎，很难跨过去的坎; 但是契机在于公司目前有一个kcp的项目在；我可以通过阅读这个代码看相关的数据来完成这个任务. 对于这块，其实我觉得主要是要掌握几点:</p>
<ul>
<li>tcp出现的目的是什么？本质它是一个什么东西? 如何能回答完这个问题估计你就很好理解三次握手和4次挥手的问题？</li>
<li>tcp目前存在什么问题？导致为什么那么多大公司会选择用用户态的各种优化？比如scylladb、kcp、quic等，是性能考虑还是其他?</li>
<li><p>如何排查tcp问题；tcpdump、tcp状态监控等等</p>
<p>这可能是我需要不断的是深入了解的；其实你看如何你抓住了本质的问题，需要学习tcp的知识就会清晰很多，对我来说就是我了解到了tcp的本质之后，我去看tcp的状态图的演变的时候就一下子就记住和明白了，自己都可以推演</p>
</li>
</ul>
</li>
<li><p>数据库: 这块原理性的东西就更加多了； 事务、一致性、共识算法、隔离性等等, 我现在问题就在于对原理性的东西搞不清楚，导致在理解实际开源的实现的时候就有点不入门.</p>
<ul>
<li>自己整理了不少关于这个方面的数据，准备通过不断阅读来加深对这块的理解</li>
<li><p>在理解过程中，找一些现存的实现来加深理论的深度</p>
<p>这块比较重要，我自己也思考了很久；不理解这块呢，后面很多业务上的问题都会遇到瓶颈.</p>
</li>
</ul>
</li>
<li><p>编程范式估计也是我最近很想了解的，因为学了很多语言发现自己貌似只会用，本质没掌握，所以这块后面也想好好掌握; 尤其是并发模型的不同解决了什么样子的问题之类的，但目前来说可能优先级没那么高</p>
</li>
</ol>
<p><strong>目前的目标:操作系统和数据库的核心概念能掌握清楚，并且知道各种开源实现的优缺点在什么地方；出于什么目的去做的</strong></p>
<h4 id="4-2-基础对应的实现类的东西"><a href="#4-2-基础对应的实现类的东西" class="headerlink" title="4.2 基础对应的实现类的东西"></a>4.2 基础对应的实现类的东西</h4><ul>
<li>seastar</li>
<li>rust的async await</li>
<li>goroutine</li>
<li>asio</li>
<li><p>folly</p>
</li>
<li><p>tikv+tidb</p>
</li>
<li>raft</li>
<li>paxos</li>
</ul>
<p>目前就想通过这些开源来帮忙自己去了解上面说的各种问题，结合着看会效果更好；</p>
<h4 id="4-3-核心会关注的产品"><a href="#4-3-核心会关注的产品" class="headerlink" title="4.3 核心会关注的产品:"></a>4.3 核心会关注的产品:</h4><ul>
<li><p>mongodb: 本职工作;也是需要不断的去关注和优化的；自己的mongodb的感受在于对核心的几个模块能比较清楚即可; 并且在后期已经是往稳定性方向上去努力. 目前自己对mongodb的了解来说，从分布式系统角度分析mongo的话，核心模块为：</p>
<ul>
<li>数据如何分片; 路由模块</li>
<li>数据如何备份；这个会涉及副本如何做，选举怎么做，切换怎么做等</li>
<li>负债均衡怎么做; 这就涉及到分片、数据迁移、split等等</li>
<li>元数据管理;</li>
<li>存储引擎的变化之类的</li>
</ul>
</li>
</ul>
<p>看上面这些就会发现，如果要把mongo了解清楚其实也不是很容易的一件事情; 我感觉会具体涉及到mongo的:</p>
<pre><code>* 元数据管理configservice; 这些信息如何在各个node上的维护;
* query/write写流程中可能会涉及到的路由刷新，一致性保证之类的
* 每一个shard之间如何做副本同步，不同的策略带来什么样子的问题，如何权衡
* movechunk、自动split的时机和具体如何实现，会给系统带来什么问题; 负载均衡的依据什么的
* 副本之间的一致性策略是怎么样的？与业界有什么区别
</code></pre><p>分析mongo其实可以从分布式角度去分析它，然后通过阅读源码和分析开源方案来比较学习，估计这样会更加好.</p>
<ul>
<li>tikv/tidb: 这块是为了弥补我自己没有完成的做过一套高性能的分布式kv存储弱点；很多点我没办法都get到，很多理论知识我也没办法感知在线上应该如何实现；所以这个我准备今年好好努力的去看看；为什么选择它呢？因为官方教程多，社区比较好，还有视频可以带你学习，所以觉得会更加好一些. </li>
<li>seastar框架: 学习这个主要是为了研究scylladb如何做异步、io用户态如何完成、用户态网络框架、自己实现内存调度，这些都是在学习完操作系统之后需要不断深入的</li>
<li>k8s: 学习这块的目的是为了投资未来，趋势不可能随意被改变，那么我就要让自己顺势而为；自己主要也储备一些自己的这方面的知识，而且自己也在用，所以无可厚非;</li>
<li>其他的话: 可能就只是浅尝则止吧；我希望自己能通过自己的专业角度去分析这些开源产品，能瞬间看出他们的创新点和肯定存在的问题；这可能就是我想要的抓住主要矛盾的能力;</li>
</ul>
<h4 id="4-4-软实力"><a href="#4-4-软实力" class="headerlink" title="4.4 软实力"></a>4.4 软实力</h4><p>这些年的工作经验，会发现软实力才是你在企业的上限，自己的软实力并不强；从在蘑菇街的几次晋升答辩就知道自己太过于胆小，同一件事情不同人在聊的时候给人的感觉就差别很大；我自己有的时候会觉得自己做的事情好小，貌似没什么了不起的；第二自己也不会主动的去思考，这可能比之前那个还要严重，因为看了很多书都说主动思考主动去解决问题的人才会比较好，但是自己好像一般都不怎么主动，你给我难度很高，我也做，你给我难度一般我也能做，反正只要是我的责任我加班加点我都做，但是如果没有责任明确我一般都不愿意去做，哈哈哈，上次看到知乎回答，这可能是独生子女的环境有关，凡事觉得没人会来抢你，哈哈哈，其实我真的内心中有这么的想法。</p>
<p>软实力我个人比较看重的是几点：</p>
<ol>
<li>写作能力; 学习如何将一个事情说明白，并且把价值体现出来，这也是需要有能力的。而自己目前貌似还没这么写明白的能力；这个方面的想法就是找个相对靠谱的课程先了解基本方式，然后后面会慢慢输出到blog或者微信公众号，是否有人看，其实不重要. </li>
<li>说的能力; 主要是练练胆子;</li>
<li>晋升之路; 主要是想看一下，大公司在晋升过程都在看重什么，整个流程是怎么样的，以我自己的目标来说，后面必然会去当leader，那个时候不得不用一套靠谱的方法论来对下面进行管理。个人是这么觉得，互利共赢永远是最优解.</li>
<li>职场管理方面的学习。目前在公司作为技术专家其实并不需要这个方面的知识，只是先进行学习一下</li>
<li>主动性；其实不主动的很大原因是不知道要做什么？但是我现在发现看不到很大原因可能是角度不够高，局限于细节很难让你有一些不一样的看法。</li>
</ol>
<h4 id="4-5-其他的事业"><a href="#4-5-其他的事业" class="headerlink" title="4.5 其他的事业"></a>4.5 其他的事业</h4><p>2020年理财事业已经开始了，趁着一波牛市这一年是赚了不少钱；虽然很多钱都是跟着别人赚的，但是起码起步了一年了，就像我说的，我只是在门口晃荡了一圈还不算真正入门，但是让我看到了这条路的可行性。2020我给自己制定了10年的退休计划，我好好计算了自己到退休的时候要有多少资产，并且根据自己的能力每年能得到多少资产利得，所以后面几年自己的另外一条就是理财和投资。目前通过工作增加本金，通过理财投资来不断的增值我的资产,我觉得这是相辅相成的一个过程，而且我发现学习这个东西会对社会很多东西看的更加清楚，而不是活着像一个小白。</p>
<blockquote>
<p>靠着事业做到财富自由有比较大的运气成分，并且太多单一；第二条路永远可以让你留一手，不会那么被动</p>
</blockquote>
<p>2021年这方面的目标是：</p>
<ul>
<li>学会看财报，关注财报中的核心知识点；</li>
<li>学会看各类指标；比如市盈率等这种，并且建立自己的股票池子</li>
<li>资产组合的核心原理能掌握，把目前的几个组合的原则给搞清楚，分别面对什么场景，后面老齐不在了我能自己组合自己的资产组合；</li>
<li>基金池子，进行长期的关注，对明星基金在不好的时候进行逆向操作</li>
<li>经济周期的核心知识点进行了解；目前大概知道是怎么回事，但是不知道通过哪些指标来进行判断；比如ppi、cpi这些宏观指标，还有利率之类的</li>
<li>基本了解中国未来的宏观方向</li>
<li>最后就是做估值，起码对一些龙头公司有自己的评判标准;</li>
</ul>
<p>其实自己想要做的就是：自己的一整套投资体系，用未来的时间来慢慢的调整它.</p>
<h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>这个写了好久好久，写的都有点累了。后面就写个大概了，细节就自己后面细化即可。未来总是想做很多很多事情，但是28原则，要把精力花在重要的事情是那个，对目前的我来说应该是事业为主，理财为辅吧。身体这些都是一定一定要保证的。</p>
<p>最近开始面试别人了，怎么说呢？面试别人的时候就不断的在反思自己。我有点发现面试官其实希望你能知道的更加本质的东西，而不是背背书，希望你能通过表现理解到本质的。我有的时候在思考，如果是我自己我能不能做到这样呢？答案是否定的。所以我自己也对自己要求越来越高，凡事要看到事物的本质，只有本质才会让你真正理解到当年为什么需要这么设计.</p>
<p>还有对面试的人来说，尽可能要多思考为什么，为什么要这么做，这样会让你的更加更加清楚知道有点核心知识点的魅力.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.nomoshen.com/light-1834289_1280.jpg&quot; alt=&quot;light-1834289_1280&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人在遥望未来的时候总是充满着希望，而希望总是给人带来着动力往前努力
    
    </summary>
    
      <category term="年度,规划" scheme="http://yoursite.com/categories/%E5%B9%B4%E5%BA%A6-%E8%A7%84%E5%88%92/"/>
    
    
      <category term="2021年" scheme="http://yoursite.com/tags/2021%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>2020年度总结</title>
    <link href="http://yoursite.com/2021/01/03/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/01/03/2020年度总结/</id>
    <published>2021-01-03T09:31:45.000Z</published>
    <updated>2021-01-05T22:45:46.346Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.nomoshen.com/christmas-2869817_1280.jpg" alt="christmas-2869817_1280"></p>
<h3 id="1-2020年自己的重大事件"><a href="#1-2020年自己的重大事件" class="headerlink" title="1. 2020年自己的重大事件"></a>1. 2020年自己的重大事件</h3><ul>
<li>疫情期间开始跟着齐老师学习投资,并在疫情期间开始将自己的存款投入到5个2的组合中;将老婆的存款投入到442中，父母的少量资金投入到3331资金；到了年底，整体还不错，5个2将近有13%的收益，442的组合有9%的收益，3331组合有将近5%的收益，全部都符合达到我的预期；自己也在这一年的学习中，慢慢对这个领域有一点点的了解；虽然到了年底我只能在这个领域的门外晃荡，但是我觉得慢慢的会好起来的.</li>
<li>4月份在阿里被361打了1;这件事情比我想象中影响很大的，导致了我整个工作状态都变得很不行；最终在8月份我也提出离职离开了阿里；现在回想这个事情，可能本身去阿里的这个部门就有点问题，不符合自己的各种预期，而且自己也不喜欢阿里的这种氛围，最后被打1导致自己开始怀疑.当然走之前新leader对我的评价还很不错，但是我感觉我已经受不了阿里，所以还是出来了</li>
<li>8月份来到了七牛云；总体还是比较适应的，而且有伯爵在，压力也不是很大；七牛云做事情还算比较缓，这大概和他们是tob行业有关，所以做事情要确定但不需要太快。总的来说自己还是挺喜欢这边；但是自己现在有一个不好的地方在于被动推着走，这个最近越来越觉得不好；</li>
<li>女儿开始上幼儿园;她感觉还是挺适应的，就是有点不喜欢早起，每天都很难起床;</li>
<li>力量上有一个比较大的提升；从之前俯卧撑做不到10个，现在一次能做30个，并且能做三组；不过到了冬天有点懈怠了，后面继续努力;</li>
</ul>
<h3 id="2-2020的总结回顾"><a href="#2-2020的总结回顾" class="headerlink" title="2. 2020的总结回顾"></a>2. 2020的总结回顾</h3><p>从家庭、事业、身体、投资几个方面来总结一下2020年，总结一下做得好和做的不好的.</p>
<h4 id="2-1-家庭"><a href="#2-1-家庭" class="headerlink" title="2.1 家庭"></a>2.1 家庭</h4><p>和老婆之前的感情在疫情期间有了一个比较好的转变，这实属是一个很好的变化. 之前因为两个人貌似因为孩子的事情导致了很多矛盾，现在放开了说也还好.希望后面能变化的更加好，而且在家庭方面她也比较照顾我，我偶尔的加班也不会说我；关于老婆我还是觉得自己稍微让着点应该会更加和谐一些，<strong>我有的时候实在太直接的，有点没有容人之量的感觉，不够稳重;</strong></p>
<p>女儿现在已经快4岁了，已经是一个很有个性的小姑娘；每个周末都和她一起，所以感情上应该问题不大；很多时候都是比较纵容的态度，所以性格上比较任性，不知道是好是坏。小姑娘现在懂很多很多，但是性格上有点不认错，倔的很；估计后面只能用激将法才能对她有效果。现在基本上通过零食来威胁她，让她能知道不听话的话，最喜爱的东西可能没有了。哎，不过小姑娘真的很可爱，所以教育上就慢慢来，不着急…</p>
<p>自己父母和老婆父母呢，身体都还好；我爸妈都退休了，所以轻松过还好，但是弟弟学习太差，真心是不省心，我不清楚为什么这个时间段的小孩子没有主动求学的心，我当年虽然成绩不算很好，但是我不差，而且我非常想学好离开这个乡下，可能他没有找打自己学习的目标吧。</p>
<h4 id="2-2-事业"><a href="#2-2-事业" class="headerlink" title="2.2 事业"></a>2.2 事业</h4><p>换了工作之后，的确会比较舒心点；也来到了自己很想做的存储方向；目前做的是对象存储，这块我也不算熟悉也不陌生，目前伯爵带着我在弄。我呢，主要是积极性有点不足，导致很多事情都不是很主动，这个后面会慢慢主动起来。</p>
<p>在阿里的大半年，虽然见识到了阿里的不好之处，但是也看到了阿里技术的底蕴；比如如何阐述自己的项目的意义，如何说服别人，如何拉去资源之类的。我这个人比较nice，所以做这些事情会比较难，估计如果后面想要突破，这个方面也需要努力。</p>
<p>技术上呢，应该算是学了点皮毛吧。k8s、mongodb、golang我都学习了一下，但是论深度应该算一般吧。在2020年，接触了一些不错的开源项目和书，可能需要后面花不少时间去理解和深入了解。很多核心问题都有了一定的理解，尤其是网络和操作系统，但是目前这些知识点有点乱，没办法很好的在我的脑子里面构成闭环。准备在2021年写几个围绕某一个问题会进行比较详细的推导和知识点的关联，从操作系统到分布式系统，到业务场景的关联，希望通过这种方式来增加自己的知识的深度和广度.</p>
<h4 id="2-3-身体"><a href="#2-3-身体" class="headerlink" title="2.3 身体"></a>2.3 身体</h4><p>身体上咋说呢，这一年熬了很多次夜，身材也还好，因为一直在锻炼；不过吃的没有管的特别牢，有点随意。很有进步的一点在于稍微学习了一点点健身知识，而且能做90个俯卧撑之类的，这可能是我坚持最后的一个习惯了。</p>
<p>新的一年还是想少熬夜，做运动，管住嘴巴，好好生活。太多猝死有点吓到我了，我还不想那么早死掉。身体是革命的本钱，所以我选择早睡早起.</p>
<h4 id="2-4-投资"><a href="#2-4-投资" class="headerlink" title="2.4 投资"></a>2.4 投资</h4><p>投资咋说呢？算是在门口有点晃荡吧，但是真实的进步还是没有的，因为很多本质的东西没有理解很清楚。所以说有自己的投资体系还是很难的；不过跟老齐投了5个2，给家里做了一点资产配置，到了年底收益都还行，我自己的预估是年回报在10%左右，因为按照这个方式去资产成长的话，我估计在38岁左右就能做到财富自由；当然自己可能是直线看待问题，但是我目标是40岁退休，这个是我和我老婆的想法，因为我两个还是想轻轻松松的过一些日子，而不是这样累死累活，说难听点，就是想为自己活着. </p>
<p>投资可能是我们这代必不可少的技能。其实说难听点的，美国经历过什么我们就会经历过什么，如果股市长期向上这就是我们应该抓住的机会，而这个技能能帮助我们早日实现财富自由。很多人说中年理财然后想逃避中年危机是幻想，我其实觉得不管什么时候理财都是很重要的，中年危机本身需要通过自己的努力去化解的，而理财在这个过程中必不可少。</p>
<h3 id="3-2020年最后"><a href="#3-2020年最后" class="headerlink" title="3. 2020年最后"></a>3. 2020年最后</h3><p>感觉自己在这一年过的还算可以，起码一切都在起步中。理财，健身、技术上的规划都在慢慢的成长中，但是整体的成长来说没有太多大的进步，可能还处于量的积累吧，2021年我的目标是从量积累到质的飞跃，当然如果还不能，那就做海量的积累。</p>
<p>这一年看过几本书和几个公众号，觉得都很不错；分别为:</p>
<ul>
<li>向上生长;豆瓣的一本书，我深刻记得的一句话是：你学不会的很大程度在于你量的积累还不够多;我感受非常深，因为自己其实明白自己为什么学习那么慢，原因就在于基础上还存在不少漏洞，所以很多问题理解的时候并不是那么准确。我要做的是量的积累；</li>
<li>知乎上的一个博主：飞轮学习法，不要太在意一些知识点，如果真的重要那就会经常出现，慢慢的你的脑就会有感觉，但是你要看的多。其实本质就在于量的积累会触发质的飞跃，当然要看好书</li>
<li>微信公众号(复利人生)：这个人会分析股市，但是我觉得更加好的在于对人生的分析，他喜欢孙子兵法和古代的一些故事文章，我看不懂，但是他会解释；他会说炒股就和人生一样，你要有章法你要去分析人性之类的；他的文章写了4年，但是我发现早年的他文章写的也很烂，但是现在的文章写的就很有深度，就他的话来说写文章的好处作者远比读者获得更加多;</li>
<li>一本离开知乎的博主的文章集合：能感觉到这个人应该是40+的大哥了，但是他分析问题非常好，好的地方在于问题的本质；教育、架构等要抓住本质的点在于哪里，其实就可以很好的解决各种问题。</li>
</ul>
<p>最近越来越觉得中国5000年的传承不只是封建，应该还有很多智慧上的提升，时间是一个很好的东西，只要顺着他慢慢的就会成长；一代人不够那就两代人的成长，而中国文化就在这5000年中慢慢成长。所以中国远比我们想象中蕴含着更多的宝藏智慧. 最近在知乎上有一个话题”为什么毛泽东比蒋介石厉害”，其中一个观点就是当年那个时代大家已经对中国文化失去了信心，开始全盘否定中国文化而接受全方面的西化，但是科学技术方面的确落后需要学习，但是人性、战争、辩证、兵法等这些需要时间验证的东西，中国文化有着不可小嘘的底蕴，越是深入越能看到问题的本质。我倒是慢慢有点认同这种观点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.nomoshen.com/christmas-2869817_1280.jpg&quot; alt=&quot;christmas-2869817_1280&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2020年自己的重大事件&quot;&gt;&lt;a href=&quot;#1-2020年
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="年底,总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%95-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>当浮点数作为数据库主键或者索引的时候会发生什么问题</title>
    <link href="http://yoursite.com/2020/12/22/%E5%BD%93%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E6%88%96%E8%80%85%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/12/22/当浮点数作为数据库主键或者索引的时候会发生什么问题/</id>
    <published>2020-12-22T12:56:40.000Z</published>
    <updated>2020-12-22T12:56:40.103Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程、进程和协程的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/线程、进程和协程的那些事情/</id>
    <published>2020-12-22T03:39:45.000Z</published>
    <updated>2020-12-22T03:39:45.483Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库一致性的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/数据库一致性的那些事情/</id>
    <published>2020-12-22T02:27:29.000Z</published>
    <updated>2020-12-22T02:27:29.577Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异步的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E5%BC%82%E6%AD%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/异步的那些事情/</id>
    <published>2020-12-22T02:27:11.000Z</published>
    <updated>2020-12-22T02:27:12.004Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CAP理论</title>
    <link href="http://yoursite.com/2020/10/14/CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/10/14/CAP理论/</id>
    <published>2020-10-14T15:23:43.000Z</published>
    <updated>2020-11-23T01:44:45.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分区更加指的是网络分区，看了知乎上说P这种是指CAP需要解决的故障模型；而为了解决网络分区，从而就出现了多副本的问题，而多副本就引起了一致性的问题，所以为了解决P才引起了CA的选择，而CA的不同权衡也是为了解决系统在出现网络分区的时候能一直运行</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分区更加指的是网络分区，看了知乎上说P这种是指CAP需要解决的故障模型；而为了解决网络分区，从而就出现了多副本的问题，而多副本就引起了一致性的问题，所以为了解决P才引起了CA的选择，而CA的不同权衡也是为了解决系统在出现网络分区的时候能一直运行&lt;/
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="CAP" scheme="http://yoursite.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>债券基金如何波动</title>
    <link href="http://yoursite.com/2020/09/29/%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91%E5%A6%82%E4%BD%95%E6%B3%A2%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/09/29/债券基金如何波动/</id>
    <published>2020-09-28T22:30:25.000Z</published>
    <updated>2020-09-30T01:06:34.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当利率处于下行空间的时候，债市往往容易出现一个所谓的债市牛市。<br>当利率处于上行空间的时候，债市往往容易出现一个所谓的债市熊市。<br>这里的利率就是市场利率。</p>
</blockquote>
<p>上面这句话其实我一直没怎么理解，所以导致我对债券基金整体都不是很了解；今天早上找了一篇文章看了一下感觉越来越清晰，所以记录一下心得; </p>
<h3 id="1-债券市场"><a href="#1-债券市场" class="headerlink" title="1. 债券市场"></a>1. 债券市场</h3><p>在<a href="http://nomoshen.com/2020/03/03/%E4%BD%95%E4%B8%BA%E5%9B%BD%E5%80%BA/" target="_blank" rel="noopener">何为债券</a>中我解释了为什么有债券市场的问题；主要的原因是债券流动性的保证，人们不需要等到真正的债券到期才能拿到收益和本金; 比如我购买了10年的债券，但是由于我急需要现金，但是债券也没有到期，这个时候在古代就很难弄，但是现代就你就可以吧这个债券放到债券市场卖掉，马上就可以变成现金；</p>
<p>而且债券市场的流动性很强，因为债券的收益相对是可计算的和稳定的，所以很好交易；可以认为是类似于美元一样的大家都很认同的东西，交易过程中的信用成本就很低;</p>
<h3 id="2-债券价格"><a href="#2-债券价格" class="headerlink" title="2. 债券价格"></a>2. 债券价格</h3><p>既然在债券市场上做买卖，那么债券的价格是如何确定的；如果把债券当作商品，那么它的价格就有下面的来决定：</p>
<ul>
<li>价值: 债券到期能赚到的钱;专业术语: 票面利率，而这个是由国债利率决定的;</li>
<li>需求关系: 如果市场上有很多很多债券可以购买，那么你的债券价格就会适当下降; </li>
</ul>
<p>所以你在卖出你的债券的时候价格就被这两者所限制；而且债券的价值是一个能被很好计算出来的，所以债券的价格波动和国债利率的走势就是一种强关联的；利率上行价格就往下，利率下行价格就往上; 供需起到相对弱的影响，只是因为市场上的债券多了，可选择的机会就多了，买方购买债券的时候就不一定能选择到你，那你最好降低价格，看是否合适;</p>
<h3 id="3-债券基金"><a href="#3-债券基金" class="headerlink" title="3. 债券基金"></a>3. 债券基金</h3><p>基金就是一个组合或者是一揽子计划；债券基金就是购买几个债券的组合；这个的好处是风险<strong>相对</strong>可控，债券本质是一种借贷关系，那么一定会出现欠钱不还的问题，这就导致了很大的损失；虽然债券稳但不表示无风险，所以买债券基金比你直接买债券会更加好操作，当然所有的都是相对的；之前出现过的<strong>华商固收</strong>就因为自己的组合中有两支暴雷，那个跌幅不低于股票基金的; 所以风险都是有的，基金相对低一些;</p>
<h3 id="4-你在购买债券基金的时候发生了什么？"><a href="#4-你在购买债券基金的时候发生了什么？" class="headerlink" title="4. 你在购买债券基金的时候发生了什么？"></a>4. 你在购买债券基金的时候发生了什么？</h3><ol>
<li>你在利率5%的时候购买了一支债券基金; </li>
<li>债券基金本身的债券组合是相对固定的，比如就是一些国开债+一些企业的债券</li>
<li>这个时候基金的经理就会去二级市场上收<strong>等值份额</strong>的债券组合中的债券给你; 这个份额很好计算，因为每支债券在二级市场都是有价格的，所以基金经理的操作也很简单，拿着你的钱直接买他组合就好;</li>
<li>你的债券基金份额已经到手，成功</li>
</ol>
<h3 id="5-为什么会有波动？"><a href="#5-为什么会有波动？" class="headerlink" title="5. 为什么会有波动？"></a>5. 为什么会有波动？</h3><p>那为什么会波动呢？ 因为市场利率是会变化的; 市场利率的变化就导致借贷成本不一样，本来我借你钱的利息是3%，但是现在整体的利率变高了，我借你钱就需要4%的利率了，这就导致借钱的成本不一样了，这里是升高了; 反应到债券上的逻辑是这样的:</p>
<ol>
<li>2000年,你购买了利率为3%的债券为期5年(我们简单点到期才能拿到本金和利息)</li>
<li>2001年,市场利率变成了4%，现在购买债券的话利息就高1%，但是你手头的债券是3%的，你有点不开心; 所以你想卖掉这个老的债券购买新的债券，这个时候就会产生一个问题；因为大家都知道购买现在的债券才是最划算的，没必要购买你的3%的债券啊，所以你就需要便宜卖给人家；当然这个计算有点复杂，我也不是很会, 大家可以自己操作一把; 那么就可以发现在<strong>当下时代</strong>本来值100元的债券你需要降价卖掉，这就导致了债券价格下降</li>
<li>债券市场每天都在做这个操作，而且债券当下的价格除了利率还有很多因素影响，所以会出现一些价格远低于价值的情况，这个时候就可以通过购买指定债券来保证确定性收益;</li>
<li>还记得上面购买债券基金的过程吗；在结尾处你拿到了一些指定份额的债券，而这个时候由于利率上升从而导致了你的这些指定份额的债券账面价值就减少了，这就导致了你看到的亏损；这就是波动;</li>
</ol>
<p>和股票类似，债券每天的净值都是在变化的，因为债券有确定性收益，所以计算的方式会相对于股票来说简单一些，这也是为什么债券收益率想对于股票要低，因为确定性收益很确定，风险小很多；如果你觉得实在是亏钱难受，你只要不卖，到了时间点拿最后的本金+利息就好，问题也不大; </p>
<h3 id="6-分析一开始结论"><a href="#6-分析一开始结论" class="headerlink" title="6. 分析一开始结论"></a>6. 分析一开始结论</h3><ul>
<li>利率下行是债券牛市的开始; 因为这个时候你购买的债券在未来一定是会涨价的；所以现在购买债券基金你会发现整体上涨;可以赚价格差；</li>
<li>利率上行是债市熊市的开始; 因为你持有的债券会在为了很长时间内都是会跌的；因为后面的债券都是比你有价值的，所以这个时候主要就是要注意了；</li>
<li>这里的利率是市场利率，有的人会说是十年期的国债收益率，其实不是这样的，这是一个因果倒置的问题，是因为市场利率上升了，才会让债券的收益变高了,毕竟票面利率变高了，导致整体的收益率会上来;</li>
</ul>
<blockquote>
<p>债券价格和收益率呈反比例变动。以十年期国债收益率为例，<strong>当前收益率</strong>上涨是由国债价格下跌引起的，而不是收益率上涨引起了债券价格的下跌。</p>
</blockquote>
<h3 id="7-老齐对于债券的投资思路"><a href="#7-老齐对于债券的投资思路" class="headerlink" title="7. 老齐对于债券的投资思路"></a>7. 老齐对于债券的投资思路</h3><p>债券的收益=票面利息 + 价格差; 但是大部分投资者拿债券不是真的为了票息，因为票息是一种保底的操作，假设你什么都不操作等到票息，收益固定，但是时间成本很高；这也就是股市中说的机会成本，因为你把钱放在债券上，那你这部分就不能投入到其他的投资；所以大家那债券大部分时候是为了流动性和相对稳定的波动;</p>
<ol>
<li>当市场利率升高的时候，投资债券不赚钱甚至亏钱，这时候<strong>短债优先</strong>，因为短债都是拿到还本付息的，所以交易价差影响极小;</li>
<li>当市场利率下降的时候，这就是债券牛市的开始，这个时候就可以投资债券，并且要投资<strong>长期债券</strong>,为什么要长期呢？因为未来利率下行，那就代表目前你这个票面利率是未来很有竞争力的存在，可能会产生超额收益；</li>
</ol>
<ul>
<li>问题：为什么债券的价值都那么固定，它的价格还会波动呢？</li>
</ul>
<blockquote>
<p>其实本质在于没有多少人会选择真的拿票息的；机会成本时间成本都是很大的，你硬扛在债券中，你损失的其他机会成本就会很高，所以折价卖也是可能的；还有就是情绪和恐慌，大家怕公司倒闭什么的，就会便宜卖了;</p>
</blockquote>
<ul>
<li>如何确定债券的牛市和熊市?</li>
</ul>
<blockquote>
<ol>
<li>通过比较资产价格；将债券的年华收益与货币基金的7天年华收益率进行比较，如果已经跑不赢的话，就因为避险债券了；债券熊市要来了; 原因很简单的，货币基金本身就是短债 + 超短债 + 现金资产，很好的反应了市场利率的波动，如果货币基金收益率提升，也就表示利率变高了，借钱变难了, 所以这个评判标准貌似很简单;而且债券本身有票面利息，大部分时候是少赚而不会赔</li>
<li>指标:信用利差;这个指标跟国债收益率几乎同时波动，有时候信用利差反应更快，信用利差，也就是3年的3A中票，减去3年国债的收益率，这个利差超过2%的时候，<strong>意味着利率基本到顶</strong>(表示利率要下行，进入牛市)，而这个利差低到0.5%附近的时候，说明信用极宽松，对中小企业和信用债有利，也是债券牛市最后末尾阶段</li>
</ol>
</blockquote>
<ul>
<li>问题:债券基金通常购买的是什么？</li>
</ul>
<p><img src="/images/16014271828437.jpg" alt></p>
<blockquote>
<p>这是一支<code>新华纯债添利债券发起A</code>,可以看到它的债券占用的比例; 你在购买的时候其实就是按照当天净值来购买了这些债券的份额; 通常基金经理会帮我们调整这些债券；也不需要你真的去调整长期债券或者什么的; 债券通常是不大会亏钱的，而且说难听点，债券本身价值是确定的，所以真的拿到了票息也不会亏钱；在债熊的时候也没必要去抄底，到了牛市在购买债券就可以；而且债熊的时候通常是股市牛，这个时候你可以投资股票会更加好;</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当利率处于下行空间的时候，债市往往容易出现一个所谓的债市牛市。&lt;br&gt;当利率处于上行空间的时候，债市往往容易出现一个所谓的债市熊市。&lt;br&gt;这里的利率就是市场利率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这句话其实我一直没怎么理解，所以导致
    
    </summary>
    
      <category term="金融" scheme="http://yoursite.com/categories/%E9%87%91%E8%9E%8D/"/>
    
    
      <category term="债券基金" scheme="http://yoursite.com/tags/%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91/"/>
    
  </entry>
  
  <entry>
    <title>新起步却是一个不一样的开始</title>
    <link href="http://yoursite.com/2020/08/23/%E6%96%B0%E8%B5%B7%E6%AD%A5%E5%8D%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2020/08/23/新起步却是一个不一样的开始/</id>
    <published>2020-08-23T02:02:09.000Z</published>
    <updated>2020-11-27T05:50:55.579Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.nomoshen.com/mountains-5485366_1920.jpg" alt="mountains-5485366_1920"></p>
<p>哈哈哈，这文章算是对过去阿里一年的结束吧; 阿里的这一年让我越加了解自己本身，并且也越加发现什么是自己真的想要的. 目前选择的公司从各方面看来还可以，起码工作内容和气氛都还可以，每天自己可以花很多时间去思考问题并且解决问题，心没那么闹. 希望后面的工作会让自己找到最好的工作状态；这个状态可能也是最适合自己的状态，让自己的在自己思考的道路上一直前进.</p>
<h3 id="1-阿里的这一年"><a href="#1-阿里的这一年" class="headerlink" title="1. 阿里的这一年"></a>1. 阿里的这一年</h3><p>去年的这个时间点，我拿到了阿里的offer,从一个入职没有一个月的创业公司离职,那个创业公司也是坑的不行,所以阿里的offer就想上天给的礼物一样到了我手里. 我心中一直是想去阿里走一下的，我觉得在那里我能见到世界上最厉害的技术.我去阿里想要的就是看更多自己见不到的东西.</p>
<p>来阿里的几个月，我其实很明显能感觉到自己不喜欢这个团队；感觉自己一个开发跑到了一个运维团队,不是说运维不好，只是不适合我. 大概在阿里这几个月，我能明显感觉到的是:</p>
<ul>
<li>团队整体技术性不强,大部分人喜欢人来搞定</li>
<li>老板和我并不合的来，我反馈过事情太简单了,但是他几乎每次都只是说你要自己多想; 关于这点，不同人性格会不一样，我是一个需要有预热过程的人，所以前期更愿意去配合团队去做事情.</li>
<li>做的东西不是很感兴趣</li>
<li>团队有点浑浑噩噩的感觉</li>
</ul>
<p>整体下来我当时的想法是: 我在这边待着估计不行，没有成长. <strong>成长</strong>一直是我在工作过程中非常追求的东西，即使工资低一点我都想要成长. 成长的焦虑也源于未来的不可知；就这样默默的4个月过去了，团队本身的工作压力不大，所以上下班还行. 但是我开始慢慢关注外界的职位消息，那个时候头条的一个职位超级吸引我,但是头条的面试不简单，我需要花点时间准备. 那个时间就开始准备面试了;</p>
<p>在快到了年底，突然被告知了要换团队了，老板要转岗了;说真的我心中很开心，我看了之后那个团队，是一个技术团队,所以我想要不再看看，说不定能有突破呢. 去阿里我想升8，所以有机会我还是想看看的. 就这样决定的话，我就准备了好好做那边的事情,由于对这边团队天生的厌恶感，我就慢慢全心全意到那个团队做事情.</p>
<p><strong>“惊喜”</strong>: 大概在4月中旬还是底来着，我的大老板找我聊天说我的kpi是325,oh no，我从来都没有想过自己的kpi是325. 说真的这是一次打击，我本来还想弄年终奖去抄底股票的呢. 这种意外让我直接就被打击到了。接下来的一个月我几乎每天都很难受，我过的超级不舒服，甚至于我都不想上班. 上班如上坟的感觉；但是我是一个追求稳定性的人，所以我没直接说走人；</p>
<p>负面情绪慢慢的影响了我很久，我知道这样不对，但是很难控制；于是慢慢的我就思考思考，既然这样要不还是走吧.但是我不甘心，我觉得自己很优秀，我不能这样灰溜溜的走. 于是我就想证明一次自己,我找新老板说，我想要自己能独立负责点东西，因为kpi实在不好看.他也答应了. 我和新老板的契合度很高，很快时间就安排清楚并且开始起步.</p>
<p>说真的如果没有那么多事情，我估计和这个老板一直能干下去,其实阿里的事情并不复杂，起码从技术角度上来说是这样的，我自己几乎能owner技术所有的东西，所以按着计划也完成了很多. 当然我也见到了阿里的效率，真的一拖就一个月过去了. 因为事情并不复杂我还开始找工作的过程. </p>
<p>其实在那个时间段，别人觉得我都很开心，但是我其实自己知道自己的心理已经被影响到了，我自己都觉得有点抑郁的; 晚上失眠的情况越来越严重. 这也是我下定决心要走的一个很重要的因素. 咋说呢？阿里的工作压力大吗，其实并没有，只不过心理压力太大;</p>
<p>一个之前公司的朋友找我，说要不要去他的创业公司做中间件负责人；当时我觉得也可以，因为有几个好朋友也在里面，我去了会开心点,但是我心里是虚的，我有点怕我并不能扛得住压力，经过阿里我发现自己其实并不是那么能扛压力的人. 我喜欢舒舒服服的，并且有自己的目标然后稳步前进就好，压力太大我可能并不行。当然这是自己心里的想法，但是我觉得不管怎么样都比留在阿里要开心，所以谈了一下价格就说接了offer,当然创业公司的offer并没有阿里那么多，但是我思考了一下也行;</p>
<p>在新老板给我的季度kpi打了一个3.5+的时候我心里是开心的，因为我起码证明了自己，这是对的起我自己.老板对我做的事情很满意，并且说如果能落地就3.75了. 哎…心中的一块石头放下之后，在下一周我就和老板提了离职,老板很诧异,我一直和他说，这个事情和他没有关系,很多事情其实都是一开始就注定的. </p>
<p>到这里就开始离职阿里的流程了，这一年我在阿里，我感觉经历了超过一年的感觉，我也更加了解自己想要一些什么东西; </p>
<blockquote>
<p>自己更加想要的是一个舒服的环境，然后做这自己想要做的事情; 其实这和加班本身没太多关系，主要在于心情上不会有太多的压力感；在阿里的压力超过了自身的负担,当你平衡不了这个压力之后，你将陷入泥潭. 所以在阿里之后我更加明白，自己的上限在哪里; 选择让自己舒服的环境不断前进，可能是我目前找工作的一个占比很高的一个点;</p>
</blockquote>
<blockquote>
<p>小伙伴总结: 性格上，我更加倾向于找一个自己舒服的环境然后待着; 而不是尝试去改变环境来让自己舒服. 我觉得有道理.非常适合自己本身的特性;</p>
</blockquote>
<p>总结一下去阿里能将遇到的问题:</p>
<ul>
<li>阿里这个公司，包含了大公司该有的所有病，并且还具有了自己独特的病</li>
<li>人生不同时间段并不都适合都阿里</li>
<li>真的压力很大，心理压力超级大; 为了让自己的kpi看着好，有的时候做的事情真不是真有意义</li>
<li>阿里核心技术的确很强; 而且内部的资源分享也很多; 技术靠积累，阿里在这个方面的确有着20年的积累</li>
<li>不同团队差别很大，并不都适合当前的你；选择部门和leader有的时候大于选择阿里这个公司; 这个真的很重要重要;</li>
</ul>
<blockquote>
<p>阿里经历就这么过去吧; 虽然它对我带来的不好影响依然还存在；时间是抚平各种伤口的良药,慢慢消化吧.</p>
</blockquote>
<h3 id="2-选择"><a href="#2-选择" class="headerlink" title="2. 选择"></a>2. 选择</h3><ul>
<li>去创业公司做小团队的team leader</li>
<li>去中型公司做自己喜欢的存储</li>
</ul>
<p>我选择了第二个; 手头有两个offer,一个是朋友公司的team leader,一个是自己喜欢的存储; 第一个offer让我有后路离开阿里,第二个offer让我觉得可以对比一下这两个offer. </p>
<p>其实怎么说呢，理论上按照我这个年纪(31)来说,第一个offer会更加合适一些，因为做技术差不多快6年了，为什么还想纯粹往技术方向发展呢? 其实内心理性分析也应该拿第一个offer冒险后面几年的收益,但是我最后却选择了第二个；个人是这么思考的:</p>
<ol>
<li>心理压力或者需要一点时间来修复自己的自身的心理. 去创业公司的转变 + 非自己擅长的领域都会加大自己的心理压力;经过阿里，我自己的心理抗压能力差的一逼，我预估自己会焦虑不已.</li>
<li>公司的气氛: 第二个公司会更加技术气氛，而且tob公司节奏相对缓慢一点; </li>
<li>理想: 技术领域上想再往存储这块走走，技术上依然还不够;领域也比较窄</li>
<li>生活和待遇: 生活上能有更多自己的时间来安排；待遇上能和阿里持平. </li>
<li>年纪上: 可以再任性两年吧</li>
</ol>
<p>总的来说我做了一个很保守的选择,觉得也挺胆小的. </p>
<h3 id="3-未来"><a href="#3-未来" class="headerlink" title="3. 未来"></a>3. 未来</h3><p>目前已经来到了新公司; 新公司是一个交流负担非常轻的；</p>
<ul>
<li>事情完成即可; 很多其他的东西都没有</li>
<li>简单；同事只是同事，你们可以不要假装来交流</li>
<li>节奏可控;不需要加班加点</li>
<li>做存储，总算转型了</li>
</ul>
<p>反正目前看来一些都还挺好的；当然这只是开始,后面还有很长的路要走. 一个人如果时间很充裕的时候，没有好的目标可能会浪费太多的时间, 所以未来篇幅,主要是为自己的未来做个简单的规划;</p>
<h4 id="3-1-做一个有职业规划的工具人"><a href="#3-1-做一个有职业规划的工具人" class="headerlink" title="3.1 做一个有职业规划的工具人"></a>3.1 做一个有职业规划的工具人</h4><ul>
<li><p>自己的内心</p>
<ul>
<li>喜欢了解底层原理; 了解原理你才能各种推演，而不是死记硬背;</li>
<li>喜欢各种牛逼的技术; 比如raft之类算法，因为它能解决一类问题</li>
<li>喜欢和人讲,但是胆子还挺小的; </li>
<li><p>希望自己能解决别人的疑难杂症</p>
<p>其实自己的内心,还是想在技术这块深根发芽的，得到自己作为技术大神的梦想.并且让自己帮助别人;</p>
</li>
</ul>
</li>
<li><p>职业方向是什么?</p>
<blockquote>
<p>技术架构师: 这个主要考验的架构广度，针对不一样的场景或者特定公司的技术架构，能清晰的知道各个模块完成的任务，整体架构本身的优点缺点等; </p>
</blockquote>
</li>
<li><p>职业规划的中台思维</p>
<ul>
<li>技术前景: <strong>待定</strong></li>
<li>打造个人竞争力: 参加核心项目</li>
<li>积累中台能力: 有意识的构建可复用的能力</li>
</ul>
</li>
</ul>
<p><a href="https://www.yuque.com/fengling-b3el7/ucgu68/wn1x3t" target="_blank" rel="noopener">详情</a></p>
<h4 id="3-2-实操"><a href="#3-2-实操" class="headerlink" title="3.2 实操"></a>3.2 实操</h4><ol>
<li><p>基础这块</p>
<p> 主要是要补全自己基础; 尤其是操作系统+网络这块知识; 这块知识其实越到后面越是很重要,可以不断的拔高你的上限</p>
</li>
<li><p>架构</p>
<ul>
<li><p>公司这边：</p>
<ul>
<li>把开源的mongodb整个流程 + 源码都能吃下来; 然后有比较完整的改造过程;</li>
<li>把公司整套存储的流程整理清楚,尤其是如何存储、如何降低成本、面向的场景等</li>
<li>希望优化整体架构,为公司的成本技术成本有所优化</li>
</ul>
</li>
<li><p>社区和开源</p>
<ul>
<li>tidb + tikv这个开源的能有一个比较好的了解，从源码到整体的周边</li>
<li>对cassandra + scylladb也有一个比较好的了解</li>
<li>了解阿里云 + aws目前云产品和各自的场景、服务对象、解决什么问题等</li>
<li>k8s、微服务、service mesh 这块也慢慢的可以了解起来</li>
<li>等</li>
</ul>
<p>自己的想法是: 存储架构是我的核心技能树,所以需要不断的去完善; 而云产品是未来的方向，需要在我的技术能上不断的扩展;</p>
</li>
</ul>
</li>
<li><p>语言</p>
<p> 目前我自己会的语言有: C++/java/golang/rust; 后面打算:</p>
<ul>
<li>主要语言:C++/golang; golang是云服务时代主流语言，掌握它算是一种跟随时代; C++存储层需要的语言，可能还是需要在看看</li>
<li>次要语言: java/rust,java是目前世界上用的最多的语言，不能提出反驳; rust起码在看tikv的时候还是需要的;而且看看它与C++的差别在哪里</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>上限”文科”</p>
<p> 在离开阿里的最后一次和老板聊天，他和我阐述了关于文理科的思想; 理科可以保证你的下限，但是文科决定了你上限; 在阿里如果没什么意外，技术能达到的最高level是8，后面基本上就是技术达不到的层级了；当然这是一个概率大小的说法; 自己在和阿里p9聊的时候，基本上这个层级的人聊产品形态和规划会偏多一些，技术细节什么的都已经慢慢不是重点;</p>
<p> 文科指什么呢? 更多的应该管理、EQ、交流、格局之类的东西；前期靠技术，后期靠文科这些东西; 而自己目前的感觉是缺失的，而且很大很大. 后面我自己也会想办法补习这些知识;</p>
</li>
<li><p>投资</p>
<p> 这块算是小小的入门，但是总的来说也没咋搞明白过; 所以这块更多是学习，不断的学习. 我对这块的想法是, 慢慢入门,感觉自己还是缺很多的东西，跟着老齐学习的确学到了一些，但是不成体系，这就导致我目前有点糊里糊涂; </p>
<p> 后面这块慢慢找一些书补习一下基础，目前是要在40岁的时候实现财富自由; </p>
</li>
</ol>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>希望在这个道路上能不断的前行，还有10年时间，增加个方面的实力才是王道; 35岁的中年危机对我来说其实不怕,怕自己浪费10年成就不了自己;</p>
<blockquote>
<p>用运气赚的钱，必定会用实力还回去</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.nomoshen.com/mountains-5485366_1920.jpg&quot; alt=&quot;mountains-5485366_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;哈哈哈，这文章算是对过去阿里一年的结束吧; 阿里的这一年让我越加了解自己本身
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>让人难以回答的问题-tcp为什么要进行三次握手</title>
    <link href="http://yoursite.com/2020/07/14/%E8%AE%A9%E4%BA%BA%E9%9A%BE%E4%BB%A5%E5%9B%9E%E7%AD%94%E7%9A%84%E9%97%AE%E9%A2%98-tcp%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://yoursite.com/2020/07/14/让人难以回答的问题-tcp为什么要进行三次握手/</id>
    <published>2020-07-13T23:20:20.000Z</published>
    <updated>2021-01-11T06:01:56.465Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.nomoshen.com/hoarfrost-4739176_1280.jpg" alt="hoarfrost-4739176_1280"></p>
<p>杭州的冬天就是难受，又冷又湿，冻死我了. 今天是周末，女儿还在睡觉，在脑子里面过了很久的一个东西我给记录一下; 其实tcp的3次连接是我一直没搞懂的事情，知其然而不知其所以然可能就是我这种状态，我无数次的去看网上的文章和书籍，但是总觉得缺点为什么会这样的感觉. 最近在看分布式系统的一些书的时候就慢慢有那么点感觉了,我就把自己的不成熟的想法先写下来. </p>
<h3 id="1-关于网络连接"><a href="#1-关于网络连接" class="headerlink" title="1. 关于网络连接"></a>1. 关于网络连接</h3><p>在分布式系统中有提到从单机变成分布式系统之后就遇到了很多很多问题，有的问题在甚至是不可能的，只能不断的收缩前提条件也得到解答. 其中有一个概念就是关于完全异步网络，定义异步网络的有三个点:</p>
<ul>
<li>节点的时钟漂移无上限, </li>
<li>消息的传输延迟无上限, </li>
<li>节点计算的速度不可预料.</li>
</ul>
<p>其中主要还是关注第二条，消息传送延迟无上限, 你可能比较疑惑这点，在tcp的场景下面会有这种情况吗？当然会，因为消息在网络中传播的过程中会进过各种设备，如果设备因为忙碌拥堵导致你的包一直被丢弃，你的包就很长很长时间不能被对端收到；所以在现实系统中，网络是不可靠的，即使在tcp协议的保证下依然不可靠，设计系统本身的时候依然还是需要自己去cover网络出现问题的时候该怎么做.</p>
<p>说完上面的问题，我们思考一下为什么网络是不可靠的呢，难道不能做到可靠吗，起码能保证延迟有上限保证呢;其实有，而且我们生活中常常遇到; 那就是电话线路, 虽然我不知道电话线路真实的物理结构怎么样，但是大概的描述就是每一次电话接通都会占用信号的某一个频率段，我占用的话其他的人就不能被占用了，那么消息转播的延迟基本上就可以被估算出来，大概是信号传播的时间；如果超过这个时间段没有收到对端回复的ack就可以任务消息丢失或者线路本身出现一定的问题; </p>
<p>既然有方式解决这个网络延迟的问题，那为什么不用呢？因为资源利用率的问题；其实电话的线路就类似于目前的城市里面的地铁，而internet就类似于公路；因为地铁是专线专用，所以启停时间都完全可控，只要不需要意外你可以计算出下一班车子什么时候达到，但是如果是在公路上面的车子就不一定的，车子一多很容易就堵车，一堵车你也不知道你什么时间能到公司，所以在公路上开有的时候开很快，有的时候又很慢，慢到难以想象，比如遇到了很多个事故. 回到一开始的问题，那为什么不全部用电话线路呢，因为物理限制和资源利用率，还是用地铁来做比喻的话，不可能没两个点之间都建造一个地铁，1是成本很高 2是如果这条线就没几个人用那资源不是很浪费吗. 所以internet提高了资源利用率和吞吐率，但是带来了网络的各种可知和不可知的问题.因为大家都公用了同一条路，区别点在于如果路比较宽敞的时候就能很快的发送，但是如果路上已经车子很多的情况下，你发送的数据会直接堵在路上，坐等超时，超时完重发依然超时，所以tcp才会有拥塞控制，避免无效的增加网络负担.</p>
<h3 id="2-关于tcp的连接"><a href="#2-关于tcp的连接" class="headerlink" title="2. 关于tcp的连接"></a>2. 关于tcp的连接</h3><p>上面说了连接，那现在说说tcp的连接. tcp是面向“连接”的协议，其实说真的很让人误解，搞的以为tcp真的有一条物理连接在似的. tcp的连接我感觉是一种在创新过程中与过去的电话线路的概念的一种借鉴吧，让大家好理解一些;</p>
<blockquote>
<p>tcp的连接其实并不是真正的连接，它只是tcp两端的自我状态的维护; 这种维护是上层自我概念，底层并没有真实连接存在;</p>
</blockquote>
<blockquote>
<p>tcp协议要解决的是什么问题呢？本质上要解决的是在Internet这种不可靠的网络传输的现状下，如果保证消息一定送达到对方;所以tcp要解决的是消息送达的问题，它本质上就是1. 超时重发 2. ack机制 3. 排序功能,其他的功能主要是为了优化做的;</p>
</blockquote>
<h3 id="3-为什么tcp建立要三次握手呢"><a href="#3-为什么tcp建立要三次握手呢" class="headerlink" title="3. 为什么tcp建立要三次握手呢?"></a>3. 为什么tcp建立要三次握手呢?</h3><p>理论上第二段tcp的本质，就应该知道tcp的三次握手其实是对一下各自状态的过程，对完这个状态我就能保证tcp协议能保证消息一定送达到了对方；那么tcp之间对状态的关键点在于哪里?</p>
<blockquote>
<ol>
<li>ack机制 2. 对一下你发送的下一个数据包的id是什么?</li>
</ol>
</blockquote>
<p><img src="http://cdn.nomoshen.com/16078757149265.jpg" alt></p>
<p>那我们先脱离最后tcp的三次握手来思考一个问题: </p>
<blockquote>
<p>假如让你设计一个协议来完成上面两个问关键点你需要怎么做？</p>
</blockquote>
<p>如果你这么思考你就想: </p>
<ol>
<li>A要告诉B我下一个包的id是多少，并且我要知道B已经收到了我的信息 </li>
<li>B要告诉A我下一个包的Id是多少，并且我要知道A已经收到了我的信息</li>
</ol>
<p>为了这个目标: </p>
<ol>
<li>A发送了一条消息给B，内容为我现在这条消息的Id是x(意味着下一条消息应该是x+1), </li>
<li>B收到了这条消息之后,会返回给A一条消息是ack(x+1)，本意是好的我知道了;</li>
</ol>
<p>而B也会要把自己的信息告诉A，走的流程和A类似，只是A与B互换了一下,那么我们就会发现，在B返回给A Ack的时候其实可以同时把自己的准备发送的消息的Id告诉A，这样就从4次交互变成了三次. 所以三次握手就理论上成立了; 至于如果中间出现了包丢了或者怎么样的，那么会不断的重试，而且在tcp三次握手没有建立起来之前，tcp是不完整的，是不能进行正常的通信，因为两端自己的状态都没有同步好，后面的消息就没办法保证tcp的保证了；</p>
<p>至于建立完“连接”之后呢，其实之后就没关系了，因为每次发送对端都知道你下次包的id是多少，如果没收到我就不返回ack，我不返回ack你就会超时重发，直到我收到为止，就从本质上保证tcp的可靠传输的保证了;</p>
<blockquote>
<p>说难听点，tcp协议就是在internet这种不可靠的网络上建立的软件层面的可靠协议；协议需要至少三次通信才能保证协议的结果，当然我不知道如果用了电话线路这种模式，构建可靠协议会变成怎么样？或者会变得很简单，1. 超时可控 2. 流量也可控，我能很好预估吞吐不需要做额外的算法； 我思考可能会更加简单一些;</p>
</blockquote>
<h3 id="4-至于为什么要4次挥手呢"><a href="#4-至于为什么要4次挥手呢" class="headerlink" title="4. 至于为什么要4次挥手呢?"></a>4. 至于为什么要4次挥手呢?</h3><p>本质上tcp包含了两条链路，A-&gt;B和B-&gt;A两条，A往B发送和B往A发送；当A想和B断的时候B可能还不想断；现实中的例子，我觉得可能是朋友吧，A和B是好朋友，突然有一天A单方面不想和B做好朋友了，就不给东西给B；可是B还是认为A是好朋友，就不断吧自己的东西给A；当然这个例子有点牵强. </p>
<p>所以4次挥手本质上还是在于A-&gt;B这条链路断链的过程:</p>
<ol>
<li>A-&gt;B</li>
<li>B-&gt;A 我知道你和我断链了，但是我现在还不想和你断链;</li>
</ol>
<p>过了一段时间B也觉得这样没意思就发送断链的请求</p>
<ol>
<li>B-&gt;A 断链</li>
<li>A-&gt;B 好的我收到了你的请求，你总算愿意了</li>
</ol>
<p><img src="http://cdn.nomoshen.com/16078771565521.jpg" alt></p>
<h4 id="是否真的需要4次挥手吗？"><a href="#是否真的需要4次挥手吗？" class="headerlink" title="是否真的需要4次挥手吗？"></a>是否真的需要4次挥手吗？</h4><ol>
<li>如果正常的分手的话，问题都不大的；四次挥手正常走下来也ok</li>
<li>客户端如果直接把来回的通道全部关闭了；那么其实4次挥手就不能正常结束了；通常客户端在FIN2这种状态一定时间之后就直接关闭了，这样能保证资源比较好的释放；在这个时候如果对端依然发送数据过来，会马上获得一个RST这恢复，tcp在收到这样的返回之后基本上就知道对端已经不在服务状态，于是就正常关闭这个服务;</li>
</ol>
<h4 id="A主动请求的状态演变"><a href="#A主动请求的状态演变" class="headerlink" title="A主动请求的状态演变:"></a>A主动请求的状态演变:</h4><ol>
<li>FIN_WAIT_1</li>
<li>FIN_WAIT_2</li>
<li>TIME_WAIT:这个小子总算可以和我分手了;</li>
<li>CLOSED: 与TIME_WAIT之间需要等待2 * MSL, 也就是包在网络中存活的最长时间;</li>
</ol>
<p>为什么要等那么长时间呢？</p>
<ol>
<li>因为client在Time_wait阶段返回给服务端的ack的包可能要丢失，需要等一下服务端重试B-&gt;A的断开的包</li>
<li>time_wait的包发送丢失最大需要MSL(这个包会彻底的消失), 服务端第二次重试包超过MSL还没有被搜到的话那肯定就再也搜不到了;client做到这步已经仁至义尽了，依然已经分开了后面我也不管了; </li>
</ol>
<h4 id="B的状态演变"><a href="#B的状态演变" class="headerlink" title="B的状态演变"></a>B的状态演变</h4><ol>
<li>CLOSE_WAIT: 接受到A主动断开之后，它的状态就变成等待被关闭；</li>
<li>LAST_ACK: B也主动发送A断开链接，然后就主动等待最后的ACK</li>
<li>CLOSED:收到ack就正确关闭；</li>
</ol>
<p>如果LAST_ACK超时会怎么样，看分析有几个:</p>
<ol>
<li>如果超时重发之后，A还是time_wait状态的话就会重新ack，如果ack收到几句进入closed</li>
<li>如果超时重发之后，A已经是CLosed状态那么就回复RST的回复，这个时候B收到就进行closed</li>
<li>如果LAST_ACK一直超时一直重试，大概等到tcp的最长时间就会进行closed状态</li>
</ol>
<h3 id="5-一些参考文档"><a href="#5-一些参考文档" class="headerlink" title="5. 一些参考文档"></a>5. 一些参考文档</h3><ul>
<li><a href="https://www.zhihu.com/question/27564314" target="_blank" rel="noopener">在tcp协议中处于last_ack状态的连接，如果一直收不到对方的ack，会一直处于这个状态吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗</a></li>
<li><a href="http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/" target="_blank" rel="noopener">TCP协议的那些超时</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.nomoshen.com/hoarfrost-4739176_1280.jpg&quot; alt=&quot;hoarfrost-4739176_1280&quot;&gt;&lt;/p&gt;
&lt;p&gt;杭州的冬天就是难受，又冷又湿，冻死我了. 今天是周末，女儿还在睡觉，在脑子里
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>从leveldb的wal恢复到hbase的hlog恢复看seqId</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BB%8Eleveldb%E7%9A%84wal%E6%81%A2%E5%A4%8D%E5%88%B0hbase%E7%9A%84hlog%E6%81%A2%E5%A4%8D%E7%9C%8BseqId/"/>
    <id>http://yoursite.com/2020/07/14/从leveldb的wal恢复到hbase的hlog恢复看seqId/</id>
    <published>2020-07-13T23:16:01.000Z</published>
    <updated>2020-07-13T23:16:01.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LevelDB源码(五、leveldb write流程)</title>
    <link href="http://yoursite.com/2020/07/11/LevelDB%E6%BA%90%E7%A0%81-%E4%BA%94%E3%80%81leveldb-write%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/11/LevelDB源码-五、leveldb-write流程/</id>
    <published>2020-07-11T02:06:28.000Z</published>
    <updated>2020-07-14T00:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leveldb的写流程分析，这个过程对比读来说已经简单很多，但是里面也涉及到很多的点；尤其是如果在线程安全的情况下进行批量写，如何保证多版本等; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  Writer w(&amp;mutex_);</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = false;</span><br><span class="line"></span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line">  /**</span><br><span class="line">   * w.done: 表示是否完成</span><br><span class="line">   * writers_.front: 表示当前write是否是最前面的writer</span><br><span class="line">   *</span><br><span class="line">   * 如果未完成并且当前写入不是最久未完成的write，就进行等待;</span><br><span class="line">   */</span><br><span class="line">  while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">    w.cv.Wait();</span><br><span class="line">  &#125;</span><br><span class="line">  if (w.done) &#123;</span><br><span class="line">    return w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //当前的writer是最前面的writer，有他来完成整体写入</span><br><span class="line">  // May temporarily unlock and wait.</span><br><span class="line">  Status status = MakeRoomForWrite(updates == nullptr);</span><br><span class="line">  uint64_t last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  if (status.ok() &amp;&amp; updates != nullptr) &#123;  // nullptr batch is for compactions</span><br><span class="line">    WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">    //设置了一个新的seqId</span><br><span class="line">    WriteBatchInternal::SetSequence(write_batch, last_sequence + 1);</span><br><span class="line">    //seq跳变到很大, 这是因为这里面包含了多个写操作，每一个put操作都会对应一个seqId</span><br><span class="line">    last_sequence += WriteBatchInternal::Count(write_batch);</span><br><span class="line"></span><br><span class="line">    // Add to log and apply to memtable.  We can release the lock</span><br><span class="line">    // during this phase since &amp;w is currently responsible for logging</span><br><span class="line">    // and protects against concurrent loggers and concurrent writes</span><br><span class="line">    // into mem_.</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为什么可以释放的原因在于：即使释放了，只是让更多的数据进入队列，但是put线程都会堵在获得mutex_上面</span><br><span class="line">     * 所以这里不会有并发问题，释放了可以让更多的数据进来;</span><br><span class="line">     */</span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      //1. 写wal，写成功了才返回</span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">      bool sync_error = false;</span><br><span class="line">      if (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        if (!status.ok()) &#123;</span><br><span class="line">          sync_error = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (status.ok()) &#123;</span><br><span class="line">        //2. 写memtable</span><br><span class="line">        status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      if (sync_error) &#123;</span><br><span class="line">        // The state of the log file is indeterminate: the log record we</span><br><span class="line">        // just added may or may not show up when the DB is re-opened.</span><br><span class="line">        // So we force the DB into a mode where all future writes fail.</span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 因为返回的write_batch可能本身就有可能不是与tmp_batch_一样的，所以就需要</span><br><span class="line">     */</span><br><span class="line">    if (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line">    //跳变的序列号</span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 自己不需要唤醒自己</span><br><span class="line">   */</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    Writer* ready = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    if (ready != &amp;w) &#123;</span><br><span class="line">      //唤醒其他的等待写入的线程</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = true;</span><br><span class="line">      ready-&gt;cv.Signal();</span><br><span class="line">    &#125;</span><br><span class="line">    if (ready == last_writer) break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Notify new head of write queue</span><br><span class="line">  if (!writers_.empty()) &#123;</span><br><span class="line">    //如果队列非空就发消息给头部，让他来做写入操作</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1. 大致流程"></a>1. 大致流程</h3><p><code>DB::put-&gt;DBImpl:Write</code>,其实写的流程大致是这样，把握这个细节可以让你在看源码的过程中不会太迷茫；</p>
<ol>
<li>构建<code>WriteBatch</code>实例，这个类作用就是用来合并写操作的，构建出一个批量写入的对象；这个对象也挺有意思的，后面会分析</li>
<li>将<code>WriteBatch</code>放到一个队列中去; 队列存放的都是一次put操作的<code>WriteBatch</code>对象，可想而知，这里的writebatch目前都还是单次操作的数据</li>
<li>让某一个线程去对队列中的WriteBatch操作进行合并</li>
<li>记入WAL</li>
<li>写入Memtable；这边需要注意的是:<strong>wal写入成功之后才会写memtable</strong></li>
<li>唤醒一些线程，然后返回结果;</li>
</ol>
<p>所以这个流程中，需要关注的点在于WriteBatch的合并、高性能的原因、wal和memtable的写入过程，当然还是有seqId的变化;</p>
<h3 id="2-WriteBatch合并"><a href="#2-WriteBatch合并" class="headerlink" title="2. WriteBatch合并"></a>2. WriteBatch合并</h3><p>首先WriteBatch是一个非常简单的合并的对象，它线程不安全；那如何在多线程操作的时候去保证写入是线程安全的呢？这个其实真的是leveldb的一个不错的优化，导致后期的很多的代码都按照这个模式进行优化;</p>
<h4 id="2-1-如何做到多线程写入安全？"><a href="#2-1-如何做到多线程写入安全？" class="headerlink" title="2.1 如何做到多线程写入安全？"></a>2.1 如何做到多线程写入安全？</h4><p>其实看dbimpl可以看出它的<code>mutex</code>其实就只有一个，如果在减少锁粒度的情况下，保证高性能的呢; 本身我觉得对于资源竞争这个问题，能解决的方式其实可以归类于几种：</p>
<ul>
<li>锁，一定是最安全的；根据不同的场景，使用不同的锁可以有着不错的性能</li>
<li>原子变量； 本质上是内存模型+cas的方式进行，与锁的不同在于底层保证原子性，缺点在于：不通用，只能针对某一些数据类型</li>
<li>threadlocal变量; 性能上应该问题不大，问题在于场景上还是很收到限制的；假如你要中心管理的时候，就比较难受，而且可见的内存占用；典型的用空间换时间的方案；但是大部分时候可以用用，反正可以用方案绕过上面的这些问题，只是不优雅而已;</li>
<li>让所有的资源的操作都放到一个线程去操作；这样可以保证绝对的线程安全；但是问题在于不是所有的场景你都能接受这个，之前的问题在于需要返回结果，目前貌似用futurn + promise可以进行;</li>
</ul>
<p>而锁的优化大部分的方式就是：1. 用不同的锁 2. 缩小锁的粒度，通过使用细粒度锁来进行保证 3. 尽可能的减少锁的范围，不知道算不算和第二种类似; </p>
<p>但是在leveldb中，它就通过一个mutex是如何保证高性能呢？答案是：</p>
<ul>
<li>leveldb的场景; 因为leveldb本身是一个io密集性的应用，这就代表了cpu大部分时候等待着io，那么多线程的优势就没有多少价值；</li>
<li>让一个线程尽可能多做点事情；批量写入只是选择了一个线程，并且让它做合并、写入wal、写入memtable的操作；其他的线程等待即可; 当然这个也是因为上面的leveldb的场景才能这样，如果是一个cpu密集性的应用，那这个方式基本上不行，因为多核优势就没有了；</li>
</ul>
<h4 id="2-2-WriteBatch分析"><a href="#2-2-WriteBatch分析" class="headerlink" title="2.2 WriteBatch分析"></a>2.2 WriteBatch分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) &#123;</span><br><span class="line">  SetCount(dst, Count(dst) + Count(src));</span><br><span class="line">  assert(src-&gt;rep_.size() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.append(src-&gt;rep_.data() + kHeader, src-&gt;rep_.size() - kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>合并结构的分析</li>
</ul>
<p><img src="media/15946849685529.jpg" alt></p>
<ul>
<li><p>前面12个字节是header，用来保存</p>
<ul>
<li>seqId：这个批量操作的起始seqId</li>
<li>count: 合并操作的个数</li>
</ul>
</li>
<li><p>后面就是：kv的list；第一个字节是操作的类型;</p>
</li>
</ul>
<h4 id="2-3-合并时机"><a href="#2-3-合并时机" class="headerlink" title="2.3 合并时机"></a>2.3 合并时机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">&#125;</span><br><span class="line">if (w.done) &#123;</span><br><span class="line">  return w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是上面写入过程中会遇到的一段代码，通常put进来之后必定会运行这段代码，这段代码的含义是: 假如w没有完成 或者 w不是队列中最早进来的那个写入，那么就进行等待；是不是很神奇；其实这个原因在于：大部分写入的操作只是将写入操作放入队列；但是肯定有那么一个write它进来的时候就是第一个写入，所以它不会进入等待状态，就开始后面的操作；</p>
<p>那你问题肯定是，那也只有一个是第一个写入操作啊，当然在后期写入完成之后会唤醒这种等待，那个时候写完就会被提出队列，那么自然会有新的最早的写入咯</p>
<h3 id="3-腾出空间进行写入操作"><a href="#3-腾出空间进行写入操作" class="headerlink" title="3. 腾出空间进行写入操作"></a>3. 腾出空间进行写入操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 看名字就是说为写入过程预留空间，可能会检查</span><br><span class="line"> *</span><br><span class="line"> * 1. level0的文件个数是否已经操作一个阈值</span><br><span class="line"> * 2. memtable是否已经满</span><br><span class="line"> * 3. 如果memtable是full。并且immtable 为空，所以内存中已经满了，需要进行compaction，这个时候就唤醒背后线程</span><br><span class="line"> * 4. l0文件依然还是很多，需要唤醒compaction</span><br><span class="line"> * * @param force</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Status DBImpl::MakeRoomForWrite(bool force) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  bool allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!bg_error_.ok()) &#123;</span><br><span class="line">      // Yield previous error</span><br><span class="line">      s = bg_error_;</span><br><span class="line">      break;</span><br><span class="line">    &#125; else if (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(0) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      // 判断当前的level0层次的文件是否已经达到需要慢慢写入的过程，可能写的太快，compaction来不及</span><br><span class="line">      // We are getting close to hitting a hard limit on the number of</span><br><span class="line">      // L0 files.  Rather than delaying a single write by several</span><br><span class="line">      // seconds when we hit the hard limit, start delaying each</span><br><span class="line">      // individual write by 1ms to reduce latency variance.  Also,</span><br><span class="line">      // this delay hands over some CPU to the compaction thread in</span><br><span class="line">      // case it is sharing the same core as the writer.</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      env_-&gt;SleepForMicroseconds(1000);</span><br><span class="line">      allow_delay = false;  // Do not delay a single write more than once</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">    &#125; else if (!force &amp;&amp;</span><br><span class="line">               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">      // There is room in current memtable</span><br><span class="line">      break;</span><br><span class="line">    &#125; else if (imm_ != nullptr) &#123;</span><br><span class="line">      // We have filled up the current memtable, but the previous</span><br><span class="line">      // one is still being compacted, so we wait.</span><br><span class="line">      Log(options_.info_log, &quot;Current memtable full; waiting...\n&quot;);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">    &#125; else if (versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">      // There are too many level-0 files.</span><br><span class="line">      Log(options_.info_log, &quot;Too many L0 files; waiting...\n&quot;);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 判断到最后的情况就是：mem已经满，但是imm还没有，这个时候就切换memtable，生成一个新memtable，顺便切换了wal</span><br><span class="line">       * wal的大小和memtable大小数据差不多吧，每次都切换memtable都会切换wal</span><br><span class="line">       */</span><br><span class="line">      // Attempt to switch to a new memtable and trigger compaction of old</span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == 0);</span><br><span class="line">      uint64_t new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = nullptr;</span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      if (!s.ok()) &#123;</span><br><span class="line">        // Avoid chewing through file number space in a tight loop.</span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      delete log_;</span><br><span class="line">      delete logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = new log::Writer(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.store(true, std::memory_order_release);</span><br><span class="line">      mem_ = new MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = false;  // Do not force another compaction if have room</span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次写操作都会进行这样的判断，用来确定当前写入是否要进行必要的变化；这种变化可能会有：</p>
<ul>
<li>memtable转成immutable</li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leveldb的写流程分析，这个过程对比读来说已经简单很多，但是里面也涉及到很多的点；尤其是如果在线程安全的情况下进行批量写，如何保证多版本等; &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(四、leveldb open流程)</title>
    <link href="http://yoursite.com/2020/07/06/LevelDB%E6%BA%90%E7%A0%81-%E5%9B%9B%E3%80%81leveldb-open%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/06/LevelDB源码-四、leveldb-open流程/</id>
    <published>2020-07-06T03:15:42.000Z</published>
    <updated>2020-07-11T02:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于到了正常讲流程的，对于leveldb来说，让我来看最主要的几个关键点在于：</p>
<ul>
<li>打开leveldb的过程；涉及到了数据如何从文件中恢复回来的问题；</li>
<li>write流程</li>
<li>open流程</li>
<li>compaction</li>
<li>版本管理</li>
</ul>
<p>今天这文章主要讲到的是db open的流程，这个过程中会涉及到很多的相关的组建，靠着这些组件才能保证持久化数据的完整性; 对leveldb的文件进行分类并且的功能介绍：</p>
<ul>
<li>sstable: 数据持久化,真正用来存储数据</li>
<li>manifest: 所有的version、versionEdit都会按照顺序写入到这个文件中；</li>
<li>WAL: 以log为结尾，wal日志，顺序写，保证数据恢复使用;</li>
<li>CURRENT: 里面记录了当前真正在使用的manifest</li>
<li>LOCK：文件锁</li>
<li>LOG.*: 表示日志文件;</li>
</ul>
<h3 id="1-打开Leveldb"><a href="#1-打开Leveldb" class="headerlink" title="1. 打开Leveldb"></a>1. 打开Leveldb</h3><p>在open db的过程中，leveldb主要做了三件事情：</p>
<ul>
<li>初始化一个最初的dbimpl对象，这个对象包含了很多内容，在系列第三篇文章中有介绍;</li>
<li>恢复版本管理的的内容，主要是从manifest文章中读出来VersionEdit，然后慢慢的构造最新的version</li>
<li>恢复wal中的数据，并不是所有的wal都需要恢复，但是在version恢复过程中可以获得需要恢复的内容;</li>
</ul>
<p>核心代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, DB** dbptr) &#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> DBImpl(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.Lock();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 恢复version和wal</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status s = impl-&gt;Recover(&amp;edit, &amp;save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">    WritableFile* lfile;</span><br><span class="line">    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                     &amp;lfile);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      edit.SetLogNumber(new_log_number);</span><br><span class="line">      impl-&gt;logfile_ = lfile;</span><br><span class="line">      impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">      impl-&gt;log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      impl-&gt;mem_ = <span class="keyword">new</span> MemTable(impl-&gt;internal_comparator_);</span><br><span class="line">      impl-&gt;mem_-&gt;Ref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.SetLogNumber(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">//删除不必要的文件</span></span><br><span class="line">    impl-&gt;RemoveObsoleteFiles();</span><br><span class="line">    impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.Unlock();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    assert(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的点在于: impl-&gt;Recover这个函数里面，里面主要包含了version恢复 + wal的恢复; 恢复完毕之后整个db就处于在上一次停止之后的一个比较完整的状态; 基于这个状态的db数据是没有”丢失”的; recover函数的代码量还是很大的，分成两块，分别为version recover + wal的recover;</p>
<h4 id="1-1-Version-Recover的过程"><a href="#1-1-Version-Recover的过程" class="headerlink" title="1.1 Version Recover的过程"></a>1.1 Version Recover的过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取manifest中的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  s = edit.DecodeFrom(record);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">        edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</span><br><span class="line">      s = Status::InvalidArgument(</span><br><span class="line">          edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</span><br><span class="line">          icmp_.user_comparator()-&gt;Name());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    builder.Apply(&amp;edit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">    log_number = edit.log_number_;</span><br><span class="line">    have_log_number = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">    prev_log_number = edit.prev_log_number_;</span><br><span class="line">    have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">    next_file = edit.next_file_number_;</span><br><span class="line">    have_next_file = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">    last_sequence = edit.last_sequence_;</span><br><span class="line">    have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑是: </p>
<ul>
<li>读取manifest中的每一个VersionEdit的内存，然后慢慢的恢复到Version中去; 如果按照git的逻辑就是，如果所有的commit都在，那就一定能构建出来完整的数据;</li>
<li>从manifest中读取的每一个VersionEdit，通过builder.Apply(&amp;edit)会被应用到一起，慢慢累积的过程;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑：</p>
<ol>
<li>更新VersionSet的compact_pointers_的数据; 这个参数主要是包含了每一层下一次要进行compact的开始的startkey;</li>
<li>VersionEdit要删除的文件进行汇总</li>
<li>VersionEdit新增的文件进行汇总</li>
<li><p>在过程中还会不断的统计这四个参数:</p>
<ul>
<li>log_number_: 用到的wal的id</li>
<li>prev_log_number_: 前一个wal的id，这个id也不知道是怎么被赋值的，但是很重要，因为也保证了数据的不丢;</li>
<li>next_file_number_: 下一个文件的id，这个id用于多种文件类型</li>
<li>last_sequence_: 最大的序列id</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    Finalize(v);</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    manifest_file_number_ = next_file;</span><br><span class="line">    next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">    last_sequence_ = last_sequence;</span><br><span class="line">    log_number_ = log_number;</span><br><span class="line">    prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">最后把所用的VersionEdit都恢复回来变成了Version，然后leveldb就你会把当前的version固化，并且放到versionSet中; 到目前为止，版本是恢复回来了，现在就要对真实的文件进行处理了；</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.2</span> WAL文件的恢复</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 版本中包含的log是已经被写入到sstable中的，但是wal中的log可能还没有写入到sstable中，</span></span><br><span class="line"><span class="comment">   * 所以必须需要将这些没有正常写入的wal恢复回来</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">      expected.erase(number);</span><br><span class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!expected.empty()) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                  <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  <span class="built_in">std</span>::sort(logs.begin(), logs.end());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">    s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;SetLastSequence(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 通过VersionSet可以知道当前应该存在有哪些文件</span><br><span class="line"><span class="number">2.</span> 通过目录可以获得当前db真实存在有哪些文件，</span><br><span class="line"><span class="number">3.</span> 进行比较，多余的进行删除，少的就进行报错，理论上不应有这样的问题;</span><br><span class="line"></span><br><span class="line">这边看到WAL的恢复的逻辑是:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"> <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.push_back(number);</span><br></pre></td></tr></table></figure>
<p>如果是kLogFile类型的文件，并且文件id小于等于min_log,或者等于prev_log，小于等于我懂，因为即使版本中包含了log_number，也不能保证wal都被消费掉了，所以需要重新会滚；prev_log目前还不清楚是什么含义(TODO);</p>
<p>wal的文件id会进行排序，然后按照顺序进行恢复; 恢复过程后面细讲;</p>
<h4 id="1-3-善后的工作"><a href="#1-3-善后的工作" class="headerlink" title="1.3 善后的工作"></a>1.3 善后的工作</h4><ol>
<li>会将本次的恢复过程按照一次VersionEdit进行写入到文件;</li>
<li>删除一些多余的文件</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于到了正常讲流程的，对于leveldb来说，让我来看最主要的几个关键点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开leveldb的过程；涉及到了数据如何从文件中恢复回来的问题；&lt;/li&gt;
&lt;li&gt;write流程&lt;/li&gt;
&lt;li&gt;open流程&lt;/li&gt;
&lt;li&gt;compacti
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(三、leveldb DBImpl成员分析)</title>
    <link href="http://yoursite.com/2020/07/02/LevelDB%E6%BA%90%E7%A0%81-%E4%B8%89%E3%80%81leveldb-DBImpl%E6%88%90%E5%91%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/02/LevelDB源码-三、leveldb-DBImpl成员分析/</id>
    <published>2020-07-02T14:36:07.000Z</published>
    <updated>2020-07-06T06:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤其在于Leveldb在被打开瞬间，数据如何恢复特别的重要.</p>
<h4 id="1-DBImpl类的数据成员"><a href="#1-DBImpl类的数据成员" class="headerlink" title="1. DBImpl类的数据成员"></a>1. DBImpl类的数据成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> DBImpl: <span class="keyword">public</span> DB &#123;</span><br><span class="line">  <span class="comment">//指定环境的工具类，比如文件操作之类的</span></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator internal_comparator_;</span><br><span class="line">  <span class="keyword">const</span> InternalFilterPolicy internal_filter_policy_;</span><br><span class="line">  <span class="keyword">const</span> Options options_;  <span class="comment">// options_.comparator == &amp;internal_comparator_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否是自己管理infolog和blockcache,通常都是leveldb自己去管理，而非调用者来传入</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_info_log_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_cache_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// table_cache_ provides its own synchronization</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提供对于leveldb的文件信息的管理，所以它的大小为最大打开文件个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock over the persistent DB state.  Non-null iff successfully acquired.</span></span><br><span class="line">  FileLock* db_lock_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State below is protected by mutex_</span></span><br><span class="line">  port::Mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; shutting_down_;</span><br><span class="line">  port::<span class="function">CondVar background_work_finished_signal_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; has_imm_;         <span class="comment">// So bg thread can detect non-null imm_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//WAL的文件，logFiles用在后面的log_上面</span></span><br><span class="line">  WritableFile* logfile_;</span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="function">logfile_number_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 感觉是WAL的类,用来存储put的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">log</span>::Writer* log_;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="function">seed_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// For sampling.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue of writers.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  leveldb是结合多个写入然后才操作memtable + wal；而这个对象就是WriteBatch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SnapshotList snapshots_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line">  <span class="comment">// part of ongoing compactions.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; <span class="function">pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Has a background compaction been scheduled or is running?</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> background_compaction_scheduled_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ManualCompaction* manual_compaction_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">VersionSet* <span class="keyword">const</span> versions_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Have we encountered a background error in paranoid mode?</span></span><br><span class="line">  <span class="function">Status bg_error_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只是展示了数据成员，没有写成员函数;想看具体在<code>db_impl.h</code>文件中;下面就具体分析这些数据成员：</p>
<ul>
<li>env_: 内部封装了一些与os相关的操作，主要是读写、生成文件之类的; 默认以default为主</li>
<li>internal_comparator_: 内部字符串的对比方式;默认字节序列比较</li>
<li>internal_filter_policy_: 默认是bloom过滤器，本身是为了减少对磁盘操作而产生的过滤器</li>
<li>options_：本系列的第二篇文章讲了关于db option的细节，大部分使用默认值，如果用户想修改的话，就需要在打开db的时候就赋值</li>
</ul>
<hr>
<ul>
<li>owns_info_log_: 是否使用的是内部自己的打日志的文件，如果是自己的话，需要在最后自己释放掉</li>
<li>owns_cache_：是否自己提供了blockcache的方式，默认是用了LRU的方式来实现这个</li>
<li>dbname_: leveldb的路径</li>
<li>table_cache_: 主要是一些经常打开的sstable的文件缓存，如果经常访问就不需要经常去open;也是使用了LRU的方式进行管理</li>
<li>db_lock_： 文件锁，其实也不是真的文件锁，只不过用一个文件来保存这个状态，方式两次打开相同的db;</li>
</ul>
<hr>
<ul>
<li>mutex_: 用于保护一些关键变量的线程安全</li>
<li>shutting_down_： 是否正在关闭</li>
<li>background_work_finished_signal_: 条件变量，用来通知背后工作线程已经运行关闭，到时候会进行通知;</li>
</ul>
<hr>
<ul>
<li>mem_: memtable; </li>
<li>imm_：不可变的memtable</li>
<li>has_imm_：是否有不可变的memtable</li>
</ul>
<hr>
<ul>
<li>logfile_: wal对应的文件</li>
<li>logfile_number: 表示当前的wal的文件名；在leveldb中文件名通常都是编号；leveldb通过增量的方式来保证唯一性；这样不需要保存文件名;</li>
<li>log_: 对logfile_的封装，可以读写操作</li>
<li>seed_： 看了后期使用的过程，主要是为了后期的随机数使用,可能是为了更加随机一些吧</li>
<li>writers_: deque的队列，是用来存放写操作的双端队列; 通过上面的mutex_来保证线程安全；通过用户调用put之后，会将写操作放到这里面; 后面有线程进行批量的写入;</li>
<li>tmp_batch_: writeBatch类型，用来做批量写入的时候使用，不过为什么需要一个这个成员变量，需要后面看到再来解答; TODO</li>
<li>snapshots_: 维持目前db返回给外界的snapshot的一个list;是一个双向链表</li>
<li>pending_outputs_: 看注解应该是一些被保护防止被删除的文件;  TODO</li>
<li>background_compaction_scheduled_： 是否开启自动compaction的调度worker</li>
<li>manual_compaction_： 记录当前db手动compaction的信息，主要起到管理作用</li>
<li>versions_: 版本管理器; 这是一个常量指针，也就是被赋值之后不能被修改，但是可以修改内容</li>
<li>bg_error_： 与option中的<code>paranoid mode</code>一起使用</li>
<li>stats_: leveldb多层结构中，每层的compaction的状态</li>
</ul>
<p>默认构造函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::DBImpl(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span><br><span class="line">    : env_(raw_options.env),</span><br><span class="line">      internal_comparator_(raw_options.comparator),</span><br><span class="line">      internal_filter_policy_(raw_options.filter_policy),</span><br><span class="line">      options_(SanitizeOptions(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      owns_info_log_(options_.info_log != raw_options.info_log),</span><br><span class="line">      owns_cache_(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      table_cache_(<span class="keyword">new</span> TableCache(dbname_, options_, TableCacheSize(options_))),</span><br><span class="line">      db_lock_(<span class="literal">nullptr</span>),</span><br><span class="line">      shutting_down_(<span class="literal">false</span>),</span><br><span class="line">      background_work_finished_signal_(&amp;mutex_),</span><br><span class="line">      mem_(<span class="literal">nullptr</span>),</span><br><span class="line">      imm_(<span class="literal">nullptr</span>),</span><br><span class="line">      has_imm_(<span class="literal">false</span>),</span><br><span class="line">      logfile_(<span class="literal">nullptr</span>),</span><br><span class="line">      logfile_number_(<span class="number">0</span>),</span><br><span class="line">      log_(<span class="literal">nullptr</span>),</span><br><span class="line">      seed_(<span class="number">0</span>),</span><br><span class="line">      tmp_batch_(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      background_compaction_scheduled_(<span class="literal">false</span>),</span><br><span class="line">      manual_compaction_(<span class="literal">nullptr</span>),</span><br><span class="line">      versions_(<span class="keyword">new</span> VersionSet(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化之后都是默认值，但是在<code>DB:open</code>函数调用之后都会从文件中恢复出之前持久化的数值;</p>
<h4 id="2-VersionSet，Leveldb的版本管理"><a href="#2-VersionSet，Leveldb的版本管理" class="headerlink" title="2. VersionSet，Leveldb的版本管理"></a>2. VersionSet，Leveldb的版本管理</h4><p>所谓版本管理，主要指的是Leveldb去管理sstable、wal、manifest等一些本地的文件；而这些文件会随着compaction的操作而变化，所以需要有版本管理器来管理这些;</p>
<p>在网上看到一<a href="https://sf-zhou.github.io/leveldb/leveldb_07_version.html" target="_blank" rel="noopener">文章</a>,里面有一个比喻会比较形象来描述这些概念:</p>
<ul>
<li>VersionEdit: 类似于git的一个commit，记录了本次的变化</li>
<li>Version: 表示git当前的版本；就是git log中展示的那个唯一id; 通常上一个version + VersionEdit = 当前的version</li>
<li>VersionSet: 初始version，以及之后的所有的VersionEdit，这个方式可以推演出所有的之后版本;</li>
</ul>
<h5 id="FileMetaData对象"><a href="#FileMetaData对象" class="headerlink" title="FileMetaData对象"></a>FileMetaData对象</h5><p>FileMetaData是用来管理sstatble的状态的;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FileMetaData &#123;</span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * refs: 当前sstable被引用的次数，如果次数=0的时候，就表示可以删除</span></span><br><span class="line"><span class="comment">   * allowed_seek: 查好次数,估计会通过这个来进行判断是否要compaction</span></span><br><span class="line"><span class="comment">   * number: 文件编号，通过编号找到文件</span></span><br><span class="line"><span class="comment">   * filesize: 文件size</span></span><br><span class="line"><span class="comment">   * smallest: 最小key的</span></span><br><span class="line"><span class="comment">   * largest: 最大key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key: level</span></span><br><span class="line"><span class="comment"> * value: 内部key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line"><span class="comment">//需要被删除的文件</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="comment">// 新增的文件</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure>
<ul>
<li>comparator_: 压缩方式</li>
<li>log_number_: 这次的变更对应的wal的文件ID</li>
<li>prev_log_number_： 上一个wal的文件ID</li>
<li>next_file_number_: 下一个sstable文件的id</li>
<li>last_sequence_： 最大的版本id是什么</li>
<li>compact_pointers_： 每一层level对应的compaction指针，目前还不清楚有什么用</li>
<li>deleted_files_: 本次更新需要被删除的文件</li>
<li>new_files_: 本次更新新增的文件</li>
</ul>
<p>对VersionEdit的理解，可以想个例子: memtable在被写入到sstable的时候，就会产生一个问题；这个时候这次的更新可以比较简单的认为是新增的一个sstable，这个时候的VersionEdit估计就是;</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"comparator_"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"log_number_"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"prev_log_number_"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"next_file_number_"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">"last_sequence_"</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">"new_files_"</span>: [<span class="string">"xxx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要保存wal的id呢，我觉得主要是在启动恢复的时候需要去知道当前哪些wal是需要被恢复的，至于为什么是要保存两个id呢？我看了后面再来记录TODO</p>
<h5 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Version &#123;</span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vset_: 当前version属于那个VersionSet</li>
<li>next_, prev_: 双向链表，指向上一个或者下一个的version</li>
<li>refs_：version是否被引用</li>
<li>files_： 当前这个version，每一个层关联的文件，估计排序的</li>
<li>file_to_compact_： 当前有哪些可能需要被compaction</li>
<li>file_to_compact_level_: 对应的层数</li>
<li>compaction_score_：TODO</li>
<li>compaction_level_：TODO</li>
</ul>
<p>从数据结构来说，Version包含了当前这个版本整体的文件结构，比如每次包含了哪些文件，哪些文件就可能需要进行compaction之类的; 上下版本的list;</p>
<h5 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> VersionSet &#123;</span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>env_: 同上</li>
<li>dbname_: leveldb路径</li>
<li>options_： 同上dbimpl_</li>
<li>icmp_: 同上</li>
<li>next_file_number_: 下一个文件id; 这个文件可能指sstable，目前还不确定</li>
<li>manifest_file_number_: manifest文件的ID</li>
<li>last_sequence_：最大序列号</li>
<li>log_number_： wal文件id</li>
<li>prev_log_number_： 同上</li>
<li>dummy_versions_: version双向链表的头</li>
<li>current_: dummy_versions_.prev_，表示当前version</li>
<li>compact_pointer_：TODO 未知</li>
</ul>
<p>构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),</span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">//提供的时候VersionSet就只有一个;</span></span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next_file_number_: 为什么初始化是2？？TODO</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(二、leveldb option分析)</title>
    <link href="http://yoursite.com/2020/06/28/LevelDB%E6%BA%90%E7%A0%81-%E4%BA%8C%E3%80%81leveldb-option%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/28/LevelDB源码-二、leveldb-option分析/</id>
    <published>2020-06-28T15:35:23.000Z</published>
    <updated>2020-06-28T16:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的第二篇文章主要是针对leveldb的option的参数进行介绍，option的参数其实不多，但是相对很重要，因为可以让用户进行自定义的一些操作; 了解清楚这些参数的含义就可以更加好的使用leveldb;</p>
<h3 id="1-option"><a href="#1-option" class="headerlink" title="1. option"></a>1. option</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT Options &#123;</span><br><span class="line">  <span class="comment">// Create an Options object with default values for all fields.</span></span><br><span class="line">  Options();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义比较器，默认使用字节序的方式进行排序比较</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如leveldb对应的目录不存在就创建 </span></span><br><span class="line">  <span class="keyword">bool</span> create_if_missing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如对应的目录存在的时候就报错</span></span><br><span class="line">  <span class="keyword">bool</span> error_if_exists = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the implementation will do aggressive checking of the</span></span><br><span class="line">  <span class="comment">// data it is processing and will stop early if it detects any</span></span><br><span class="line">  <span class="comment">// errors.  This may have unforeseen ramifications: for example, a</span></span><br><span class="line">  <span class="comment">// corruption of one DB entry may cause a large number of entries to</span></span><br><span class="line">  <span class="comment">// become unreadable or for the entire DB to become unopenable.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在打开leveldb的时候是否检测db，如果有数据损坏的话就直接报错；但是通常默认false；因为大部分情况下即使数据损坏也可以用;</span></span><br><span class="line">  <span class="keyword">bool</span> paranoid_checks = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认Env::default(), Env封装的是操作系统相关的操作;</span></span><br><span class="line">  Env* env;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//leveldb自己的日志文件对象，用来记录leveldb本身在处理过程中的信息</span></span><br><span class="line">  Logger* info_log = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * memetable的大小;默认4MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">size_t</span> write_buffer_size = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * db能最大打开文件的个数;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> max_open_files = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Control over blocks (user data is stored in a set of blocks, and</span></span><br><span class="line">  <span class="comment">// a block is the unit of reading from disk).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If non-null, use the specified cache for blocks.</span></span><br><span class="line">  <span class="comment">// If null, leveldb will automatically create and use an 8MB internal cache.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * block缓存，如果为null，使用的是leveldb自己的lRU的缓存，默认8MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Cache* block_cache = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认block的大小为4KB,真实数据为4KB，非压缩数据</span></span><br><span class="line">  <span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类似与时间戳的压缩算法一下，通过保存一个完整的时间戳，后面的时间戳用偏移量来存储，这样的好处就可以压缩空间</span></span><br><span class="line"><span class="comment">   * 问题在于如果数据损毁的话会损失很多数据，所以会每n隔时间戳重新记录一个完整时间戳，这样即使数据顺坏也不会丢失</span></span><br><span class="line"><span class="comment">   * 很多数据；，这个参数是key前缀压缩的方式;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> block_restart_interval = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sstable的大小为2M,除了0层是4M，其他的level都是2M的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compress blocks using the specified compression algorithm.  This</span></span><br><span class="line">  <span class="comment">// parameter can be changed dynamically.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Default: kSnappyCompression, which gives lightweight but fast</span></span><br><span class="line">  <span class="comment">// compression.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:</span></span><br><span class="line">  <span class="comment">//    ~200-500MB/s compression</span></span><br><span class="line">  <span class="comment">//    ~400-800MB/s decompression</span></span><br><span class="line">  <span class="comment">// Note that these speeds are significantly faster than most</span></span><br><span class="line">  <span class="comment">// persistent storage speeds, and therefore it is typically never</span></span><br><span class="line">  <span class="comment">// worth switching to kNoCompression.  Even if the input data is</span></span><br><span class="line">  <span class="comment">// incompressible, the kSnappyCompression implementation will</span></span><br><span class="line">  <span class="comment">// efficiently detect that and will switch to uncompressed mode.</span></span><br><span class="line">  CompressionType compression = kSnappyCompression;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过判断来发现manifest是否可以重用之前的；还不确定？？</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bool</span> reuse_logs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置一个过滤器能用来减少磁盘的访问次数，默认用bloomfilter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* filter_policy = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-ReadOptions"><a href="#2-ReadOptions" class="headerlink" title="2. ReadOptions"></a>2. ReadOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options that control read operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT ReadOptions &#123;</span><br><span class="line">  ReadOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, all data read from underlying storage will be</span></span><br><span class="line">  <span class="comment">// verified against corresponding checksums.</span></span><br><span class="line">  <span class="comment">//是否对结果进行checksum检查</span></span><br><span class="line">  <span class="keyword">bool</span> verify_checksums = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should the data read for this iteration be cached in memory?</span></span><br><span class="line">  <span class="comment">// Callers may wish to set this field to false for bulk scans.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否将读出来数据缓存在内存里，如果你读很大的数据的时候，希望它不污染cache的话，可以设置false</span></span><br><span class="line">  <span class="keyword">bool</span> fill_cache = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If "snapshot" is non-null, read as of the supplied snapshot</span></span><br><span class="line">  <span class="comment">// (which must belong to the DB that is being read and which must</span></span><br><span class="line">  <span class="comment">// not have been released).  If "snapshot" is null, use an implicit</span></span><br><span class="line">  <span class="comment">// snapshot of the state at the beginning of this read operation.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对于db的getSnapshot的函数返回的对象，可以读指定snapshot的数据，如果为null，就读当前读操作最新的snapshot的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> Snapshot* snapshot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-WriteOptions"><a href="#3-WriteOptions" class="headerlink" title="3. WriteOptions"></a>3. WriteOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Options that control write operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT WriteOptions &#123;</span><br><span class="line">  WriteOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the write will be flushed from the operating system</span></span><br><span class="line">  <span class="comment">// buffer cache (by calling WritableFile::Sync()) before the write</span></span><br><span class="line">  <span class="comment">// is considered complete.  If this flag is true, writes will be</span></span><br><span class="line">  <span class="comment">// slower.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If this flag is false, and the machine crashes, some recent</span></span><br><span class="line">  <span class="comment">// writes may be lost.  Note that if it is just the process that</span></span><br><span class="line">  <span class="comment">// crashes (i.e., the machine does not reboot), no writes will be</span></span><br><span class="line">  <span class="comment">// lost even if sync==false.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In other words, a DB write with sync==false has similar</span></span><br><span class="line">  <span class="comment">// crash semantics as the "write()" system call.  A DB write</span></span><br><span class="line">  <span class="comment">// with sync==true has similar crash semantics to a "write()"</span></span><br><span class="line">  <span class="comment">// system call followed by "fsync()".</span></span><br><span class="line">  <span class="comment">//性能考虑，不会设置true</span></span><br><span class="line">  <span class="keyword">bool</span> sync = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的第二篇文章主要是针对leveldb的option的参数进行介绍，option的参数其实不多，但是相对很重要，因为可以让用户进行自定义的一些操作; 了解清楚这些参数的含义就可以更加好的使用leveldb;&lt;/p&gt;
&lt;h3 id=&quot;1-option&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(一、leveldb接口分析)</title>
    <link href="http://yoursite.com/2020/06/27/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-db%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/27/leveldb源码分析-db接口分析/</id>
    <published>2020-06-27T15:28:31.000Z</published>
    <updated>2020-06-28T15:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要是针对leveldb的源码分析; 个人也是重温这份源码，希望能在重新看的过程中学习到更多的知识;</p>
<h3 id="1-基本接口"><a href="#1-基本接口" class="headerlink" title="1. 基本接口"></a>1. 基本接口</h3><p><a href="https://github.com/google/leveldb/blob/master/include/leveldb/db.h" target="_blank" rel="noopener">db.h</a>这个头文件几乎包含了所有leveldb提供的所有功能；这套接口是标准的存储引擎的接口，接口非常简洁，主要提供了修改、删除、读取的三大基本功能；其他的接口主要是一些附带的功能;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 打开leveldb,</span><br><span class="line"> * @param options: 打开leveldb的一些参数</span><br><span class="line"> * @param name: 路径</span><br><span class="line"> * @param dbptr: 返回值,如果成功打开就会在这个参数中返回;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">static Status Open(const Options&amp; options, const std::string&amp; name,</span><br><span class="line">                   DB** dbptr);</span><br><span class="line"></span><br><span class="line">DB() = default;</span><br><span class="line"></span><br><span class="line">//db不能被copy或者赋值</span><br><span class="line">DB(const DB&amp;) = delete;</span><br><span class="line">DB&amp; operator=(const DB&amp;) = delete;</span><br><span class="line"></span><br><span class="line">virtual ~DB();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将key和value存储到db里面；</span><br><span class="line"> * @param options ： 写参数设置，默认可以空对象</span><br><span class="line"> * @param key </span><br><span class="line"> * @param value </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Put(const WriteOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   const Slice&amp; value) = 0;</span><br><span class="line"> </span><br><span class="line">//删除key</span><br><span class="line">virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line"> * 批量写的接口; </span><br><span class="line"> * @param options: 同Put接口 </span><br><span class="line"> * @param updates : 批量参数，里面可以包含有写、delete的操作; </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;</span><br><span class="line"></span><br><span class="line">//查询接口，指定key,返回结果在value中；状态看Status，如果为ok的话，value就是取到的值;</span><br><span class="line">virtual Status Get(const ReadOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个iterator，这个需要调用者自己去清理掉的,</span><br><span class="line"> * 返回的iterator通常是无效的，需要在调用seek之后才有效</span><br><span class="line"> * @param options</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;</span><br></pre></td></tr></table></figure>
<p>上面这些接口机会是最为常用的接口,提供了打开db、读key、存储key的功能；存储引擎的功能就在于：</p>
<ul>
<li>存储数据</li>
<li>读取数据</li>
</ul>
<p>关于<code>NewIterator</code>接口需要注意的在于返回是一个指针类型的<code>Iterator*</code>,这个指针内存释放需要调用者来执行的，所以如果每次调用之后不调用delete的话，会出现内存泄露; 这是我第一次注意到这个问题，我发现自己在其他的代码中几乎都没有显示的delete的; 用shared_ptr来封装掉这个过程,这样就不需要手动去delete这个指针;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Iterator&gt; tmp = new std::shared_ptr&lt;Iterator&gt;(db-&gt;NewIterator(options), [](void* raw)&#123;</span><br><span class="line">  if (raw != nullptr) &#123;</span><br><span class="line">    delete static_cast&lt;Iterator*&gt;(raw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">tmp-&gt;SeekToFirst();</span><br></pre></td></tr></table></figure>
<h3 id="2-附加接口"><a href="#2-附加接口" class="headerlink" title="2. 附加接口"></a>2. 附加接口</h3><p>附加接口主要是一些其他功能的介绍；比如快照、如何获得leveldb的监控信息等等;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获得快照; 需要调用者负责清理;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual const Snapshot* GetSnapshot() = 0;</span><br><span class="line"></span><br><span class="line">// Release a previously acquired snapshot.  The caller must not</span><br><span class="line">// use &quot;snapshot&quot; after this call.</span><br><span class="line">virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;</span><br><span class="line"></span><br><span class="line">// DB implementations can export properties about their state</span><br><span class="line">// via this method.  If &quot;property&quot; is a valid property understood by this</span><br><span class="line">// DB implementation, fills &quot;*value&quot; with its current value and returns</span><br><span class="line">// true.  Otherwise returns false.</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">// Valid property names include:</span><br><span class="line">//</span><br><span class="line">//  &quot;leveldb.num-files-at-level&lt;N&gt;&quot; - return the number of files at level &lt;N&gt;,</span><br><span class="line">//     where &lt;N&gt; is an ASCII representation of a level number (e.g. &quot;0&quot;).</span><br><span class="line">//  &quot;leveldb.stats&quot; - returns a multi-line string that describes statistics</span><br><span class="line">//     about the internal operation of the DB.</span><br><span class="line">//  &quot;leveldb.sstables&quot; - returns a multi-line string that describes all</span><br><span class="line">//     of the sstables that make up the db contents.</span><br><span class="line">//  &quot;leveldb.approximate-memory-usage&quot; - returns the approximate number of</span><br><span class="line">//     bytes of memory in use by the DB.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * leveldb会有自己的统计信息，这个函数可以获得这些信息;</span><br><span class="line"> * @param property</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual bool GetProperty(const Slice&amp; property, std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">// For each i in [0,n-1], store in &quot;sizes[i]&quot;, the approximate</span><br><span class="line">// file system space used by keys in &quot;[range[i].start .. range[i].limit)&quot;.</span><br><span class="line">//</span><br><span class="line">// Note that the returned sizes measure file system space usage, so</span><br><span class="line">// if the user data compresses by a factor of ten, the returned</span><br><span class="line">// sizes will be one-tenth the size of the corresponding user data size.</span><br><span class="line">//</span><br><span class="line">// The results may not include the sizes of recently written data.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给key的范围、给level的层数，获得这些key大概的磁盘占用空间</span><br><span class="line"> * @param range</span><br><span class="line"> * @param n</span><br><span class="line"> * @param sizes</span><br><span class="line"> */</span><br><span class="line">virtual void GetApproximateSizes(const Range* range, int n,</span><br><span class="line">                                 uint64_t* sizes) = 0;</span><br><span class="line"></span><br><span class="line">// Compact the underlying storage for the key range [*begin,*end].</span><br><span class="line">// In particular, deleted and overwritten versions are discarded,</span><br><span class="line">// and the data is rearranged to reduce the cost of operations</span><br><span class="line">// needed to access the data.  This operation should typically only</span><br><span class="line">// be invoked by users who understand the underlying implementation.</span><br><span class="line">//</span><br><span class="line">// begin==nullptr is treated as a key before all keys in the database.</span><br><span class="line">// end==nullptr is treated as a key after all keys in the database.</span><br><span class="line">// Therefore the following call will compact the entire database:</span><br><span class="line">//    db-&gt;CompactRange(nullptr, nullptr);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 手动触发指定key范围的compaction</span><br><span class="line"> * @param begin</span><br><span class="line"> * @param end</span><br><span class="line"> */</span><br><span class="line">virtual void CompactRange(const Slice* begin, const Slice* end) = 0;</span><br></pre></td></tr></table></figure>
<p><code>ReleaseSnapshot</code>这个也可以通过<code>shared_ptr</code>来进行封装，这样就省的自己操作了; <code>GetProperty</code>这个函数对后期真正线上使用的时候会特别有用，因为可以让leveldb吐出来很多leveldb自身的信息，方便查问题并且调整leveldb; 对于db来说，能清楚的知道db的状态是非常重要的;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章主要是针对leveldb的源码分析; 个人也是重温这份源码，希望能在重新看的过程中学习到更多的知识;&lt;/p&gt;
&lt;h3 id=&quot;1-基本接口&quot;&gt;&lt;a href=&quot;#1-基本接口&quot; class=&quot;headerlink&quot; title=&quot;1. 基本接口&quot;&gt;&lt;/a&gt;1. 基
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>想好要去试试看了</title>
    <link href="http://yoursite.com/2020/06/12/%E6%83%B3%E5%A5%BD%E8%A6%81%E5%8E%BB%E8%AF%95%E8%AF%95%E7%9C%8B%E4%BA%86/"/>
    <id>http://yoursite.com/2020/06/12/想好要去试试看了/</id>
    <published>2020-06-12T15:48:26.000Z</published>
    <updated>2020-06-12T17:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-这段时间的思考"><a href="#1-这段时间的思考" class="headerlink" title="1. 这段时间的思考"></a>1. 这段时间的思考</h3><p>上一个文章讲了我得到325这个事情；这个事情给我的打击和压力很大很大，我几乎有半个月的时间意志一直很低迷; 不过慢慢的我也看开了，而且开始专注于做新的事情，并且新老板还比较合得来，所以慢慢的好起来来的.</p>
<p>但是从那之后我还是从各方面打听了不少消息过来的；也找了一些朋友交心的聊了一下；感觉自己的处境的确还是比较尴尬的，而且最为主要的是我发现大老板这边我可能不大被看好，我做的事情其实不咋关心，他更加关心的是在另外场景下面的东西落地；但是按照我的想法，这个东西在一个环境没能很好的跑起来，马上就到内部使用，估计到时候会变得骑虎难下哦。</p>
<p>当然其实大老板怎么想和我关心不大，但是相对而言的是我做的事情对他而言无价值的话，就会导致后面325又落我头上，这不是坑爹吗. 而且我在和同事聊天的过程中发现，325是谁可周旋的余地太大了，和老板关系好一些，估计325就能变成3.5甚至于375; 所以，像我这种新人估计有点艰难..</p>
<p>第二点思考在于目前我的组织比较奇葩；我和我团队分割两地，团队几乎全在北京，而我一人在杭州；按照常规分析来说，可能不是一个很好的现象; 而且组织架构也很奇怪，估计后面绩效的还是有这边的大老板来确定，哎想想就有点怕;</p>
<p>第三点思考在于做的事情; 可能心中还是有一个追求技术的心，并且我感觉在这边做的事情，更多的是产品形态上东西，而且监控门槛太低了，能做的东西大家都在做，不能做的大家都不做；所以在差别上就是谁能更加全一些；所以在这里能得到的成长可能没有想象中的那么大；而且我感觉不开心，因为没成长没组织，平时就一个人做事情，这样对自己的心理压力还是很大的；可能现在还好，时间长了可能就不咋好了;</p>
<p>当然这段时间还在思考自己到底要什么东西? 在和包总聊的时候，包总聊到不可替代性这个东西；技术是一个非常容易被替代的东西，尤其当你做的技术还是很上层的东西，3年的熟练工和5～10年的你技术没有区别；那么对于我来说，是否只能往管理岗位走呢？我觉得难，因为这个转化非常难，而且也没有地方让你能做这种磨练和转化; 包总这种算是目标明确，现在也是完全得到了他们想要的，但是我呢？我的优势是什么呢？</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>技术水平还可以</td>
<td>毫无带团队的经验</td>
</tr>
<tr>
<td>对技术还是有追求</td>
<td>貌似没那么浓厚的技术倾向</td>
</tr>
<tr>
<td>目前31岁还年轻</td>
<td>剩下4年</td>
</tr>
<tr>
<td></td>
<td>想不到未来能做什么</td>
</tr>
</tbody>
</table>
<p>那么对于这些优势，我能在35之前的目标是什么呢？并且不会被淘汰呢; </p>
<ul>
<li><p>技术门槛性; 往某一个方面继续努力深挖;</p>
<ul>
<li>技术门槛</li>
<li>清晰产品形态</li>
</ul>
</li>
<li><p>往TL方向努力; 技术是一方面，但是管理这个东西还是后面主力的东西；这有点类似于在理财方面，随着经济周期的变化，你必须慢慢从一个资产过度到另外的资产，这样才能保证你持续的赚钱；而在职业生涯中也是这样的，慢慢从纯技术到技术+管理最后到整体的架构师之类的; </p>
</li>
</ul>
<p>对于这块，我目前在我司是看不到希望的；技术上明显还处于比较薄的地段；管理上，我根本就没什么管理的，就一个人在杭州呆着，我估计升上去的机会要好多年才能到我身上; 哎艰难..</p>
<h3 id="2-心中有了一个想法"><a href="#2-心中有了一个想法" class="headerlink" title="2. 心中有了一个想法"></a>2. 心中有了一个想法</h3><p>想尝试去其他的公司看看，能不能获得自己想要的东西;  如果有好的机会那就选择走，如果没有特别优秀的机会，那看在公司中还能不能熬一熬; 但是多个选择总比一个选择要好很多很多;</p>
<h3 id="3-需要做的准备"><a href="#3-需要做的准备" class="headerlink" title="3. 需要做的准备"></a>3. 需要做的准备</h3><p>目前我需要做的准备是:</p>
<h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h4><ul>
<li>操作系统: <ul>
<li><ol>
<li>看操作系统导论 </li>
</ol>
</li>
<li><ol start="2">
<li>找一个与linux结合比较近的操作系统课程来补习一下<a href="https://time.geekbang.org/column/article/105980" target="_blank" rel="noopener">趣谈Linux操作系统</a></li>
</ol>
</li>
</ul>
</li>
<li>网络: 直接看一下<a href="https://time.geekbang.org/column/article/8386" target="_blank" rel="noopener">趣谈网络协议</a></li>
<li>算法题: 关于这个，现在知乎上刷一些帖子，看是否有比较合适的方式来刷题，然后就进行比较系统的刷和总结吧;</li>
</ul>
<h4 id="2-语言层面（主要还是C-这个方面）"><a href="#2-语言层面（主要还是C-这个方面）" class="headerlink" title="2. 语言层面（主要还是C++这个方面）"></a>2. 语言层面（主要还是C++这个方面）</h4><ul>
<li><a href="https://time.geekbang.org/column/article/184018" target="_blank" rel="noopener">现代C++实战30讲</a>: 几乎把C++的最近的几个特点都比较好的讲了一下；但是缺少了并发的相关东西;</li>
<li><a href="https://time.geekbang.org/column/article/245259" target="_blank" rel="noopener">罗剑锋的C++实战笔记</a>： 目前重合度与上面重合度还是有点高，所以关于这块倒是选择性阅读;</li>
</ul>
<h4 id="3-一些有趣东西的深入"><a href="#3-一些有趣东西的深入" class="headerlink" title="3. 一些有趣东西的深入"></a>3. 一些有趣东西的深入</h4><ul>
<li><p>C++异步的网络框架: 之前我们用的是个facebook的folly + proxygen这个东西来模拟类似于netty；这边需要主要了解的是：</p>
<ul>
<li>future + promise是什么</li>
<li>带来了怎么样的变化</li>
<li>在boost.asio、folly、seastar中都是如何实现，之间有什么区别;</li>
</ul>
</li>
<li><p>协程这个东西的了解; 这块就是要自己深入一下，最好这次就啃下来这块东西，不会再被约束；而且结合目前C++20的stackless的实现来看看;</p>
</li>
<li><p>tcmalloc/jemalloc/malloc这块，对于这块主要连个操作系统的内存机制一起合着看会比较好掌握;</p>
</li>
</ul>
<h4 id="4-基础问题需要掌握的好的几个点"><a href="#4-基础问题需要掌握的好的几个点" class="headerlink" title="4. 基础问题需要掌握的好的几个点"></a>4. 基础问题需要掌握的好的几个点</h4><ul>
<li>进程、线程的概念和目前的调度机制</li>
<li>内存的分配机制</li>
<li>网络的技术问题</li>
<li>io协议栈之类的吧</li>
</ul>
<h4 id="5-领域"><a href="#5-领域" class="headerlink" title="5. 领域"></a>5. 领域</h4><ul>
<li>sentry的整体架构、原理、优势和缺点</li>
<li><p>influxdb的源码阅读</p>
<ul>
<li>文件存储</li>
<li>元信息的管理</li>
<li>时间线的管理</li>
<li>如果我来设计分布式方案要如何解决;</li>
</ul>
</li>
<li><p>整理监控领域的几个产品; </p>
<ul>
<li>sentry</li>
<li>influxdb</li>
<li>prometheus：产品形态、自身的分布式方案、thanos的分布式方案架构</li>
<li>open-falcon</li>
<li>opentsdb/kairsdb等</li>
<li><p>我司内部的监控产品</p>
<p>这边主要是比较有缺点，并且进行划分来看出各自的优缺点</p>
</li>
</ul>
</li>
<li><p>监控产品的全景形态</p>
<p>  从采集到存储到计算到展示和报警；每一块如何做到最优，最后服务好用户本身;</p>
</li>
<li><p>时序存储需要掌握的知识点</p>
<ul>
<li>分布式一致性协议; raft, 目前会按照<a href="https://time.geekbang.org/column/article/218938" target="_blank" rel="noopener">分布式协议与算法实战</a>来进行一步步的学习，主要是对源码和论文进行比较好的阅读;</li>
<li>mysql的一些列的概念;<a href="https://time.geekbang.org/column/article/75659" target="_blank" rel="noopener">MySQL实战45讲</a>, 大神课程，一定能收获很多;</li>
<li><p>leveldb：目前的源码能再次阅读，脉络要清晰; </p>
<ul>
<li>rocksdb的改造有哪些；</li>
<li>x-engine进行了哪些改造，为什么？</li>
<li>lsm的结构会遇到什么样子的问题，如何能优化和解决这些问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h4><ul>
<li>案件用例; 需要自己整理，并且对常规的方式进行了解; <a href="https://time.geekbang.org/column/article/230187" target="_blank" rel="noopener">系统性能调优必知必会</a></li>
<li>经验管理: 这块只能现学现卖吧；自己整理即可</li>
<li>对于过去这段时间的工作经验的解释: 这个需要找到能圆的过去的理由，不然难弄的;</li>
</ul>
<h3 id="4-给自己的时间"><a href="#4-给自己的时间" class="headerlink" title="4. 给自己的时间"></a>4. 给自己的时间</h3><p>目前准备给自己大概是1～1.5个月的时间; 因为内容还是比较多的，需要充分的准备时间；而且目前我手头项目有点忙，可能大部分时间都是课外时间；希望自己能慢慢坚持下来，最后能从多个选择中选择一些比较好的机会; 太难了..</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-这段时间的思考&quot;&gt;&lt;a href=&quot;#1-这段时间的思考&quot; class=&quot;headerlink&quot; title=&quot;1. 这段时间的思考&quot;&gt;&lt;/a&gt;1. 这段时间的思考&lt;/h3&gt;&lt;p&gt;上一个文章讲了我得到325这个事情；这个事情给我的打击和压力很大很大，我几乎有半
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>第一次3.25</title>
    <link href="http://yoursite.com/2020/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A13-25/"/>
    <id>http://yoursite.com/2020/04/23/第一次3-25/</id>
    <published>2020-04-23T14:27:05.000Z</published>
    <updated>2020-04-23T14:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上，新老板找我过一下绩效什么的; 我想总算是到了聊绩效的，我等年终奖等了好久呢；可是等来的是一个3.25；搞得我心情一天都很失落;</p>
<p>去年9月来了阿里，超过半年了; 我虽然觉得我做的东西并不多的，但是3.25总觉得有点过不去吧; 和新老板聊了一下，大概原因估计在与：和我层级不匹配之类的；还有没有主动的提意见并且没有作为技术专家的气势; 当然我觉得，主动、能提出意见、还有气势的什么的，都是不咋靠谱的；我毕竟只是一个新来的，在不熟悉系统、不熟悉人员的个性、不熟悉我们遇到了什么问题的情况下，你能我怎么样才能说到你想要的呢；</p>
<p>我自己其实承认这半年没有很主动的去承担这团队内的核心C位，但是我来这个团队的时候，团队是很稳定的，并且每一个位置都有人做了很久，我能做的只是帮他们负担一些需求；现在看来这样的方式其实并不是很好，因为这样我虽然做了很多的工作，但是得不到老板们的认可；真尼玛坑爹; 最近还为了别人的一个项目忙死忙活的，我实在是有点气愤；</p>
<p>当然我隐性的猜测到有一点是：前老板的这份评价有点针对我，而保护了其他人；其他人毕竟都是自己带出来的，而且跟了很多年；而且现在他要走了，估计后面也没有相处的机会，那就让我这个新人来背一个3.25的位置; 哎…当然这是我臆测；但是我估计从人性角度上来说，这个事情是肯定会在主观上去影响的，即使他觉得他没有; </p>
<p>哎..这3.25的锅一背上, 少说亏个10w块还是有的，真尼玛的不舍得; 哎…涨薪水 + 年终奖都泡汤了, 本来还想用这笔钱来抄个底之类的，现在什么都没有了…有点心烦意乱.</p>
<h3 id="教训是什么"><a href="#教训是什么" class="headerlink" title="教训是什么"></a>教训是什么</h3><p>与老板的聊天过程中，我自己多多少少能感悟到一些东西，这些东西是老板看重的，也是我需要做的一些:</p>
<ul>
<li><p>绩效考核的是在你这个层级，你在半年中，核心价值是什么; 核心价值是指你在某一块内容中承担了什么样的责任，并且你的核心价值解决的是什么样子的问题;这边需要明确的是，你的核心是解决什么问题，用了什么手段，达到了什么样子的效果；</p>
<ul>
<li>解决什么问题</li>
<li>使用什么手段</li>
<li><p>达到怎么样的效果</p>
<p>在设定自己的kpi的时候就需要思考好这个思路，并且按照这个思路去思考自己解决这个难题的方式是否是正确的，是否能达到自己的层级; </p>
</li>
</ul>
</li>
<li><p>老板其实不关心你做了多少事情；这边的事情指的是和你核心事情无关的其他的事情；这半年，我做了很多事情，比如输出、报警、sso登录其他的乱七八糟的事情，我都是做过，但是，老板基本不认可你这事情；他更加关心你的核心事情完成的怎么样? 所以后面要时刻要与老板聊这块的东西,要保证自己能有足够的时间来做自己的本职的事情;</p>
</li>
<li>多给老板做选择题，而非问答题; 因为这样会让老板觉得你比较有能力;</li>
<li>多提出意见和解决方案; 其实这块我觉得可以试试;</li>
<li>和老板多聊聊进度什么的, 让老板能时时刻刻知道目前的状态进度和你的想法;</li>
<li>最后最后，一定要记住自己的核心职责是什么？</li>
</ul>
<h3 id="机会"><a href="#机会" class="headerlink" title="机会"></a>机会</h3><p>说机会也是有的; 目前其实我们部门也不是没有危机，很多产品都在竞争，要做到在这个地方能脱引而出，还是需要做点手段的; 首先：</p>
<ul>
<li>你要解决的问题是什么？</li>
<li>你面向的场景是什么？</li>
<li>你要如何解决这个问题？</li>
<li>解决了这个问题之后会达到什么样子的成果?</li>
</ul>
<p>敏捷paas版本，我个人感觉还是机会，虽然不一定能赚钱什么的，但是推出之后可用的范围可以很大…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天早上，新老板找我过一下绩效什么的; 我想总算是到了聊绩效的，我等年终奖等了好久呢；可是等来的是一个3.25；搞得我心情一天都很失落;&lt;/p&gt;
&lt;p&gt;去年9月来了阿里，超过半年了; 我虽然觉得我做的东西并不多的，但是3.25总觉得有点过不去吧; 和新老板聊了一下，大概原因
    
    </summary>
    
      <category term="心情" scheme="http://yoursite.com/categories/%E5%BF%83%E6%83%85/"/>
    
    
  </entry>
  
  <entry>
    <title>何为债券</title>
    <link href="http://yoursite.com/2020/03/03/%E4%BD%95%E4%B8%BA%E5%9B%BD%E5%80%BA/"/>
    <id>http://yoursite.com/2020/03/03/何为国债/</id>
    <published>2020-03-03T10:51:53.000Z</published>
    <updated>2020-03-03T12:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-债券"><a href="#1-债券" class="headerlink" title="1. 债券"></a>1. 债券</h3><ul>
<li>wiki-定义</li>
</ul>
<blockquote>
<p>债券(Notes)是政府、金融机构、工商企业等机构直接向社会借债筹措资金时，向投资者发行，承诺按一定利率支付利息并按约定条件偿还本金的债权债务凭证。债券的本质是债的证明书，具有法律效力。债券购买者与发行者之间是一种债权债务关系，债券发行人即债务人(Debtors)，投资者（或债券持有人）即债权人(Creditors)。最常见的债券为定息债券、浮息债券以及零息债券。</p>
</blockquote>
<ul>
<li>与银行贷款的不同</li>
</ul>
<blockquote>
<p>与银行信贷不同的是，债券是一种直接债务关系。银行信贷通过存款人——银行，银行——贷款人形成间接的债务关系。</p>
</blockquote>
<h4 id="债券的特性"><a href="#债券的特性" class="headerlink" title="债券的特性"></a>债券的特性</h4><ol>
<li>债券属于有价证券</li>
<li>债券是一种虚拟资本</li>
<li>债券是债权的表现</li>
</ol>
<h4 id="债券的基本要素"><a href="#债券的基本要素" class="headerlink" title="债券的基本要素"></a>债券的基本要素</h4><ul>
<li>债券价格：也就是债券的面值; 面值是固定的，但是购买这些债券的花费的价值是不固定的，有时候高有时候低;</li>
<li>债券利息: 债券利率是<strong>债券利息</strong>与<strong>债券面值</strong>的比率。债券利率分为固定利率和浮动利率两种。债券利率一般为年利率，面值与利率相乘可得出年利息。债券利率直接关系到债券的收益。影响债券利率的因素主要有银行利率水平、发行者的资信状况、债券的偿还期限和资金市场的供求情况等</li>
<li><p>债券还本期限与方式</p>
<ul>
<li>债券还本期限是指从债券发行到归还本金之间的时间</li>
<li>债券还本方式是指一次还本还是分期还本等，还本方式也应在债券票面上注明。</li>
</ul>
</li>
</ul>
<h4 id="债券的特征"><a href="#债券的特征" class="headerlink" title="债券的特征"></a>债券的特征</h4><ul>
<li>期限性</li>
<li>流动性: 仅仅次于储蓄存款；流动性非常好</li>
<li>收益性: 票息（债券利息） + 债券买卖价格差 = 债券收益率</li>
<li><p>安全性</p>
<p>  <strong>市场风险是指债券的市场价格随资本市场的利率上涨而下跌，因为债券的价格是与市场利率呈反方向变动的。当利率下跌时，债券的市场价格便上涨；而当利率上升时，债券的市场价格就下跌。而债券距离到期日越远，其价格受利率变动的影响越大。</strong></p>
</li>
<li><p>自主性</p>
</li>
</ul>
<h4 id="债券类型"><a href="#债券类型" class="headerlink" title="债券类型"></a>债券类型</h4><ul>
<li><p>按照发行主体分类</p>
<ul>
<li>政府</li>
<li>金融债券</li>
<li>企业债券</li>
</ul>
</li>
<li><p>按付息方式划分</p>
<ul>
<li><strong>贴现债券</strong>: 购买债券的时候，按照折扣来进行买；这样折扣就是利息;</li>
<li><strong>零息债券</strong>: 零息债券指债券到期时和本金一起一次性付息、利随本清，也可称为到期付息债券。付息特点一是利息一次性支付。二是债券到期时支付。</li>
<li><strong>附息债券</strong>: 附息债券指债券券面上附有息票的债券，是按照债券票面载明的利率及支付方式支付利息的债券。息票上标有利息额、支付利息的期限和债券号码等内容。持有人可从债券上剪下息票，并据此领取利息。附息国债的利息支付方式一般是在偿还期内按期付息，如每半年或一年付息一次。</li>
<li><strong>固定利率债券</strong>: 是在偿还期内利率固定的债券</li>
<li><strong>浮动利率债券</strong>: 浮动利率债券是指利率可以变动的债券。这种债券的利率确定与市场利率挂钩，一般高于市场利率的一定百分点。</li>
</ul>
</li>
<li><p>按照偿还期限划分</p>
<ul>
<li>长期：&gt; 10年; 我国是5年为分割点</li>
<li>中期:1 ~ 10年</li>
<li>短期: &lt; 1年</li>
</ul>
</li>
<li><p>按照是否可转换来区分</p>
<ul>
<li>可转债债券</li>
<li><p>不可转换债券</p>
<p>可转换债券是能按一定条件转换为其他金融工具的债券，而不可转换债券就是不能转化为其他金融工具的债券。可转换债券一般都是指的可转换公司债券，这种债券的持有者可按一定的条件根据自己的意愿将持有的债券转换成股票。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-债券市场"><a href="#2-债券市场" class="headerlink" title="2. 债券市场"></a>2. 债券市场</h3><p>债券市场, 分为一级市场和二级市场; 其实一开始我很不能理解，为什么会存在债券这种东西? 它存在的形式有的时候和股票那么像，可能买来买去，而且竟然价格还会那么不一致；这主要原因在于: </p>
<blockquote>
<p>债券市场，一个将债券变成可以交易的东西，而不再是只有两个人的关系; 现在的金融市场的基础是信用; 而债券本身就是信用证明，证明了其实期限一到就可以获得一笔钱; 这样以来，其实被借人可以将债券证明卖掉，来提前获得钱;</p>
<p>就这样,债券市场就产生了；那为什么会有价格高低呢? 原因在于每个时间点的利率是不一样的，与国家的基本利率有关系; 比如去年借钱利率是5%，但是今年就只有1%，那么如果5%的债券出来卖的时候价格肯定是高的，因为买走这个债券是有稳定的可预见的收益;</p>
</blockquote>
<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><ol>
<li>2010年，利率为5%, A为B借了100元; 那么就产生了借条: 100元，年利率为5%</li>
<li>2013年, B已经拿了两年的利息, 也就是10元；但是由于他比较缺钱，他需要把这个借条卖掉; 这年的利率是1%；</li>
<li>因为2013年的利率很低，所以B卖出这个债券的价格就比债券本身的面值(100)要高; 比如卖出的价格是105元; </li>
<li>那么B总共赚的钱是 10 + 5 = 15; 那么他的年华收益率100 <em> (1 + x) </em> (1 + x) = 115; 年化利率大概是7%； 这个利率比银行高好多啊; </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-债券&quot;&gt;&lt;a href=&quot;#1-债券&quot; class=&quot;headerlink&quot; title=&quot;1. 债券&quot;&gt;&lt;/a&gt;1. 债券&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;wiki-定义&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;债券(Notes)是政府、金融机构、工
    
    </summary>
    
      <category term="财经" scheme="http://yoursite.com/categories/%E8%B4%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年-年终总结</title>
    <link href="http://yoursite.com/2020/01/20/2019%E5%B9%B4-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/20/2019年-年终总结/</id>
    <published>2020-01-20T08:54:29.000Z</published>
    <updated>2020-01-28T04:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019年过完了; 今天离农历过年还有几天，属于很明显的垃圾时间,大家都比较轻松，并且事情也都能拖到年后来做，所以就找了今天下午出来酱油写一下去年的年终总结；其实每年的年终总结都挺水的，所以今年就稍微不同一下，总结一下去年的好的，今年想要做的；简单一些，不罗列太多无用的东西;</p>
<h3 id="1-去年总结"><a href="#1-去年总结" class="headerlink" title="1. 去年总结"></a>1. 去年总结</h3><p>去年做了几个选择，想了很久但是一直没有行动，去年一年就做了不少的改变，我觉得还挺好的，佩服自己的抉择;有的改变是主动的、有的是被动的，但是从目前来看都挺好的，就类似于伯爵说的，老天永远在往好的方向在推动我; 在这边谢谢老天爷;</p>
<h4 id="1-1-换了工作"><a href="#1-1-换了工作" class="headerlink" title="1.1 换了工作"></a>1.1 换了工作</h4><p>从1年多前就开始尝试出去面试，目标是阿里；总的来说，其实面的并不是很好；除了自己水平原因之外，很重要的一点在于我想做的一直是存储，导致面试阿里存储的时候我的水平一直没到位；后期，自己一直也在思考是否合适，并且也有补习相关的知识，慢慢的就转变了方向；开始面试自己比较擅长的监控领域，这个决策还是很ok的，一下子面试就进步很快; 可能是运气真的很好，来的这个部门刚刚有人走; 当时阿里的招聘的策略是走一个才能进一个，而且必须是7的层级; </p>
<p>面试过程比较顺利，并且进度也很快; 当然真的拿到offer的过程是挺漫长的；中间还去了一家神奇的公司，让我对小公司一下子就没有了好感；索性的是它在去年11月份就倒闭了，说真的心里挺开心的；因为这家公司真的很糟糕;</p>
<p>终于成功的来到了阿里，还是比较兴奋的; 因为一直想来这种世界级公司，看看什么不一样；而且毕业的时候也没成功进来; 来了阿里，其实整体的文化氛围还是很ok的，和之前的公司的感觉很像；大概率因为我们之前那个公司大部分是从阿里过去的，所以文化也超级像；所以适应这种环境还是很快的；</p>
<p>当然最艰难的主要是和同事相处；相处的还挺漫长，我也不知道如何和他们相处；不过虽然他们不怎么说话，但是整体很nice，我有什么问题他们都会积极的; 另外的问题就是适应他们的产品，而且需要寻找自己的定位；我不知道如何去介入到他们做的事情，做多了怕让他们觉得我抢工作，做少了又怕3.25；有点尴尬;</p>
<p>不管怎么说，工作换了，也算是走出了自己的舒服区；去尝试各种不一样的团队和不一样公司，让自己有着更加好的成长;</p>
<h4 id="1-2-开始持久的健身"><a href="#1-2-开始持久的健身" class="headerlink" title="1.2 开始持久的健身"></a>1.2 开始持久的健身</h4><p>去年过年回来之后，我花了将近2w元去办了一个健身卡和报了私交; 开始了自己的健身之路；成果挺好的；大概花了3个月就从160到了140，不过减肥之路还是很辛苦和花钱；不过我觉得值得，因为这是为自己投资；后面又胖回来了一点，但是整体通过持续的锻炼还ok；</p>
<p>今年依然还是买了1w块课程，准备比较系统的学习一下无氧的肌肉运动；但是目前感觉是自己貌似没有学到太多，只是每次让教练监督我练习；明年的话我也多请教一下教练好好的掌握技巧，能在后面自己就能完成练习;</p>
<p>自己健身主要是为了身材、健康和给自己一个目标；所以今年算是坚持下来了，后面要持续支持，让自己的身体更加健康;</p>
<h4 id="1-3-开始学习财务知识"><a href="#1-3-开始学习财务知识" class="headerlink" title="1.3 开始学习财务知识"></a>1.3 开始学习财务知识</h4><p>一直想，一直想学，但是总是没有行动；因为入门的那一脚有点难，一直借口着不去尝试；不过去年真的在离职的前几个月，也不知道为什么就开始认识了公司的一个朋友；其实他和我在公司的时间差不多，之前是认识的，但是不那么熟悉；但是因为kafka迁移让我们关系越来越熟悉，到后面饭后一起走路，到后面他给我们讲于我们不同的观点；慢慢的我就发现着就是我想要学习的东西；而现在这个时间点，这个人出现了，并且他真的很愿意和我们分享这些知识，于是我就下决心好好的把这块补上;</p>
<p>他家相对比较富裕，但是他有着更加遥远的梦想；他的观点是想要让自己做到财富自由；这边的财富自由值得是支付和被动收入相同，也就是即使不上班你也不会饿死；目前我的状态是工作是我唯一的收入，而我的支付有很多很多，房贷就是最大的支出；假设我不工作我感觉用不了多久我就活不下去了. 所以我的人生是被动的。而在遇到他之前，我的想法很简单的，就是如何去提高自己的工资，如何让工作给我赚更多的钱；这条一路走到黑。</p>
<p>关于这点，我突然想到了一个观点；每个人的格局或者视野什么的本来就是需要是被开阔的，不会有一个人天生就格局很大；普通人通常会是这样的一个过程，给了一条路，就觉得这条路就是适合自己，然后不断的往里面走，直到走到黑为止；但是其实可能这条本来就是错的，也不是唯一的，只不过是一开始冒失的一个选择而已；中国人真的很悲剧，在不了解的情况下，做出了人生后半辈子的选择，导致很多人在干的过程中很辛苦很累.而后半辈子因为生活压力的情况下，也不敢再去做尝试，只能默默的承受的这条路;</p>
<p>所以如果你觉得这条路走的很难受，或者你觉得前途很不行；那么是否可以考虑一下，是不是这条本来就不是自己选择的，而且也不知道有什么错误； 换条路是否可能；尤其是年轻人一定要多尝试；尝试可以让你不断去试错，直到找到自己觉得舒服的道路；事半功倍可能;</p>
<p>而对于已经承受着人生压力我来说，轻易的换肯定会导致生活的严重抖动；在计算机中就是要如何平滑重启；既然你已经在这条路上走了，那就先走着，但是你需要去接触除了这条路以外的事物，比如经济学，比如社会学，比如其他的任何东西；虽然你没有试错的机会，但是你可以通过主动学习去开阔自己的视野，这是一种准备，为未来的准备；现在可能会辛苦，但是当你在未来某一个时刻，你在做出选择的时候可能是多条路的选择，而不是一路走黑的选择； </p>
<p>昨天和一个小朋友聊；他说他可能还是有点喜欢计算机的，我说这个没问题，但是这不是你不去做尝试的借口；作为工作计算机可以帮你赚钱养家，但是它并非是你唯一的一条路，你的人生可以有多个路，这个路并非说现在就你让你来换，而是一种准备，在未来的某一个时刻，你发现计算机这条路已经不适合的你的时候，你有其他的路可以走；而且也会让你能更加早的去判断是否这条路合理; 如果合理那就更加应该努力学习而不是茫然;</p>
<p>说了那么多精神方面的，其实想说的总结：</p>
<ul>
<li>保持主动学习，这个学习不一定是看书，也可以尝试其他的东西;</li>
<li>学习可能现在没用，但是后面会有用;</li>
<li>等你的格局或者知识慢慢有变化之后，你就越是能判断当前这路的未来; 如果值得那就不会再迷失自己;</li>
<li>多接触非这条路上的人;</li>
</ul>
<p>关于自己，去年的观点有了比较多的转变; 我看了富爸爸系列的几本书，还看了基金相关的，虽然现在还挺糊涂的，但是慢慢的我觉得会好起来; 去年的投资也还ok，只不过大部分还是无脑操作；后面慢慢的需要去了解这一切的东西;</p>
<h4 id="1-4-存款"><a href="#1-4-存款" class="headerlink" title="1.4 存款"></a>1.4 存款</h4><p>去年基本完成了存款目标；也幸好是我那个朋友说，先让我存6个月的支出，然后放起来，其他的再来投资; 慢慢也有点积蓄能抗风险，希望未来能越来越好;</p>
<h3 id="2-2020年的规划"><a href="#2-2020年的规划" class="headerlink" title="2. 2020年的规划"></a>2. 2020年的规划</h3><p>今年的规划我只是想写个大方向，不想太过细节; 2019年虽然上面几个小目标都完成了，但是依然是一个打酱油的一年，2月份～9月在上一家公司安心的打着酱油, 9月～1月在新公司打酱油；</p>
<p>为什么能在新公司打酱油呢；主要还是因为这个领域能做的东西其实并不是很多，而且团队比较大，所以能分到自己手上的东西就很少。每天改console是我最主要的东西；说真的这个工作真没意思，没有任何挑战；本来到了年底想和老板好好聊聊，看看能不能从他未来的规划中找出一块有价值的事情；但是最后整个团队散了，老板和师兄都转岗了，我们部分团队和另外的团队合并了，另外一些全心做产品；我感觉这是一次机会，因为后面的远景很大的，世界级别的，而且是我喜欢做的技术相关的，有技术挑战性。来了这边我才觉得技术成长对我来说是什么？是一种快乐，是一种每天都愿意奋斗的动力. 所以2020-2021我的目前就是搞定这个世界级别的技术问题，然后能获得自己想要的成果;</p>
<h4 id="2-1-工作"><a href="#2-1-工作" class="headerlink" title="2.1 工作"></a>2.1 工作</h4><p>虽然不清楚后面要做什么，但是目前新老板画的饼我非常喜欢，真的是吃准了技术人员的大饼. 钱很重要，但是技术人员喜欢的挑战，目前我后面主要做我领域的基础技术平台开发, 后面要接入每秒上千万的tps. 我之前公司最最最顶峰的时候才100w，所以这太吸引我了. </p>
<p>我自己的打算是这样的：</p>
<ul>
<li>先承接住目前sunfire的稳定性; 目前主要是对整体的解决问题的能力、对一些细节的掌握，可能是我比较弱的点; 不过目前机会还是蛮好的，我的层级和目前机会的空缺，估计应该可以顺利的接过来; 主要我能主动点;</li>
<li>云监控那边我目前还不怎么清楚;但是我后面想主要放精力的两个方面是：1. 监控数据实时计算 2. 比较友好的预聚合方案 3. 存储引擎；关于展示和采集、报警我其实兴趣不大; 后面就往这块走;</li>
<li>研究一下开源的时序数据库和nosql的存储引擎，怎么样来调和两者;</li>
</ul>
<p>这次调整机会还是很大的，所以能不能抓住要看自己了；我觉得这已经是在我擅长的赛道上进行比赛了，所以老天已经对我很好了，要自己争气啊; 加油加油..</p>
<h4 id="2-2-财务理财"><a href="#2-2-财务理财" class="headerlink" title="2.2 财务理财"></a>2.2 财务理财</h4><p>2020年的目标是真正入门到这个行业,个人觉得可能需要从理论、观点和实战方面全方面进行; 虽然2019年已经开始进行了投资的行为，但是大部分还是通过感觉来进行的；所以2020年就像逐步构建自己的经济学的知识体系，通过实践来不断的完善自己的知识体系; 就目前想得到的目标有几个：</p>
<ul>
<li>能轻松分析国外和国内的公司财报</li>
<li>自己来操作基金组合定投</li>
<li>从跟着别人做资产配置变成自己做资产配置</li>
<li>做公司估值分析</li>
</ul>
<p>这几个方面可能需要看很多书，需要自律; 但是这是没有办法的，学习本来就是逆人性的过程，不能只是焦虑，需要的是去了解这些知识，为后面的未知做好准备; </p>
<p>目前这两条路是我预防我中年危机的手段; 上次在玩现金流游戏的时候让我知道了几个重要点:</p>
<ol>
<li>工资收入高，可以带来很多现金流; 工作上面的努力可以让你很快的积累现金流;</li>
<li>工资高如果支付高，那么想达到财富自由是不可能的; 所以尽可能避免无效开支，不能说因为收入很高，就花费很多; </li>
<li>被动收入真的很重要; 企业和房产的被动收入相差比较大; 需要在生活过程中不断的去寻找高回报的现金流资产. 这个过程可能很艰难，但是这可能是未来一条正确的道路，不然等真的到了35岁的时候，就真的一点办法都没了，我实在太害怕回到农村，我想给孩子一个好的环境，一个能让她尝试各种东西的环境；这样的环境能让她能让我能让我老婆做出心所向往的选择，而不是被迫无奈的选择.</li>
</ol>
<p>加油，2020年的自己…一定要自律自律自律，的确反人性，但是这才是真的吃苦;</p>
<h4 id="2-3-健身"><a href="#2-3-健身" class="headerlink" title="2.3 健身"></a>2.3 健身</h4><p>钱已经花了，后面就按照教练的课程好好练就好了; 但是2020年有几个想要完成的目标：</p>
<ul>
<li>体重达到120～130斤差不多;</li>
<li>学习一整套比较完整的动作，之后就按照这个套路训练就可以;</li>
</ul>
<h3 id="3-写给下一次看的自己"><a href="#3-写给下一次看的自己" class="headerlink" title="3. 写给下一次看的自己"></a>3. 写给下一次看的自己</h3><p>目标每年都定，不知道每年是否有回顾过自己的目标完成的程度; 希望每个一段时间都来回顾自己的计划，然后总结一下自己是否偏离目标，如果偏离合理，那么目标是否要调整; 2019年是一个不错的开始也有一个不错的结尾，后面就靠自己努力进步; 加油加油…</p>
<p>感情这个东西，对我来说真的很难驾驭，本身的性格缺陷，让我有的时候程度很难把握..哎.. 2020年我希望自己能大方一些，不要太在意很多小东西；并且主动去交流，我想这样一定会有点改善;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年过完了; 今天离农历过年还有几天，属于很明显的垃圾时间,大家都比较轻松，并且事情也都能拖到年后来做，所以就找了今天下午出来酱油写一下去年的年终总结；其实每年的年终总结都挺水的，所以今年就稍微不同一下，总结一下去年的好的，今年想要做的；简单一些，不罗列太多无用的东西
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
</feed>
