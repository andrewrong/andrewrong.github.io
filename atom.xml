<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nomoshen</title>
  <subtitle>尽可能努力一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-22T12:56:40.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>nomoshen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>当浮点数作为数据库主键或者索引的时候会发生什么问题</title>
    <link href="http://yoursite.com/2020/12/22/%E5%BD%93%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E6%88%96%E8%80%85%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/12/22/当浮点数作为数据库主键或者索引的时候会发生什么问题/</id>
    <published>2020-12-22T12:56:40.000Z</published>
    <updated>2020-12-22T12:56:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程、进程和协程的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/线程、进程和协程的那些事情/</id>
    <published>2020-12-22T03:39:45.000Z</published>
    <updated>2020-12-22T03:39:45.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库一致性的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/数据库一致性的那些事情/</id>
    <published>2020-12-22T02:27:29.000Z</published>
    <updated>2020-12-22T02:27:29.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异步的那些事情</title>
    <link href="http://yoursite.com/2020/12/22/%E5%BC%82%E6%AD%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://yoursite.com/2020/12/22/异步的那些事情/</id>
    <published>2020-12-22T02:27:11.000Z</published>
    <updated>2020-12-22T02:27:12.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CAP理论</title>
    <link href="http://yoursite.com/2020/10/14/CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/10/14/CAP理论/</id>
    <published>2020-10-14T15:23:43.000Z</published>
    <updated>2020-11-23T01:44:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分区更加指的是网络分区，看了知乎上说P这种是指CAP需要解决的故障模型；而为了解决网络分区，从而就出现了多副本的问题，而多副本就引起了一致性的问题，所以为了解决P才引起了CA的选择，而CA的不同权衡也是为了解决系统在出现网络分区的时候能一直运行</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分区更加指的是网络分区，看了知乎上说P这种是指CAP需要解决的故障模型；而为了解决网络分区，从而就出现了多副本的问题，而多副本就引起了一致性的问题，所以为了解决P才引起了CA的选择，而CA的不同权衡也是为了解决系统在出现网络分区的时候能一直运行&lt;/
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="CAP" scheme="http://yoursite.com/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>债券基金如何波动</title>
    <link href="http://yoursite.com/2020/09/29/%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91%E5%A6%82%E4%BD%95%E6%B3%A2%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/09/29/债券基金如何波动/</id>
    <published>2020-09-28T22:30:25.000Z</published>
    <updated>2020-09-30T01:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当利率处于下行空间的时候，债市往往容易出现一个所谓的债市牛市。<br>当利率处于上行空间的时候，债市往往容易出现一个所谓的债市熊市。<br>这里的利率就是市场利率。</p>
</blockquote>
<p>上面这句话其实我一直没怎么理解，所以导致我对债券基金整体都不是很了解；今天早上找了一篇文章看了一下感觉越来越清晰，所以记录一下心得; </p>
<h3 id="1-债券市场"><a href="#1-债券市场" class="headerlink" title="1. 债券市场"></a>1. 债券市场</h3><p>在<a href="http://nomoshen.com/2020/03/03/%E4%BD%95%E4%B8%BA%E5%9B%BD%E5%80%BA/" target="_blank" rel="noopener">何为债券</a>中我解释了为什么有债券市场的问题；主要的原因是债券流动性的保证，人们不需要等到真正的债券到期才能拿到收益和本金; 比如我购买了10年的债券，但是由于我急需要现金，但是债券也没有到期，这个时候在古代就很难弄，但是现代就你就可以吧这个债券放到债券市场卖掉，马上就可以变成现金；</p>
<p>而且债券市场的流动性很强，因为债券的收益相对是可计算的和稳定的，所以很好交易；可以认为是类似于美元一样的大家都很认同的东西，交易过程中的信用成本就很低;</p>
<h3 id="2-债券价格"><a href="#2-债券价格" class="headerlink" title="2. 债券价格"></a>2. 债券价格</h3><p>既然在债券市场上做买卖，那么债券的价格是如何确定的；如果把债券当作商品，那么它的价格就有下面的来决定：</p>
<ul>
<li>价值: 债券到期能赚到的钱;专业术语: 票面利率，而这个是由国债利率决定的;</li>
<li>需求关系: 如果市场上有很多很多债券可以购买，那么你的债券价格就会适当下降; </li>
</ul>
<p>所以你在卖出你的债券的时候价格就被这两者所限制；而且债券的价值是一个能被很好计算出来的，所以债券的价格波动和国债利率的走势就是一种强关联的；利率上行价格就往下，利率下行价格就往上; 供需起到相对弱的影响，只是因为市场上的债券多了，可选择的机会就多了，买方购买债券的时候就不一定能选择到你，那你最好降低价格，看是否合适;</p>
<h3 id="3-债券基金"><a href="#3-债券基金" class="headerlink" title="3. 债券基金"></a>3. 债券基金</h3><p>基金就是一个组合或者是一揽子计划；债券基金就是购买几个债券的组合；这个的好处是风险<strong>相对</strong>可控，债券本质是一种借贷关系，那么一定会出现欠钱不还的问题，这就导致了很大的损失；虽然债券稳但不表示无风险，所以买债券基金比你直接买债券会更加好操作，当然所有的都是相对的；之前出现过的<strong>华商固收</strong>就因为自己的组合中有两支暴雷，那个跌幅不低于股票基金的; 所以风险都是有的，基金相对低一些;</p>
<h3 id="4-你在购买债券基金的时候发生了什么？"><a href="#4-你在购买债券基金的时候发生了什么？" class="headerlink" title="4. 你在购买债券基金的时候发生了什么？"></a>4. 你在购买债券基金的时候发生了什么？</h3><ol>
<li>你在利率5%的时候购买了一支债券基金; </li>
<li>债券基金本身的债券组合是相对固定的，比如就是一些国开债+一些企业的债券</li>
<li>这个时候基金的经理就会去二级市场上收<strong>等值份额</strong>的债券组合中的债券给你; 这个份额很好计算，因为每支债券在二级市场都是有价格的，所以基金经理的操作也很简单，拿着你的钱直接买他组合就好;</li>
<li>你的债券基金份额已经到手，成功</li>
</ol>
<h3 id="5-为什么会有波动？"><a href="#5-为什么会有波动？" class="headerlink" title="5. 为什么会有波动？"></a>5. 为什么会有波动？</h3><p>那为什么会波动呢？ 因为市场利率是会变化的; 市场利率的变化就导致借贷成本不一样，本来我借你钱的利息是3%，但是现在整体的利率变高了，我借你钱就需要4%的利率了，这就导致借钱的成本不一样了，这里是升高了; 反应到债券上的逻辑是这样的:</p>
<ol>
<li>2000年,你购买了利率为3%的债券为期5年(我们简单点到期才能拿到本金和利息)</li>
<li>2001年,市场利率变成了4%，现在购买债券的话利息就高1%，但是你手头的债券是3%的，你有点不开心; 所以你想卖掉这个老的债券购买新的债券，这个时候就会产生一个问题；因为大家都知道购买现在的债券才是最划算的，没必要购买你的3%的债券啊，所以你就需要便宜卖给人家；当然这个计算有点复杂，我也不是很会, 大家可以自己操作一把; 那么就可以发现在<strong>当下时代</strong>本来值100元的债券你需要降价卖掉，这就导致了债券价格下降</li>
<li>债券市场每天都在做这个操作，而且债券当下的价格除了利率还有很多因素影响，所以会出现一些价格远低于价值的情况，这个时候就可以通过购买指定债券来保证确定性收益;</li>
<li>还记得上面购买债券基金的过程吗；在结尾处你拿到了一些指定份额的债券，而这个时候由于利率上升从而导致了你的这些指定份额的债券账面价值就减少了，这就导致了你看到的亏损；这就是波动;</li>
</ol>
<p>和股票类似，债券每天的净值都是在变化的，因为债券有确定性收益，所以计算的方式会相对于股票来说简单一些，这也是为什么债券收益率想对于股票要低，因为确定性收益很确定，风险小很多；如果你觉得实在是亏钱难受，你只要不卖，到了时间点拿最后的本金+利息就好，问题也不大; </p>
<h3 id="6-分析一开始结论"><a href="#6-分析一开始结论" class="headerlink" title="6. 分析一开始结论"></a>6. 分析一开始结论</h3><ul>
<li>利率下行是债券牛市的开始; 因为这个时候你购买的债券在未来一定是会涨价的；所以现在购买债券基金你会发现整体上涨;可以赚价格差；</li>
<li>利率上行是债市熊市的开始; 因为你持有的债券会在为了很长时间内都是会跌的；因为后面的债券都是比你有价值的，所以这个时候主要就是要注意了；</li>
<li>这里的利率是市场利率，有的人会说是十年期的国债收益率，其实不是这样的，这是一个因果倒置的问题，是因为市场利率上升了，才会让债券的收益变高了,毕竟票面利率变高了，导致整体的收益率会上来;</li>
</ul>
<blockquote>
<p>债券价格和收益率呈反比例变动。以十年期国债收益率为例，<strong>当前收益率</strong>上涨是由国债价格下跌引起的，而不是收益率上涨引起了债券价格的下跌。</p>
</blockquote>
<h3 id="7-老齐对于债券的投资思路"><a href="#7-老齐对于债券的投资思路" class="headerlink" title="7. 老齐对于债券的投资思路"></a>7. 老齐对于债券的投资思路</h3><p>债券的收益=票面利息 + 价格差; 但是大部分投资者拿债券不是真的为了票息，因为票息是一种保底的操作，假设你什么都不操作等到票息，收益固定，但是时间成本很高；这也就是股市中说的机会成本，因为你把钱放在债券上，那你这部分就不能投入到其他的投资；所以大家那债券大部分时候是为了流动性和相对稳定的波动;</p>
<ol>
<li>当市场利率升高的时候，投资债券不赚钱甚至亏钱，这时候<strong>短债优先</strong>，因为短债都是拿到还本付息的，所以交易价差影响极小;</li>
<li>当市场利率下降的时候，这就是债券牛市的开始，这个时候就可以投资债券，并且要投资<strong>长期债券</strong>,为什么要长期呢？因为未来利率下行，那就代表目前你这个票面利率是未来很有竞争力的存在，可能会产生超额收益；</li>
</ol>
<ul>
<li>问题：为什么债券的价值都那么固定，它的价格还会波动呢？</li>
</ul>
<blockquote>
<p>其实本质在于没有多少人会选择真的拿票息的；机会成本时间成本都是很大的，你硬扛在债券中，你损失的其他机会成本就会很高，所以折价卖也是可能的；还有就是情绪和恐慌，大家怕公司倒闭什么的，就会便宜卖了;</p>
</blockquote>
<ul>
<li>如何确定债券的牛市和熊市?</li>
</ul>
<blockquote>
<ol>
<li>通过比较资产价格；将债券的年华收益与货币基金的7天年华收益率进行比较，如果已经跑不赢的话，就因为避险债券了；债券熊市要来了; 原因很简单的，货币基金本身就是短债 + 超短债 + 现金资产，很好的反应了市场利率的波动，如果货币基金收益率提升，也就表示利率变高了，借钱变难了, 所以这个评判标准貌似很简单;而且债券本身有票面利息，大部分时候是少赚而不会赔</li>
<li>指标:信用利差;这个指标跟国债收益率几乎同时波动，有时候信用利差反应更快，信用利差，也就是3年的3A中票，减去3年国债的收益率，这个利差超过2%的时候，<strong>意味着利率基本到顶</strong>(表示利率要下行，进入牛市)，而这个利差低到0.5%附近的时候，说明信用极宽松，对中小企业和信用债有利，也是债券牛市最后末尾阶段</li>
</ol>
</blockquote>
<ul>
<li>问题:债券基金通常购买的是什么？</li>
</ul>
<p><img src="/images/16014271828437.jpg" alt></p>
<blockquote>
<p>这是一支<code>新华纯债添利债券发起A</code>,可以看到它的债券占用的比例; 你在购买的时候其实就是按照当天净值来购买了这些债券的份额; 通常基金经理会帮我们调整这些债券；也不需要你真的去调整长期债券或者什么的; 债券通常是不大会亏钱的，而且说难听点，债券本身价值是确定的，所以真的拿到了票息也不会亏钱；在债熊的时候也没必要去抄底，到了牛市在购买债券就可以；而且债熊的时候通常是股市牛，这个时候你可以投资股票会更加好;</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当利率处于下行空间的时候，债市往往容易出现一个所谓的债市牛市。&lt;br&gt;当利率处于上行空间的时候，债市往往容易出现一个所谓的债市熊市。&lt;br&gt;这里的利率就是市场利率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这句话其实我一直没怎么理解，所以导致
    
    </summary>
    
      <category term="金融" scheme="http://yoursite.com/categories/%E9%87%91%E8%9E%8D/"/>
    
    
      <category term="债券基金" scheme="http://yoursite.com/tags/%E5%80%BA%E5%88%B8%E5%9F%BA%E9%87%91/"/>
    
  </entry>
  
  <entry>
    <title>让人难以回答的问题-tcp为什么要进行三次握手</title>
    <link href="http://yoursite.com/2020/07/14/%E8%AE%A9%E4%BA%BA%E9%9A%BE%E4%BB%A5%E5%9B%9E%E7%AD%94%E7%9A%84%E9%97%AE%E9%A2%98-tcp%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>http://yoursite.com/2020/07/14/让人难以回答的问题-tcp为什么要进行三次握手/</id>
    <published>2020-07-13T23:20:20.000Z</published>
    <updated>2021-01-11T06:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.nomoshen.com/hoarfrost-4739176_1280.jpg" alt="hoarfrost-4739176_1280"></p>
<p>杭州的冬天就是难受，又冷又湿，冻死我了. 今天是周末，女儿还在睡觉，在脑子里面过了很久的一个东西我给记录一下; 其实tcp的3次连接是我一直没搞懂的事情，知其然而不知其所以然可能就是我这种状态，我无数次的去看网上的文章和书籍，但是总觉得缺点为什么会这样的感觉. 最近在看分布式系统的一些书的时候就慢慢有那么点感觉了,我就把自己的不成熟的想法先写下来. </p>
<h3 id="1-关于网络连接"><a href="#1-关于网络连接" class="headerlink" title="1. 关于网络连接"></a>1. 关于网络连接</h3><p>在分布式系统中有提到从单机变成分布式系统之后就遇到了很多很多问题，有的问题在甚至是不可能的，只能不断的收缩前提条件也得到解答. 其中有一个概念就是关于完全异步网络，定义异步网络的有三个点:</p>
<ul>
<li>节点的时钟漂移无上限, </li>
<li>消息的传输延迟无上限, </li>
<li>节点计算的速度不可预料.</li>
</ul>
<p>其中主要还是关注第二条，消息传送延迟无上限, 你可能比较疑惑这点，在tcp的场景下面会有这种情况吗？当然会，因为消息在网络中传播的过程中会进过各种设备，如果设备因为忙碌拥堵导致你的包一直被丢弃，你的包就很长很长时间不能被对端收到；所以在现实系统中，网络是不可靠的，即使在tcp协议的保证下依然不可靠，设计系统本身的时候依然还是需要自己去cover网络出现问题的时候该怎么做.</p>
<p>说完上面的问题，我们思考一下为什么网络是不可靠的呢，难道不能做到可靠吗，起码能保证延迟有上限保证呢;其实有，而且我们生活中常常遇到; 那就是电话线路, 虽然我不知道电话线路真实的物理结构怎么样，但是大概的描述就是每一次电话接通都会占用信号的某一个频率段，我占用的话其他的人就不能被占用了，那么消息转播的延迟基本上就可以被估算出来，大概是信号传播的时间；如果超过这个时间段没有收到对端回复的ack就可以任务消息丢失或者线路本身出现一定的问题; </p>
<p>既然有方式解决这个网络延迟的问题，那为什么不用呢？因为资源利用率的问题；其实电话的线路就类似于目前的城市里面的地铁，而internet就类似于公路；因为地铁是专线专用，所以启停时间都完全可控，只要不需要意外你可以计算出下一班车子什么时候达到，但是如果是在公路上面的车子就不一定的，车子一多很容易就堵车，一堵车你也不知道你什么时间能到公司，所以在公路上开有的时候开很快，有的时候又很慢，慢到难以想象，比如遇到了很多个事故. 回到一开始的问题，那为什么不全部用电话线路呢，因为物理限制和资源利用率，还是用地铁来做比喻的话，不可能没两个点之间都建造一个地铁，1是成本很高 2是如果这条线就没几个人用那资源不是很浪费吗. 所以internet提高了资源利用率和吞吐率，但是带来了网络的各种可知和不可知的问题.因为大家都公用了同一条路，区别点在于如果路比较宽敞的时候就能很快的发送，但是如果路上已经车子很多的情况下，你发送的数据会直接堵在路上，坐等超时，超时完重发依然超时，所以tcp才会有拥塞控制，避免无效的增加网络负担.</p>
<h3 id="2-关于tcp的连接"><a href="#2-关于tcp的连接" class="headerlink" title="2. 关于tcp的连接"></a>2. 关于tcp的连接</h3><p>上面说了连接，那现在说说tcp的连接. tcp是面向“连接”的协议，其实说真的很让人误解，搞的以为tcp真的有一条物理连接在似的. tcp的连接我感觉是一种在创新过程中与过去的电话线路的概念的一种借鉴吧，让大家好理解一些;</p>
<blockquote>
<p>tcp的连接其实并不是真正的连接，它只是tcp两端的自我状态的维护; 这种维护是上层自我概念，底层并没有真实连接存在;</p>
</blockquote>
<blockquote>
<p>tcp协议要解决的是什么问题呢？本质上要解决的是在Internet这种不可靠的网络传输的现状下，如果保证消息一定送达到对方;所以tcp要解决的是消息送达的问题，它本质上就是1. 超时重发 2. ack机制 3. 排序功能,其他的功能主要是为了优化做的;</p>
</blockquote>
<h3 id="3-为什么tcp建立要三次握手呢"><a href="#3-为什么tcp建立要三次握手呢" class="headerlink" title="3. 为什么tcp建立要三次握手呢?"></a>3. 为什么tcp建立要三次握手呢?</h3><p>理论上第二段tcp的本质，就应该知道tcp的三次握手其实是对一下各自状态的过程，对完这个状态我就能保证tcp协议能保证消息一定送达到了对方；那么tcp之间对状态的关键点在于哪里?</p>
<blockquote>
<ol>
<li>ack机制 2. 对一下你发送的下一个数据包的id是什么?</li>
</ol>
</blockquote>
<p><img src="http://cdn.nomoshen.com/16078757149265.jpg" alt></p>
<p>那我们先脱离最后tcp的三次握手来思考一个问题: </p>
<blockquote>
<p>假如让你设计一个协议来完成上面两个问关键点你需要怎么做？</p>
</blockquote>
<p>如果你这么思考你就想: </p>
<ol>
<li>A要告诉B我下一个包的id是多少，并且我要知道B已经收到了我的信息 </li>
<li>B要告诉A我下一个包的Id是多少，并且我要知道A已经收到了我的信息</li>
</ol>
<p>为了这个目标: </p>
<ol>
<li>A发送了一条消息给B，内容为我现在这条消息的Id是x(意味着下一条消息应该是x+1), </li>
<li>B收到了这条消息之后,会返回给A一条消息是ack(x+1)，本意是好的我知道了;</li>
</ol>
<p>而B也会要把自己的信息告诉A，走的流程和A类似，只是A与B互换了一下,那么我们就会发现，在B返回给A Ack的时候其实可以同时把自己的准备发送的消息的Id告诉A，这样就从4次交互变成了三次. 所以三次握手就理论上成立了; 至于如果中间出现了包丢了或者怎么样的，那么会不断的重试，而且在tcp三次握手没有建立起来之前，tcp是不完整的，是不能进行正常的通信，因为两端自己的状态都没有同步好，后面的消息就没办法保证tcp的保证了；</p>
<p>至于建立完“连接”之后呢，其实之后就没关系了，因为每次发送对端都知道你下次包的id是多少，如果没收到我就不返回ack，我不返回ack你就会超时重发，直到我收到为止，就从本质上保证tcp的可靠传输的保证了;</p>
<blockquote>
<p>说难听点，tcp协议就是在internet这种不可靠的网络上建立的软件层面的可靠协议；协议需要至少三次通信才能保证协议的结果，当然我不知道如果用了电话线路这种模式，构建可靠协议会变成怎么样？或者会变得很简单，1. 超时可控 2. 流量也可控，我能很好预估吞吐不需要做额外的算法； 我思考可能会更加简单一些;</p>
</blockquote>
<h3 id="4-至于为什么要4次挥手呢"><a href="#4-至于为什么要4次挥手呢" class="headerlink" title="4. 至于为什么要4次挥手呢?"></a>4. 至于为什么要4次挥手呢?</h3><p>本质上tcp包含了两条链路，A-&gt;B和B-&gt;A两条，A往B发送和B往A发送；当A想和B断的时候B可能还不想断；现实中的例子，我觉得可能是朋友吧，A和B是好朋友，突然有一天A单方面不想和B做好朋友了，就不给东西给B；可是B还是认为A是好朋友，就不断吧自己的东西给A；当然这个例子有点牵强. </p>
<p>所以4次挥手本质上还是在于A-&gt;B这条链路断链的过程:</p>
<ol>
<li>A-&gt;B</li>
<li>B-&gt;A 我知道你和我断链了，但是我现在还不想和你断链;</li>
</ol>
<p>过了一段时间B也觉得这样没意思就发送断链的请求</p>
<ol>
<li>B-&gt;A 断链</li>
<li>A-&gt;B 好的我收到了你的请求，你总算愿意了</li>
</ol>
<p><img src="http://cdn.nomoshen.com/16078771565521.jpg" alt></p>
<h4 id="是否真的需要4次挥手吗？"><a href="#是否真的需要4次挥手吗？" class="headerlink" title="是否真的需要4次挥手吗？"></a>是否真的需要4次挥手吗？</h4><ol>
<li>如果正常的分手的话，问题都不大的；四次挥手正常走下来也ok</li>
<li>客户端如果直接把来回的通道全部关闭了；那么其实4次挥手就不能正常结束了；通常客户端在FIN2这种状态一定时间之后就直接关闭了，这样能保证资源比较好的释放；在这个时候如果对端依然发送数据过来，会马上获得一个RST这恢复，tcp在收到这样的返回之后基本上就知道对端已经不在服务状态，于是就正常关闭这个服务;</li>
</ol>
<h4 id="A主动请求的状态演变"><a href="#A主动请求的状态演变" class="headerlink" title="A主动请求的状态演变:"></a>A主动请求的状态演变:</h4><ol>
<li>FIN_WAIT_1</li>
<li>FIN_WAIT_2</li>
<li>TIME_WAIT:这个小子总算可以和我分手了;</li>
<li>CLOSED: 与TIME_WAIT之间需要等待2 * MSL, 也就是包在网络中存活的最长时间;</li>
</ol>
<p>为什么要等那么长时间呢？</p>
<ol>
<li>因为client在Time_wait阶段返回给服务端的ack的包可能要丢失，需要等一下服务端重试B-&gt;A的断开的包</li>
<li>time_wait的包发送丢失最大需要MSL(这个包会彻底的消失), 服务端第二次重试包超过MSL还没有被搜到的话那肯定就再也搜不到了;client做到这步已经仁至义尽了，依然已经分开了后面我也不管了; </li>
</ol>
<h4 id="B的状态演变"><a href="#B的状态演变" class="headerlink" title="B的状态演变"></a>B的状态演变</h4><ol>
<li>CLOSE_WAIT: 接受到A主动断开之后，它的状态就变成等待被关闭；</li>
<li>LAST_ACK: B也主动发送A断开链接，然后就主动等待最后的ACK</li>
<li>CLOSED:收到ack就正确关闭；</li>
</ol>
<p>如果LAST_ACK超时会怎么样，看分析有几个:</p>
<ol>
<li>如果超时重发之后，A还是time_wait状态的话就会重新ack，如果ack收到几句进入closed</li>
<li>如果超时重发之后，A已经是CLosed状态那么就回复RST的回复，这个时候B收到就进行closed</li>
<li>如果LAST_ACK一直超时一直重试，大概等到tcp的最长时间就会进行closed状态</li>
</ol>
<h3 id="5-一些参考文档"><a href="#5-一些参考文档" class="headerlink" title="5. 一些参考文档"></a>5. 一些参考文档</h3><ul>
<li><a href="https://www.zhihu.com/question/27564314" target="_blank" rel="noopener">在tcp协议中处于last_ack状态的连接，如果一直收不到对方的ack，会一直处于这个状态吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗</a></li>
<li><a href="http://blog.qiusuo.im/blog/2014/03/19/tcp-timeout/" target="_blank" rel="noopener">TCP协议的那些超时</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.nomoshen.com/hoarfrost-4739176_1280.jpg&quot; alt=&quot;hoarfrost-4739176_1280&quot;&gt;&lt;/p&gt;
&lt;p&gt;杭州的冬天就是难受，又冷又湿，冻死我了. 今天是周末，女儿还在睡觉，在脑子里
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>从leveldb的wal恢复到hbase的hlog恢复看seqId</title>
    <link href="http://yoursite.com/2020/07/14/%E4%BB%8Eleveldb%E7%9A%84wal%E6%81%A2%E5%A4%8D%E5%88%B0hbase%E7%9A%84hlog%E6%81%A2%E5%A4%8D%E7%9C%8BseqId/"/>
    <id>http://yoursite.com/2020/07/14/从leveldb的wal恢复到hbase的hlog恢复看seqId/</id>
    <published>2020-07-13T23:16:01.000Z</published>
    <updated>2020-07-13T23:16:01.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LevelDB源码(五、leveldb write流程)</title>
    <link href="http://yoursite.com/2020/07/11/LevelDB%E6%BA%90%E7%A0%81-%E4%BA%94%E3%80%81leveldb-write%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/11/LevelDB源码-五、leveldb-write流程/</id>
    <published>2020-07-11T02:06:28.000Z</published>
    <updated>2020-07-14T00:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Leveldb的写流程分析，这个过程对比读来说已经简单很多，但是里面也涉及到很多的点；尤其是如果在线程安全的情况下进行批量写，如何保证多版本等; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  Writer w(&amp;mutex_);</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = false;</span><br><span class="line"></span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line">  /**</span><br><span class="line">   * w.done: 表示是否完成</span><br><span class="line">   * writers_.front: 表示当前write是否是最前面的writer</span><br><span class="line">   *</span><br><span class="line">   * 如果未完成并且当前写入不是最久未完成的write，就进行等待;</span><br><span class="line">   */</span><br><span class="line">  while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">    w.cv.Wait();</span><br><span class="line">  &#125;</span><br><span class="line">  if (w.done) &#123;</span><br><span class="line">    return w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //当前的writer是最前面的writer，有他来完成整体写入</span><br><span class="line">  // May temporarily unlock and wait.</span><br><span class="line">  Status status = MakeRoomForWrite(updates == nullptr);</span><br><span class="line">  uint64_t last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  if (status.ok() &amp;&amp; updates != nullptr) &#123;  // nullptr batch is for compactions</span><br><span class="line">    WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">    //设置了一个新的seqId</span><br><span class="line">    WriteBatchInternal::SetSequence(write_batch, last_sequence + 1);</span><br><span class="line">    //seq跳变到很大, 这是因为这里面包含了多个写操作，每一个put操作都会对应一个seqId</span><br><span class="line">    last_sequence += WriteBatchInternal::Count(write_batch);</span><br><span class="line"></span><br><span class="line">    // Add to log and apply to memtable.  We can release the lock</span><br><span class="line">    // during this phase since &amp;w is currently responsible for logging</span><br><span class="line">    // and protects against concurrent loggers and concurrent writes</span><br><span class="line">    // into mem_.</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为什么可以释放的原因在于：即使释放了，只是让更多的数据进入队列，但是put线程都会堵在获得mutex_上面</span><br><span class="line">     * 所以这里不会有并发问题，释放了可以让更多的数据进来;</span><br><span class="line">     */</span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      //1. 写wal，写成功了才返回</span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">      bool sync_error = false;</span><br><span class="line">      if (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        if (!status.ok()) &#123;</span><br><span class="line">          sync_error = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (status.ok()) &#123;</span><br><span class="line">        //2. 写memtable</span><br><span class="line">        status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      if (sync_error) &#123;</span><br><span class="line">        // The state of the log file is indeterminate: the log record we</span><br><span class="line">        // just added may or may not show up when the DB is re-opened.</span><br><span class="line">        // So we force the DB into a mode where all future writes fail.</span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 因为返回的write_batch可能本身就有可能不是与tmp_batch_一样的，所以就需要</span><br><span class="line">     */</span><br><span class="line">    if (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line">    //跳变的序列号</span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 自己不需要唤醒自己</span><br><span class="line">   */</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    Writer* ready = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    if (ready != &amp;w) &#123;</span><br><span class="line">      //唤醒其他的等待写入的线程</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = true;</span><br><span class="line">      ready-&gt;cv.Signal();</span><br><span class="line">    &#125;</span><br><span class="line">    if (ready == last_writer) break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Notify new head of write queue</span><br><span class="line">  if (!writers_.empty()) &#123;</span><br><span class="line">    //如果队列非空就发消息给头部，让他来做写入操作</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1. 大致流程"></a>1. 大致流程</h3><p><code>DB::put-&gt;DBImpl:Write</code>,其实写的流程大致是这样，把握这个细节可以让你在看源码的过程中不会太迷茫；</p>
<ol>
<li>构建<code>WriteBatch</code>实例，这个类作用就是用来合并写操作的，构建出一个批量写入的对象；这个对象也挺有意思的，后面会分析</li>
<li>将<code>WriteBatch</code>放到一个队列中去; 队列存放的都是一次put操作的<code>WriteBatch</code>对象，可想而知，这里的writebatch目前都还是单次操作的数据</li>
<li>让某一个线程去对队列中的WriteBatch操作进行合并</li>
<li>记入WAL</li>
<li>写入Memtable；这边需要注意的是:<strong>wal写入成功之后才会写memtable</strong></li>
<li>唤醒一些线程，然后返回结果;</li>
</ol>
<p>所以这个流程中，需要关注的点在于WriteBatch的合并、高性能的原因、wal和memtable的写入过程，当然还是有seqId的变化;</p>
<h3 id="2-WriteBatch合并"><a href="#2-WriteBatch合并" class="headerlink" title="2. WriteBatch合并"></a>2. WriteBatch合并</h3><p>首先WriteBatch是一个非常简单的合并的对象，它线程不安全；那如何在多线程操作的时候去保证写入是线程安全的呢？这个其实真的是leveldb的一个不错的优化，导致后期的很多的代码都按照这个模式进行优化;</p>
<h4 id="2-1-如何做到多线程写入安全？"><a href="#2-1-如何做到多线程写入安全？" class="headerlink" title="2.1 如何做到多线程写入安全？"></a>2.1 如何做到多线程写入安全？</h4><p>其实看dbimpl可以看出它的<code>mutex</code>其实就只有一个，如果在减少锁粒度的情况下，保证高性能的呢; 本身我觉得对于资源竞争这个问题，能解决的方式其实可以归类于几种：</p>
<ul>
<li>锁，一定是最安全的；根据不同的场景，使用不同的锁可以有着不错的性能</li>
<li>原子变量； 本质上是内存模型+cas的方式进行，与锁的不同在于底层保证原子性，缺点在于：不通用，只能针对某一些数据类型</li>
<li>threadlocal变量; 性能上应该问题不大，问题在于场景上还是很收到限制的；假如你要中心管理的时候，就比较难受，而且可见的内存占用；典型的用空间换时间的方案；但是大部分时候可以用用，反正可以用方案绕过上面的这些问题，只是不优雅而已;</li>
<li>让所有的资源的操作都放到一个线程去操作；这样可以保证绝对的线程安全；但是问题在于不是所有的场景你都能接受这个，之前的问题在于需要返回结果，目前貌似用futurn + promise可以进行;</li>
</ul>
<p>而锁的优化大部分的方式就是：1. 用不同的锁 2. 缩小锁的粒度，通过使用细粒度锁来进行保证 3. 尽可能的减少锁的范围，不知道算不算和第二种类似; </p>
<p>但是在leveldb中，它就通过一个mutex是如何保证高性能呢？答案是：</p>
<ul>
<li>leveldb的场景; 因为leveldb本身是一个io密集性的应用，这就代表了cpu大部分时候等待着io，那么多线程的优势就没有多少价值；</li>
<li>让一个线程尽可能多做点事情；批量写入只是选择了一个线程，并且让它做合并、写入wal、写入memtable的操作；其他的线程等待即可; 当然这个也是因为上面的leveldb的场景才能这样，如果是一个cpu密集性的应用，那这个方式基本上不行，因为多核优势就没有了；</li>
</ul>
<h4 id="2-2-WriteBatch分析"><a href="#2-2-WriteBatch分析" class="headerlink" title="2.2 WriteBatch分析"></a>2.2 WriteBatch分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) &#123;</span><br><span class="line">  SetCount(dst, Count(dst) + Count(src));</span><br><span class="line">  assert(src-&gt;rep_.size() &gt;= kHeader);</span><br><span class="line">  dst-&gt;rep_.append(src-&gt;rep_.data() + kHeader, src-&gt;rep_.size() - kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>合并结构的分析</li>
</ul>
<p><img src="media/15946849685529.jpg" alt></p>
<ul>
<li><p>前面12个字节是header，用来保存</p>
<ul>
<li>seqId：这个批量操作的起始seqId</li>
<li>count: 合并操作的个数</li>
</ul>
</li>
<li><p>后面就是：kv的list；第一个字节是操作的类型;</p>
</li>
</ul>
<h4 id="2-3-合并时机"><a href="#2-3-合并时机" class="headerlink" title="2.3 合并时机"></a>2.3 合并时机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">&#125;</span><br><span class="line">if (w.done) &#123;</span><br><span class="line">  return w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是上面写入过程中会遇到的一段代码，通常put进来之后必定会运行这段代码，这段代码的含义是: 假如w没有完成 或者 w不是队列中最早进来的那个写入，那么就进行等待；是不是很神奇；其实这个原因在于：大部分写入的操作只是将写入操作放入队列；但是肯定有那么一个write它进来的时候就是第一个写入，所以它不会进入等待状态，就开始后面的操作；</p>
<p>那你问题肯定是，那也只有一个是第一个写入操作啊，当然在后期写入完成之后会唤醒这种等待，那个时候写完就会被提出队列，那么自然会有新的最早的写入咯</p>
<h3 id="3-腾出空间进行写入操作"><a href="#3-腾出空间进行写入操作" class="headerlink" title="3. 腾出空间进行写入操作"></a>3. 腾出空间进行写入操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 看名字就是说为写入过程预留空间，可能会检查</span><br><span class="line"> *</span><br><span class="line"> * 1. level0的文件个数是否已经操作一个阈值</span><br><span class="line"> * 2. memtable是否已经满</span><br><span class="line"> * 3. 如果memtable是full。并且immtable 为空，所以内存中已经满了，需要进行compaction，这个时候就唤醒背后线程</span><br><span class="line"> * 4. l0文件依然还是很多，需要唤醒compaction</span><br><span class="line"> * * @param force</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Status DBImpl::MakeRoomForWrite(bool force) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  bool allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!bg_error_.ok()) &#123;</span><br><span class="line">      // Yield previous error</span><br><span class="line">      s = bg_error_;</span><br><span class="line">      break;</span><br><span class="line">    &#125; else if (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(0) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      // 判断当前的level0层次的文件是否已经达到需要慢慢写入的过程，可能写的太快，compaction来不及</span><br><span class="line">      // We are getting close to hitting a hard limit on the number of</span><br><span class="line">      // L0 files.  Rather than delaying a single write by several</span><br><span class="line">      // seconds when we hit the hard limit, start delaying each</span><br><span class="line">      // individual write by 1ms to reduce latency variance.  Also,</span><br><span class="line">      // this delay hands over some CPU to the compaction thread in</span><br><span class="line">      // case it is sharing the same core as the writer.</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      env_-&gt;SleepForMicroseconds(1000);</span><br><span class="line">      allow_delay = false;  // Do not delay a single write more than once</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">    &#125; else if (!force &amp;&amp;</span><br><span class="line">               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">      // There is room in current memtable</span><br><span class="line">      break;</span><br><span class="line">    &#125; else if (imm_ != nullptr) &#123;</span><br><span class="line">      // We have filled up the current memtable, but the previous</span><br><span class="line">      // one is still being compacted, so we wait.</span><br><span class="line">      Log(options_.info_log, &quot;Current memtable full; waiting...\n&quot;);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">    &#125; else if (versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">      // There are too many level-0 files.</span><br><span class="line">      Log(options_.info_log, &quot;Too many L0 files; waiting...\n&quot;);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 判断到最后的情况就是：mem已经满，但是imm还没有，这个时候就切换memtable，生成一个新memtable，顺便切换了wal</span><br><span class="line">       * wal的大小和memtable大小数据差不多吧，每次都切换memtable都会切换wal</span><br><span class="line">       */</span><br><span class="line">      // Attempt to switch to a new memtable and trigger compaction of old</span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == 0);</span><br><span class="line">      uint64_t new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = nullptr;</span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      if (!s.ok()) &#123;</span><br><span class="line">        // Avoid chewing through file number space in a tight loop.</span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      delete log_;</span><br><span class="line">      delete logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = new log::Writer(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.store(true, std::memory_order_release);</span><br><span class="line">      mem_ = new MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = false;  // Do not force another compaction if have room</span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次写操作都会进行这样的判断，用来确定当前写入是否要进行必要的变化；这种变化可能会有：</p>
<ul>
<li>memtable转成immutable</li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leveldb的写流程分析，这个过程对比读来说已经简单很多，但是里面也涉及到很多的点；尤其是如果在线程安全的情况下进行批量写，如何保证多版本等; &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(四、leveldb open流程)</title>
    <link href="http://yoursite.com/2020/07/06/LevelDB%E6%BA%90%E7%A0%81-%E5%9B%9B%E3%80%81leveldb-open%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/06/LevelDB源码-四、leveldb-open流程/</id>
    <published>2020-07-06T03:15:42.000Z</published>
    <updated>2020-07-11T02:12:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于到了正常讲流程的，对于leveldb来说，让我来看最主要的几个关键点在于：</p>
<ul>
<li>打开leveldb的过程；涉及到了数据如何从文件中恢复回来的问题；</li>
<li>write流程</li>
<li>open流程</li>
<li>compaction</li>
<li>版本管理</li>
</ul>
<p>今天这文章主要讲到的是db open的流程，这个过程中会涉及到很多的相关的组建，靠着这些组件才能保证持久化数据的完整性; 对leveldb的文件进行分类并且的功能介绍：</p>
<ul>
<li>sstable: 数据持久化,真正用来存储数据</li>
<li>manifest: 所有的version、versionEdit都会按照顺序写入到这个文件中；</li>
<li>WAL: 以log为结尾，wal日志，顺序写，保证数据恢复使用;</li>
<li>CURRENT: 里面记录了当前真正在使用的manifest</li>
<li>LOCK：文件锁</li>
<li>LOG.*: 表示日志文件;</li>
</ul>
<h3 id="1-打开Leveldb"><a href="#1-打开Leveldb" class="headerlink" title="1. 打开Leveldb"></a>1. 打开Leveldb</h3><p>在open db的过程中，leveldb主要做了三件事情：</p>
<ul>
<li>初始化一个最初的dbimpl对象，这个对象包含了很多内容，在系列第三篇文章中有介绍;</li>
<li>恢复版本管理的的内容，主要是从manifest文章中读出来VersionEdit，然后慢慢的构造最新的version</li>
<li>恢复wal中的数据，并不是所有的wal都需要恢复，但是在version恢复过程中可以获得需要恢复的内容;</li>
</ul>
<p>核心代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, DB** dbptr) &#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> DBImpl(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.Lock();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 恢复version和wal</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status s = impl-&gt;Recover(&amp;edit, &amp;save_manifest);</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">    WritableFile* lfile;</span><br><span class="line">    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                     &amp;lfile);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      edit.SetLogNumber(new_log_number);</span><br><span class="line">      impl-&gt;logfile_ = lfile;</span><br><span class="line">      impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">      impl-&gt;log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      impl-&gt;mem_ = <span class="keyword">new</span> MemTable(impl-&gt;internal_comparator_);</span><br><span class="line">      impl-&gt;mem_-&gt;Ref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.SetLogNumber(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">//删除不必要的文件</span></span><br><span class="line">    impl-&gt;RemoveObsoleteFiles();</span><br><span class="line">    impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.Unlock();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    assert(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的点在于: impl-&gt;Recover这个函数里面，里面主要包含了version恢复 + wal的恢复; 恢复完毕之后整个db就处于在上一次停止之后的一个比较完整的状态; 基于这个状态的db数据是没有”丢失”的; recover函数的代码量还是很大的，分成两块，分别为version recover + wal的recover;</p>
<h4 id="1-1-Version-Recover的过程"><a href="#1-1-Version-Recover的过程" class="headerlink" title="1.1 Version Recover的过程"></a>1.1 Version Recover的过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取manifest中的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  s = edit.DecodeFrom(record);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">        edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</span><br><span class="line">      s = Status::InvalidArgument(</span><br><span class="line">          edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</span><br><span class="line">          icmp_.user_comparator()-&gt;Name());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    builder.Apply(&amp;edit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">    log_number = edit.log_number_;</span><br><span class="line">    have_log_number = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">    prev_log_number = edit.prev_log_number_;</span><br><span class="line">    have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">    next_file = edit.next_file_number_;</span><br><span class="line">    have_next_file = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">    last_sequence = edit.last_sequence_;</span><br><span class="line">    have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑是: </p>
<ul>
<li>读取manifest中的每一个VersionEdit的内存，然后慢慢的恢复到Version中去; 如果按照git的逻辑就是，如果所有的commit都在，那就一定能构建出来完整的数据;</li>
<li>从manifest中读取的每一个VersionEdit，通过builder.Apply(&amp;edit)会被应用到一起，慢慢累积的过程;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑：</p>
<ol>
<li>更新VersionSet的compact_pointers_的数据; 这个参数主要是包含了每一层下一次要进行compact的开始的startkey;</li>
<li>VersionEdit要删除的文件进行汇总</li>
<li>VersionEdit新增的文件进行汇总</li>
<li><p>在过程中还会不断的统计这四个参数:</p>
<ul>
<li>log_number_: 用到的wal的id</li>
<li>prev_log_number_: 前一个wal的id，这个id也不知道是怎么被赋值的，但是很重要，因为也保证了数据的不丢;</li>
<li>next_file_number_: 下一个文件的id，这个id用于多种文件类型</li>
<li>last_sequence_: 最大的序列id</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    Finalize(v);</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    manifest_file_number_ = next_file;</span><br><span class="line">    next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">    last_sequence_ = last_sequence;</span><br><span class="line">    log_number_ = log_number;</span><br><span class="line">    prev_log_number_ = prev_log_number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">最后把所用的VersionEdit都恢复回来变成了Version，然后leveldb就你会把当前的version固化，并且放到versionSet中; 到目前为止，版本是恢复回来了，现在就要对真实的文件进行处理了；</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.2</span> WAL文件的恢复</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 版本中包含的log是已经被写入到sstable中的，但是wal中的log可能还没有写入到sstable中，</span></span><br><span class="line"><span class="comment">   * 所以必须需要将这些没有正常写入的wal恢复回来</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">      expected.erase(number);</span><br><span class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!expected.empty()) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                  <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  <span class="built_in">std</span>::sort(logs.begin(), logs.end());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">    s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;SetLastSequence(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 通过VersionSet可以知道当前应该存在有哪些文件</span><br><span class="line"><span class="number">2.</span> 通过目录可以获得当前db真实存在有哪些文件，</span><br><span class="line"><span class="number">3.</span> 进行比较，多余的进行删除，少的就进行报错，理论上不应有这样的问题;</span><br><span class="line"></span><br><span class="line">这边看到WAL的恢复的逻辑是:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"> <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.push_back(number);</span><br></pre></td></tr></table></figure>
<p>如果是kLogFile类型的文件，并且文件id小于等于min_log,或者等于prev_log，小于等于我懂，因为即使版本中包含了log_number，也不能保证wal都被消费掉了，所以需要重新会滚；prev_log目前还不清楚是什么含义(TODO);</p>
<p>wal的文件id会进行排序，然后按照顺序进行恢复; 恢复过程后面细讲;</p>
<h4 id="1-3-善后的工作"><a href="#1-3-善后的工作" class="headerlink" title="1.3 善后的工作"></a>1.3 善后的工作</h4><ol>
<li>会将本次的恢复过程按照一次VersionEdit进行写入到文件;</li>
<li>删除一些多余的文件</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于到了正常讲流程的，对于leveldb来说，让我来看最主要的几个关键点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开leveldb的过程；涉及到了数据如何从文件中恢复回来的问题；&lt;/li&gt;
&lt;li&gt;write流程&lt;/li&gt;
&lt;li&gt;open流程&lt;/li&gt;
&lt;li&gt;compacti
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(三、leveldb DBImpl成员分析)</title>
    <link href="http://yoursite.com/2020/07/02/LevelDB%E6%BA%90%E7%A0%81-%E4%B8%89%E3%80%81leveldb-DBImpl%E6%88%90%E5%91%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/02/LevelDB源码-三、leveldb-DBImpl成员分析/</id>
    <published>2020-07-02T14:36:07.000Z</published>
    <updated>2020-07-06T06:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤其在于Leveldb在被打开瞬间，数据如何恢复特别的重要.</p>
<h4 id="1-DBImpl类的数据成员"><a href="#1-DBImpl类的数据成员" class="headerlink" title="1. DBImpl类的数据成员"></a>1. DBImpl类的数据成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> DBImpl: <span class="keyword">public</span> DB &#123;</span><br><span class="line">  <span class="comment">//指定环境的工具类，比如文件操作之类的</span></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator internal_comparator_;</span><br><span class="line">  <span class="keyword">const</span> InternalFilterPolicy internal_filter_policy_;</span><br><span class="line">  <span class="keyword">const</span> Options options_;  <span class="comment">// options_.comparator == &amp;internal_comparator_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否是自己管理infolog和blockcache,通常都是leveldb自己去管理，而非调用者来传入</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_info_log_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_cache_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// table_cache_ provides its own synchronization</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提供对于leveldb的文件信息的管理，所以它的大小为最大打开文件个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock over the persistent DB state.  Non-null iff successfully acquired.</span></span><br><span class="line">  FileLock* db_lock_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State below is protected by mutex_</span></span><br><span class="line">  port::Mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; shutting_down_;</span><br><span class="line">  port::<span class="function">CondVar background_work_finished_signal_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; has_imm_;         <span class="comment">// So bg thread can detect non-null imm_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//WAL的文件，logFiles用在后面的log_上面</span></span><br><span class="line">  WritableFile* logfile_;</span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="function">logfile_number_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 感觉是WAL的类,用来存储put的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">log</span>::Writer* log_;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="function">seed_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// For sampling.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue of writers.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  leveldb是结合多个写入然后才操作memtable + wal；而这个对象就是WriteBatch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SnapshotList snapshots_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line">  <span class="comment">// part of ongoing compactions.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; <span class="function">pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Has a background compaction been scheduled or is running?</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> background_compaction_scheduled_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ManualCompaction* manual_compaction_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">VersionSet* <span class="keyword">const</span> versions_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Have we encountered a background error in paranoid mode?</span></span><br><span class="line">  <span class="function">Status bg_error_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只是展示了数据成员，没有写成员函数;想看具体在<code>db_impl.h</code>文件中;下面就具体分析这些数据成员：</p>
<ul>
<li>env_: 内部封装了一些与os相关的操作，主要是读写、生成文件之类的; 默认以default为主</li>
<li>internal_comparator_: 内部字符串的对比方式;默认字节序列比较</li>
<li>internal_filter_policy_: 默认是bloom过滤器，本身是为了减少对磁盘操作而产生的过滤器</li>
<li>options_：本系列的第二篇文章讲了关于db option的细节，大部分使用默认值，如果用户想修改的话，就需要在打开db的时候就赋值</li>
</ul>
<hr>
<ul>
<li>owns_info_log_: 是否使用的是内部自己的打日志的文件，如果是自己的话，需要在最后自己释放掉</li>
<li>owns_cache_：是否自己提供了blockcache的方式，默认是用了LRU的方式来实现这个</li>
<li>dbname_: leveldb的路径</li>
<li>table_cache_: 主要是一些经常打开的sstable的文件缓存，如果经常访问就不需要经常去open;也是使用了LRU的方式进行管理</li>
<li>db_lock_： 文件锁，其实也不是真的文件锁，只不过用一个文件来保存这个状态，方式两次打开相同的db;</li>
</ul>
<hr>
<ul>
<li>mutex_: 用于保护一些关键变量的线程安全</li>
<li>shutting_down_： 是否正在关闭</li>
<li>background_work_finished_signal_: 条件变量，用来通知背后工作线程已经运行关闭，到时候会进行通知;</li>
</ul>
<hr>
<ul>
<li>mem_: memtable; </li>
<li>imm_：不可变的memtable</li>
<li>has_imm_：是否有不可变的memtable</li>
</ul>
<hr>
<ul>
<li>logfile_: wal对应的文件</li>
<li>logfile_number: 表示当前的wal的文件名；在leveldb中文件名通常都是编号；leveldb通过增量的方式来保证唯一性；这样不需要保存文件名;</li>
<li>log_: 对logfile_的封装，可以读写操作</li>
<li>seed_： 看了后期使用的过程，主要是为了后期的随机数使用,可能是为了更加随机一些吧</li>
<li>writers_: deque的队列，是用来存放写操作的双端队列; 通过上面的mutex_来保证线程安全；通过用户调用put之后，会将写操作放到这里面; 后面有线程进行批量的写入;</li>
<li>tmp_batch_: writeBatch类型，用来做批量写入的时候使用，不过为什么需要一个这个成员变量，需要后面看到再来解答; TODO</li>
<li>snapshots_: 维持目前db返回给外界的snapshot的一个list;是一个双向链表</li>
<li>pending_outputs_: 看注解应该是一些被保护防止被删除的文件;  TODO</li>
<li>background_compaction_scheduled_： 是否开启自动compaction的调度worker</li>
<li>manual_compaction_： 记录当前db手动compaction的信息，主要起到管理作用</li>
<li>versions_: 版本管理器; 这是一个常量指针，也就是被赋值之后不能被修改，但是可以修改内容</li>
<li>bg_error_： 与option中的<code>paranoid mode</code>一起使用</li>
<li>stats_: leveldb多层结构中，每层的compaction的状态</li>
</ul>
<p>默认构造函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::DBImpl(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span><br><span class="line">    : env_(raw_options.env),</span><br><span class="line">      internal_comparator_(raw_options.comparator),</span><br><span class="line">      internal_filter_policy_(raw_options.filter_policy),</span><br><span class="line">      options_(SanitizeOptions(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      owns_info_log_(options_.info_log != raw_options.info_log),</span><br><span class="line">      owns_cache_(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      table_cache_(<span class="keyword">new</span> TableCache(dbname_, options_, TableCacheSize(options_))),</span><br><span class="line">      db_lock_(<span class="literal">nullptr</span>),</span><br><span class="line">      shutting_down_(<span class="literal">false</span>),</span><br><span class="line">      background_work_finished_signal_(&amp;mutex_),</span><br><span class="line">      mem_(<span class="literal">nullptr</span>),</span><br><span class="line">      imm_(<span class="literal">nullptr</span>),</span><br><span class="line">      has_imm_(<span class="literal">false</span>),</span><br><span class="line">      logfile_(<span class="literal">nullptr</span>),</span><br><span class="line">      logfile_number_(<span class="number">0</span>),</span><br><span class="line">      log_(<span class="literal">nullptr</span>),</span><br><span class="line">      seed_(<span class="number">0</span>),</span><br><span class="line">      tmp_batch_(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      background_compaction_scheduled_(<span class="literal">false</span>),</span><br><span class="line">      manual_compaction_(<span class="literal">nullptr</span>),</span><br><span class="line">      versions_(<span class="keyword">new</span> VersionSet(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化之后都是默认值，但是在<code>DB:open</code>函数调用之后都会从文件中恢复出之前持久化的数值;</p>
<h4 id="2-VersionSet，Leveldb的版本管理"><a href="#2-VersionSet，Leveldb的版本管理" class="headerlink" title="2. VersionSet，Leveldb的版本管理"></a>2. VersionSet，Leveldb的版本管理</h4><p>所谓版本管理，主要指的是Leveldb去管理sstable、wal、manifest等一些本地的文件；而这些文件会随着compaction的操作而变化，所以需要有版本管理器来管理这些;</p>
<p>在网上看到一<a href="https://sf-zhou.github.io/leveldb/leveldb_07_version.html" target="_blank" rel="noopener">文章</a>,里面有一个比喻会比较形象来描述这些概念:</p>
<ul>
<li>VersionEdit: 类似于git的一个commit，记录了本次的变化</li>
<li>Version: 表示git当前的版本；就是git log中展示的那个唯一id; 通常上一个version + VersionEdit = 当前的version</li>
<li>VersionSet: 初始version，以及之后的所有的VersionEdit，这个方式可以推演出所有的之后版本;</li>
</ul>
<h5 id="FileMetaData对象"><a href="#FileMetaData对象" class="headerlink" title="FileMetaData对象"></a>FileMetaData对象</h5><p>FileMetaData是用来管理sstatble的状态的;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FileMetaData &#123;</span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * refs: 当前sstable被引用的次数，如果次数=0的时候，就表示可以删除</span></span><br><span class="line"><span class="comment">   * allowed_seek: 查好次数,估计会通过这个来进行判断是否要compaction</span></span><br><span class="line"><span class="comment">   * number: 文件编号，通过编号找到文件</span></span><br><span class="line"><span class="comment">   * filesize: 文件size</span></span><br><span class="line"><span class="comment">   * smallest: 最小key的</span></span><br><span class="line"><span class="comment">   * largest: 最大key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key: level</span></span><br><span class="line"><span class="comment"> * value: 内部key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line"><span class="comment">//需要被删除的文件</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="comment">// 新增的文件</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure>
<ul>
<li>comparator_: 压缩方式</li>
<li>log_number_: 这次的变更对应的wal的文件ID</li>
<li>prev_log_number_： 上一个wal的文件ID</li>
<li>next_file_number_: 下一个sstable文件的id</li>
<li>last_sequence_： 最大的版本id是什么</li>
<li>compact_pointers_： 每一层level对应的compaction指针，目前还不清楚有什么用</li>
<li>deleted_files_: 本次更新需要被删除的文件</li>
<li>new_files_: 本次更新新增的文件</li>
</ul>
<p>对VersionEdit的理解，可以想个例子: memtable在被写入到sstable的时候，就会产生一个问题；这个时候这次的更新可以比较简单的认为是新增的一个sstable，这个时候的VersionEdit估计就是;</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"comparator_"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"log_number_"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"prev_log_number_"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"next_file_number_"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">"last_sequence_"</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">"new_files_"</span>: [<span class="string">"xxx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要保存wal的id呢，我觉得主要是在启动恢复的时候需要去知道当前哪些wal是需要被恢复的，至于为什么是要保存两个id呢？我看了后面再来记录TODO</p>
<h5 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Version &#123;</span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vset_: 当前version属于那个VersionSet</li>
<li>next_, prev_: 双向链表，指向上一个或者下一个的version</li>
<li>refs_：version是否被引用</li>
<li>files_： 当前这个version，每一个层关联的文件，估计排序的</li>
<li>file_to_compact_： 当前有哪些可能需要被compaction</li>
<li>file_to_compact_level_: 对应的层数</li>
<li>compaction_score_：TODO</li>
<li>compaction_level_：TODO</li>
</ul>
<p>从数据结构来说，Version包含了当前这个版本整体的文件结构，比如每次包含了哪些文件，哪些文件就可能需要进行compaction之类的; 上下版本的list;</p>
<h5 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> VersionSet &#123;</span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>env_: 同上</li>
<li>dbname_: leveldb路径</li>
<li>options_： 同上dbimpl_</li>
<li>icmp_: 同上</li>
<li>next_file_number_: 下一个文件id; 这个文件可能指sstable，目前还不确定</li>
<li>manifest_file_number_: manifest文件的ID</li>
<li>last_sequence_：最大序列号</li>
<li>log_number_： wal文件id</li>
<li>prev_log_number_： 同上</li>
<li>dummy_versions_: version双向链表的头</li>
<li>current_: dummy_versions_.prev_，表示当前version</li>
<li>compact_pointer_：TODO 未知</li>
</ul>
<p>构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),</span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">//提供的时候VersionSet就只有一个;</span></span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next_file_number_: 为什么初始化是2？？TODO</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(二、leveldb option分析)</title>
    <link href="http://yoursite.com/2020/06/28/LevelDB%E6%BA%90%E7%A0%81-%E4%BA%8C%E3%80%81leveldb-option%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/28/LevelDB源码-二、leveldb-option分析/</id>
    <published>2020-06-28T15:35:23.000Z</published>
    <updated>2020-06-28T16:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的第二篇文章主要是针对leveldb的option的参数进行介绍，option的参数其实不多，但是相对很重要，因为可以让用户进行自定义的一些操作; 了解清楚这些参数的含义就可以更加好的使用leveldb;</p>
<h3 id="1-option"><a href="#1-option" class="headerlink" title="1. option"></a>1. option</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT Options &#123;</span><br><span class="line">  <span class="comment">// Create an Options object with default values for all fields.</span></span><br><span class="line">  Options();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义比较器，默认使用字节序的方式进行排序比较</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如leveldb对应的目录不存在就创建 </span></span><br><span class="line">  <span class="keyword">bool</span> create_if_missing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如对应的目录存在的时候就报错</span></span><br><span class="line">  <span class="keyword">bool</span> error_if_exists = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the implementation will do aggressive checking of the</span></span><br><span class="line">  <span class="comment">// data it is processing and will stop early if it detects any</span></span><br><span class="line">  <span class="comment">// errors.  This may have unforeseen ramifications: for example, a</span></span><br><span class="line">  <span class="comment">// corruption of one DB entry may cause a large number of entries to</span></span><br><span class="line">  <span class="comment">// become unreadable or for the entire DB to become unopenable.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在打开leveldb的时候是否检测db，如果有数据损坏的话就直接报错；但是通常默认false；因为大部分情况下即使数据损坏也可以用;</span></span><br><span class="line">  <span class="keyword">bool</span> paranoid_checks = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认Env::default(), Env封装的是操作系统相关的操作;</span></span><br><span class="line">  Env* env;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//leveldb自己的日志文件对象，用来记录leveldb本身在处理过程中的信息</span></span><br><span class="line">  Logger* info_log = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * memetable的大小;默认4MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">size_t</span> write_buffer_size = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * db能最大打开文件的个数;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> max_open_files = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Control over blocks (user data is stored in a set of blocks, and</span></span><br><span class="line">  <span class="comment">// a block is the unit of reading from disk).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If non-null, use the specified cache for blocks.</span></span><br><span class="line">  <span class="comment">// If null, leveldb will automatically create and use an 8MB internal cache.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * block缓存，如果为null，使用的是leveldb自己的lRU的缓存，默认8MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Cache* block_cache = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认block的大小为4KB,真实数据为4KB，非压缩数据</span></span><br><span class="line">  <span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类似与时间戳的压缩算法一下，通过保存一个完整的时间戳，后面的时间戳用偏移量来存储，这样的好处就可以压缩空间</span></span><br><span class="line"><span class="comment">   * 问题在于如果数据损毁的话会损失很多数据，所以会每n隔时间戳重新记录一个完整时间戳，这样即使数据顺坏也不会丢失</span></span><br><span class="line"><span class="comment">   * 很多数据；，这个参数是key前缀压缩的方式;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> block_restart_interval = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sstable的大小为2M,除了0层是4M，其他的level都是2M的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compress blocks using the specified compression algorithm.  This</span></span><br><span class="line">  <span class="comment">// parameter can be changed dynamically.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Default: kSnappyCompression, which gives lightweight but fast</span></span><br><span class="line">  <span class="comment">// compression.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:</span></span><br><span class="line">  <span class="comment">//    ~200-500MB/s compression</span></span><br><span class="line">  <span class="comment">//    ~400-800MB/s decompression</span></span><br><span class="line">  <span class="comment">// Note that these speeds are significantly faster than most</span></span><br><span class="line">  <span class="comment">// persistent storage speeds, and therefore it is typically never</span></span><br><span class="line">  <span class="comment">// worth switching to kNoCompression.  Even if the input data is</span></span><br><span class="line">  <span class="comment">// incompressible, the kSnappyCompression implementation will</span></span><br><span class="line">  <span class="comment">// efficiently detect that and will switch to uncompressed mode.</span></span><br><span class="line">  CompressionType compression = kSnappyCompression;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过判断来发现manifest是否可以重用之前的；还不确定？？</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bool</span> reuse_logs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置一个过滤器能用来减少磁盘的访问次数，默认用bloomfilter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* filter_policy = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-ReadOptions"><a href="#2-ReadOptions" class="headerlink" title="2. ReadOptions"></a>2. ReadOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options that control read operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT ReadOptions &#123;</span><br><span class="line">  ReadOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, all data read from underlying storage will be</span></span><br><span class="line">  <span class="comment">// verified against corresponding checksums.</span></span><br><span class="line">  <span class="comment">//是否对结果进行checksum检查</span></span><br><span class="line">  <span class="keyword">bool</span> verify_checksums = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should the data read for this iteration be cached in memory?</span></span><br><span class="line">  <span class="comment">// Callers may wish to set this field to false for bulk scans.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否将读出来数据缓存在内存里，如果你读很大的数据的时候，希望它不污染cache的话，可以设置false</span></span><br><span class="line">  <span class="keyword">bool</span> fill_cache = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If "snapshot" is non-null, read as of the supplied snapshot</span></span><br><span class="line">  <span class="comment">// (which must belong to the DB that is being read and which must</span></span><br><span class="line">  <span class="comment">// not have been released).  If "snapshot" is null, use an implicit</span></span><br><span class="line">  <span class="comment">// snapshot of the state at the beginning of this read operation.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对于db的getSnapshot的函数返回的对象，可以读指定snapshot的数据，如果为null，就读当前读操作最新的snapshot的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> Snapshot* snapshot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-WriteOptions"><a href="#3-WriteOptions" class="headerlink" title="3. WriteOptions"></a>3. WriteOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Options that control write operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT WriteOptions &#123;</span><br><span class="line">  WriteOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the write will be flushed from the operating system</span></span><br><span class="line">  <span class="comment">// buffer cache (by calling WritableFile::Sync()) before the write</span></span><br><span class="line">  <span class="comment">// is considered complete.  If this flag is true, writes will be</span></span><br><span class="line">  <span class="comment">// slower.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If this flag is false, and the machine crashes, some recent</span></span><br><span class="line">  <span class="comment">// writes may be lost.  Note that if it is just the process that</span></span><br><span class="line">  <span class="comment">// crashes (i.e., the machine does not reboot), no writes will be</span></span><br><span class="line">  <span class="comment">// lost even if sync==false.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In other words, a DB write with sync==false has similar</span></span><br><span class="line">  <span class="comment">// crash semantics as the "write()" system call.  A DB write</span></span><br><span class="line">  <span class="comment">// with sync==true has similar crash semantics to a "write()"</span></span><br><span class="line">  <span class="comment">// system call followed by "fsync()".</span></span><br><span class="line">  <span class="comment">//性能考虑，不会设置true</span></span><br><span class="line">  <span class="keyword">bool</span> sync = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的第二篇文章主要是针对leveldb的option的参数进行介绍，option的参数其实不多，但是相对很重要，因为可以让用户进行自定义的一些操作; 了解清楚这些参数的含义就可以更加好的使用leveldb;&lt;/p&gt;
&lt;h3 id=&quot;1-option&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB源码(一、leveldb接口分析)</title>
    <link href="http://yoursite.com/2020/06/27/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-db%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/27/leveldb源码分析-db接口分析/</id>
    <published>2020-06-27T15:28:31.000Z</published>
    <updated>2020-06-28T15:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要是针对leveldb的源码分析; 个人也是重温这份源码，希望能在重新看的过程中学习到更多的知识;</p>
<h3 id="1-基本接口"><a href="#1-基本接口" class="headerlink" title="1. 基本接口"></a>1. 基本接口</h3><p><a href="https://github.com/google/leveldb/blob/master/include/leveldb/db.h" target="_blank" rel="noopener">db.h</a>这个头文件几乎包含了所有leveldb提供的所有功能；这套接口是标准的存储引擎的接口，接口非常简洁，主要提供了修改、删除、读取的三大基本功能；其他的接口主要是一些附带的功能;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 打开leveldb,</span><br><span class="line"> * @param options: 打开leveldb的一些参数</span><br><span class="line"> * @param name: 路径</span><br><span class="line"> * @param dbptr: 返回值,如果成功打开就会在这个参数中返回;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">static Status Open(const Options&amp; options, const std::string&amp; name,</span><br><span class="line">                   DB** dbptr);</span><br><span class="line"></span><br><span class="line">DB() = default;</span><br><span class="line"></span><br><span class="line">//db不能被copy或者赋值</span><br><span class="line">DB(const DB&amp;) = delete;</span><br><span class="line">DB&amp; operator=(const DB&amp;) = delete;</span><br><span class="line"></span><br><span class="line">virtual ~DB();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将key和value存储到db里面；</span><br><span class="line"> * @param options ： 写参数设置，默认可以空对象</span><br><span class="line"> * @param key </span><br><span class="line"> * @param value </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Put(const WriteOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   const Slice&amp; value) = 0;</span><br><span class="line"> </span><br><span class="line">//删除key</span><br><span class="line">virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line"> * 批量写的接口; </span><br><span class="line"> * @param options: 同Put接口 </span><br><span class="line"> * @param updates : 批量参数，里面可以包含有写、delete的操作; </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;</span><br><span class="line"></span><br><span class="line">//查询接口，指定key,返回结果在value中；状态看Status，如果为ok的话，value就是取到的值;</span><br><span class="line">virtual Status Get(const ReadOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个iterator，这个需要调用者自己去清理掉的,</span><br><span class="line"> * 返回的iterator通常是无效的，需要在调用seek之后才有效</span><br><span class="line"> * @param options</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;</span><br></pre></td></tr></table></figure>
<p>上面这些接口机会是最为常用的接口,提供了打开db、读key、存储key的功能；存储引擎的功能就在于：</p>
<ul>
<li>存储数据</li>
<li>读取数据</li>
</ul>
<p>关于<code>NewIterator</code>接口需要注意的在于返回是一个指针类型的<code>Iterator*</code>,这个指针内存释放需要调用者来执行的，所以如果每次调用之后不调用delete的话，会出现内存泄露; 这是我第一次注意到这个问题，我发现自己在其他的代码中几乎都没有显示的delete的; 用shared_ptr来封装掉这个过程,这样就不需要手动去delete这个指针;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Iterator&gt; tmp = new std::shared_ptr&lt;Iterator&gt;(db-&gt;NewIterator(options), [](void* raw)&#123;</span><br><span class="line">  if (raw != nullptr) &#123;</span><br><span class="line">    delete static_cast&lt;Iterator*&gt;(raw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">tmp-&gt;SeekToFirst();</span><br></pre></td></tr></table></figure>
<h3 id="2-附加接口"><a href="#2-附加接口" class="headerlink" title="2. 附加接口"></a>2. 附加接口</h3><p>附加接口主要是一些其他功能的介绍；比如快照、如何获得leveldb的监控信息等等;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获得快照; 需要调用者负责清理;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual const Snapshot* GetSnapshot() = 0;</span><br><span class="line"></span><br><span class="line">// Release a previously acquired snapshot.  The caller must not</span><br><span class="line">// use &quot;snapshot&quot; after this call.</span><br><span class="line">virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;</span><br><span class="line"></span><br><span class="line">// DB implementations can export properties about their state</span><br><span class="line">// via this method.  If &quot;property&quot; is a valid property understood by this</span><br><span class="line">// DB implementation, fills &quot;*value&quot; with its current value and returns</span><br><span class="line">// true.  Otherwise returns false.</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">// Valid property names include:</span><br><span class="line">//</span><br><span class="line">//  &quot;leveldb.num-files-at-level&lt;N&gt;&quot; - return the number of files at level &lt;N&gt;,</span><br><span class="line">//     where &lt;N&gt; is an ASCII representation of a level number (e.g. &quot;0&quot;).</span><br><span class="line">//  &quot;leveldb.stats&quot; - returns a multi-line string that describes statistics</span><br><span class="line">//     about the internal operation of the DB.</span><br><span class="line">//  &quot;leveldb.sstables&quot; - returns a multi-line string that describes all</span><br><span class="line">//     of the sstables that make up the db contents.</span><br><span class="line">//  &quot;leveldb.approximate-memory-usage&quot; - returns the approximate number of</span><br><span class="line">//     bytes of memory in use by the DB.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * leveldb会有自己的统计信息，这个函数可以获得这些信息;</span><br><span class="line"> * @param property</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual bool GetProperty(const Slice&amp; property, std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">// For each i in [0,n-1], store in &quot;sizes[i]&quot;, the approximate</span><br><span class="line">// file system space used by keys in &quot;[range[i].start .. range[i].limit)&quot;.</span><br><span class="line">//</span><br><span class="line">// Note that the returned sizes measure file system space usage, so</span><br><span class="line">// if the user data compresses by a factor of ten, the returned</span><br><span class="line">// sizes will be one-tenth the size of the corresponding user data size.</span><br><span class="line">//</span><br><span class="line">// The results may not include the sizes of recently written data.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给key的范围、给level的层数，获得这些key大概的磁盘占用空间</span><br><span class="line"> * @param range</span><br><span class="line"> * @param n</span><br><span class="line"> * @param sizes</span><br><span class="line"> */</span><br><span class="line">virtual void GetApproximateSizes(const Range* range, int n,</span><br><span class="line">                                 uint64_t* sizes) = 0;</span><br><span class="line"></span><br><span class="line">// Compact the underlying storage for the key range [*begin,*end].</span><br><span class="line">// In particular, deleted and overwritten versions are discarded,</span><br><span class="line">// and the data is rearranged to reduce the cost of operations</span><br><span class="line">// needed to access the data.  This operation should typically only</span><br><span class="line">// be invoked by users who understand the underlying implementation.</span><br><span class="line">//</span><br><span class="line">// begin==nullptr is treated as a key before all keys in the database.</span><br><span class="line">// end==nullptr is treated as a key after all keys in the database.</span><br><span class="line">// Therefore the following call will compact the entire database:</span><br><span class="line">//    db-&gt;CompactRange(nullptr, nullptr);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 手动触发指定key范围的compaction</span><br><span class="line"> * @param begin</span><br><span class="line"> * @param end</span><br><span class="line"> */</span><br><span class="line">virtual void CompactRange(const Slice* begin, const Slice* end) = 0;</span><br></pre></td></tr></table></figure>
<p><code>ReleaseSnapshot</code>这个也可以通过<code>shared_ptr</code>来进行封装，这样就省的自己操作了; <code>GetProperty</code>这个函数对后期真正线上使用的时候会特别有用，因为可以让leveldb吐出来很多leveldb自身的信息，方便查问题并且调整leveldb; 对于db来说，能清楚的知道db的状态是非常重要的;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列文章主要是针对leveldb的源码分析; 个人也是重温这份源码，希望能在重新看的过程中学习到更多的知识;&lt;/p&gt;
&lt;h3 id=&quot;1-基本接口&quot;&gt;&lt;a href=&quot;#1-基本接口&quot; class=&quot;headerlink&quot; title=&quot;1. 基本接口&quot;&gt;&lt;/a&gt;1. 基
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>何为债券</title>
    <link href="http://yoursite.com/2020/03/03/%E4%BD%95%E4%B8%BA%E5%9B%BD%E5%80%BA/"/>
    <id>http://yoursite.com/2020/03/03/何为国债/</id>
    <published>2020-03-03T10:51:53.000Z</published>
    <updated>2020-03-03T12:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-债券"><a href="#1-债券" class="headerlink" title="1. 债券"></a>1. 债券</h3><ul>
<li>wiki-定义</li>
</ul>
<blockquote>
<p>债券(Notes)是政府、金融机构、工商企业等机构直接向社会借债筹措资金时，向投资者发行，承诺按一定利率支付利息并按约定条件偿还本金的债权债务凭证。债券的本质是债的证明书，具有法律效力。债券购买者与发行者之间是一种债权债务关系，债券发行人即债务人(Debtors)，投资者（或债券持有人）即债权人(Creditors)。最常见的债券为定息债券、浮息债券以及零息债券。</p>
</blockquote>
<ul>
<li>与银行贷款的不同</li>
</ul>
<blockquote>
<p>与银行信贷不同的是，债券是一种直接债务关系。银行信贷通过存款人——银行，银行——贷款人形成间接的债务关系。</p>
</blockquote>
<h4 id="债券的特性"><a href="#债券的特性" class="headerlink" title="债券的特性"></a>债券的特性</h4><ol>
<li>债券属于有价证券</li>
<li>债券是一种虚拟资本</li>
<li>债券是债权的表现</li>
</ol>
<h4 id="债券的基本要素"><a href="#债券的基本要素" class="headerlink" title="债券的基本要素"></a>债券的基本要素</h4><ul>
<li>债券价格：也就是债券的面值; 面值是固定的，但是购买这些债券的花费的价值是不固定的，有时候高有时候低;</li>
<li>债券利息: 债券利率是<strong>债券利息</strong>与<strong>债券面值</strong>的比率。债券利率分为固定利率和浮动利率两种。债券利率一般为年利率，面值与利率相乘可得出年利息。债券利率直接关系到债券的收益。影响债券利率的因素主要有银行利率水平、发行者的资信状况、债券的偿还期限和资金市场的供求情况等</li>
<li><p>债券还本期限与方式</p>
<ul>
<li>债券还本期限是指从债券发行到归还本金之间的时间</li>
<li>债券还本方式是指一次还本还是分期还本等，还本方式也应在债券票面上注明。</li>
</ul>
</li>
</ul>
<h4 id="债券的特征"><a href="#债券的特征" class="headerlink" title="债券的特征"></a>债券的特征</h4><ul>
<li>期限性</li>
<li>流动性: 仅仅次于储蓄存款；流动性非常好</li>
<li>收益性: 票息（债券利息） + 债券买卖价格差 = 债券收益率</li>
<li><p>安全性</p>
<p>  <strong>市场风险是指债券的市场价格随资本市场的利率上涨而下跌，因为债券的价格是与市场利率呈反方向变动的。当利率下跌时，债券的市场价格便上涨；而当利率上升时，债券的市场价格就下跌。而债券距离到期日越远，其价格受利率变动的影响越大。</strong></p>
</li>
<li><p>自主性</p>
</li>
</ul>
<h4 id="债券类型"><a href="#债券类型" class="headerlink" title="债券类型"></a>债券类型</h4><ul>
<li><p>按照发行主体分类</p>
<ul>
<li>政府</li>
<li>金融债券</li>
<li>企业债券</li>
</ul>
</li>
<li><p>按付息方式划分</p>
<ul>
<li><strong>贴现债券</strong>: 购买债券的时候，按照折扣来进行买；这样折扣就是利息;</li>
<li><strong>零息债券</strong>: 零息债券指债券到期时和本金一起一次性付息、利随本清，也可称为到期付息债券。付息特点一是利息一次性支付。二是债券到期时支付。</li>
<li><strong>附息债券</strong>: 附息债券指债券券面上附有息票的债券，是按照债券票面载明的利率及支付方式支付利息的债券。息票上标有利息额、支付利息的期限和债券号码等内容。持有人可从债券上剪下息票，并据此领取利息。附息国债的利息支付方式一般是在偿还期内按期付息，如每半年或一年付息一次。</li>
<li><strong>固定利率债券</strong>: 是在偿还期内利率固定的债券</li>
<li><strong>浮动利率债券</strong>: 浮动利率债券是指利率可以变动的债券。这种债券的利率确定与市场利率挂钩，一般高于市场利率的一定百分点。</li>
</ul>
</li>
<li><p>按照偿还期限划分</p>
<ul>
<li>长期：&gt; 10年; 我国是5年为分割点</li>
<li>中期:1 ~ 10年</li>
<li>短期: &lt; 1年</li>
</ul>
</li>
<li><p>按照是否可转换来区分</p>
<ul>
<li>可转债债券</li>
<li><p>不可转换债券</p>
<p>可转换债券是能按一定条件转换为其他金融工具的债券，而不可转换债券就是不能转化为其他金融工具的债券。可转换债券一般都是指的可转换公司债券，这种债券的持有者可按一定的条件根据自己的意愿将持有的债券转换成股票。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-债券市场"><a href="#2-债券市场" class="headerlink" title="2. 债券市场"></a>2. 债券市场</h3><p>债券市场, 分为一级市场和二级市场; 其实一开始我很不能理解，为什么会存在债券这种东西? 它存在的形式有的时候和股票那么像，可能买来买去，而且竟然价格还会那么不一致；这主要原因在于: </p>
<blockquote>
<p>债券市场，一个将债券变成可以交易的东西，而不再是只有两个人的关系; 现在的金融市场的基础是信用; 而债券本身就是信用证明，证明了其实期限一到就可以获得一笔钱; 这样以来，其实被借人可以将债券证明卖掉，来提前获得钱;</p>
<p>就这样,债券市场就产生了；那为什么会有价格高低呢? 原因在于每个时间点的利率是不一样的，与国家的基本利率有关系; 比如去年借钱利率是5%，但是今年就只有1%，那么如果5%的债券出来卖的时候价格肯定是高的，因为买走这个债券是有稳定的可预见的收益;</p>
</blockquote>
<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><ol>
<li>2010年，利率为5%, A为B借了100元; 那么就产生了借条: 100元，年利率为5%</li>
<li>2013年, B已经拿了两年的利息, 也就是10元；但是由于他比较缺钱，他需要把这个借条卖掉; 这年的利率是1%；</li>
<li>因为2013年的利率很低，所以B卖出这个债券的价格就比债券本身的面值(100)要高; 比如卖出的价格是105元; </li>
<li>那么B总共赚的钱是 10 + 5 = 15; 那么他的年华收益率100 <em> (1 + x) </em> (1 + x) = 115; 年化利率大概是7%； 这个利率比银行高好多啊; </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-债券&quot;&gt;&lt;a href=&quot;#1-债券&quot; class=&quot;headerlink&quot; title=&quot;1. 债券&quot;&gt;&lt;/a&gt;1. 债券&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;wiki-定义&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;债券(Notes)是政府、金融机构、工
    
    </summary>
    
      <category term="财经" scheme="http://yoursite.com/categories/%E8%B4%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Linux内存的一些知识</title>
    <link href="http://yoursite.com/2019/04/04/%E5%85%B3%E4%BA%8ELinux%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/04/04/关于Linux内存的一些知识/</id>
    <published>2019-04-04T03:50:57.000Z</published>
    <updated>2019-04-18T06:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>页表</p>
<p> 每个进程都会有自己的页表，页表的主要的作用就是将虚拟地址转化为真实的物理地址；通过页表的架构是这样的：</p>
<p> <img src="media/9C2C6E33-E0C4-4EEC-9F24-37C2C6E6917E.png" alt="9C2C6E33-E0C4-4EEC-9F24-37C2C6E6917E"></p>
</li>
</ol>
<p>有三个部分组成</p>
<pre><code>* 页表目录
* 页表
* 偏移量
</code></pre><p>多级的好处是节省内存占用率，如果只有一级的话，那么即使不用全部的线程地址，也会占用很多无效内存; 所以多级可以有效的介绍这部分的开销;</p>
<p>那不同进程是如何找到自己的页表的物理地址呢？那么就要靠<code>cr3(控制寄存器)</code>，每次进程切换会把这个寄存器恢复，那么每次查找页表的时候就可以轻而易举的找到页表；</p>
<ol start="2">
<li><p>页表和页的权限控制</p>
<p> 根据User/Supervisor这个flag来设置权限;这个flag是存在页表项的;</p>
<ul>
<li>0: 必须是内核态才能访问</li>
<li><p>1: 总能访问</p>
<p>通过这个就可以保护内存的访问，有的只有内核态的进程才能访问;</p>
</li>
</ul>
</li>
<li><p>PAE（物理地址扩展）</p>
<p> 明明地址空间只有32bit，如何能使用超过4GB的物理内存空间呢；就出现了PAE了; 其本质在于在cr3这个寄存器上做了手段；cr3本身指向页表的物理地址，所以cr3可以变化，可以指向多个页表的物理地址就可以访问多个物理地址了；<br> 寻址空间依然是4GB，只不过通过切换来使用更多的内存；但是由于用户态的进程不能修改页表，所以它无法使用超过4GB的物理内存；</p>
</li>
<li><p>高速缓存和TLB</p>
<p> 高速缓存主要解决的是cpu与ram速度的巨大差异，用来缓解这个过程；在cpu和ram之间加入高速缓存，cpu直接访问cache而不是RAM；使用的原理当时就是局部性原理；</p>
<pre><code>* 时间局部性: 在一定返回内会重复执行某一些东西
* 空间局部性: 访问了一个地址空间的内容，有极大的概率会访问周边的内存
</code></pre><p> 高速缓存的组成是cacheline，每一个cacheline大概是64kb; 那么如果确定当前地址是否在cache中呢，其实方式依然还是用虚拟地址中的各个地址位来进行判断;目前有三种；</p>
<p> TLB: 我们知道虚拟地址转为物理地址需要通过查找页表来进行；那么我们也知道RAM的速率和cpu相比很慢，如果每次都走一次RAM那基本上就没得玩了；所以TLB就是一个保存virtual-&gt;phyical的一个kv硬件缓存；但是当cr3这个寄存器修改的时候，TLB就会失效；so 切换进程是多么耗时的事情;</p>
</li>
<li><p>物理内存分布</p>
<p> 内核会将下面的页框保留下来，不会被动态分配和交换到磁盘上去 </p>
<ul>
<li>在不可用的物理地址范围内的页框</li>
<li><p>含有内核代码和已初始化的数据结构的页框</p>
<p>内核通常为了能保存在物理内存上连续存储，会选择跳过第一个MB，从0x00100000的物理地址开始使用;</p>
</li>
</ul>
</li>
<li><p>内核页表</p>
<p> 进程的页表在内核部分的页表是公用的；通过的方式是每次生成一个新的进程的时候，新的页表中内核页表是指向原来的进程是一样的；而用户态的页表是使用cow的方式，虽然也是一样的，从一开始来说;</p>
</li>
<li><p>缓存和tlb</p>
<ul>
<li><p>TLB高速缓存的刷新是内核而不是硬件；</p>
<p>  通常情况来说，进程切换的时候就会让tlb失效；内核在进行cr3变更的时候就会触发这个操作; 下面的几个情况，内核会避免TLB切换:</p>
<ul>
<li>当两个使用相同页表集的普通进程之间执行切换的时候；比如线程的切换</li>
<li>当一个普通进程和一个内核线程间进行切换的时候；因为内核线程是没有自己单独的页表的，而是内核统一的页表；所以切换的时候内核其实还是用进程之前的页表;</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;页表&lt;/p&gt;
&lt;p&gt; 每个进程都会有自己的页表，页表的主要的作用就是将虚拟地址转化为真实的物理地址；通过页表的架构是这样的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;media/9C2C6E33-E0C4-4EEC-9F24-37C2C6E6917E.png&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于线程、进程、协程的了解</title>
    <link href="http://yoursite.com/2019/03/29/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/29/关于线程、进程、协程的了解/</id>
    <published>2019-03-29T03:02:16.000Z</published>
    <updated>2019-04-02T15:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>虚拟地址、物理地址</p>
<p> linux的内存管理模块将物理地址封装到了底层，也就是说物理地址只有操作系统内核在管理，而程序员或者程序本身能获得的地址都是虚拟地址； 这么做的好处是:</p>
<ul>
<li>每一个进程有着独立和相同范围的虚拟地址; 与物理地址的关系有os来管理，每一个进程都会维护一个页表，这就是对应关系;</li>
<li>对权限管理会更加好做，防止进程访问相互的内存地址空间;</li>
</ul>
</li>
<li><p>进程之间的fork</p>
<p> linux的进程通过fork的方式创建子进程，当子进程创建初期，子进程和父进程是一样的；一样主要体现在页表内容是一致的；也就是表示两个进程的虚拟地址指向的物理地址一样的；如果一致一样肯定是不行的；所以当两个进程谁修改了对应的数据，就会以copy-on-write的方式来进行修改，其实本质就是修改虚拟地址指向其他的物理页;</p>
</li>
<li><p>进程描述符(每一个进程的一生的档案)</p>
<p> linux虽有线程概念，其本质依然还是进程，每一个线程都有进程描述符，但是线程与进程的区别在于有一些东西可以共享；每一个进程(线程)都存在一个pid；操作系统为了能更加好管理pid的空闲状态，通常会使用bitmap来保存使用状态；32bit的操作系统，通过会使用一个页来保存这些信息，这些信息会永久的存放在内存中; 64bit就会更加多一些;</p>
<p> 一个进程通常会有多个线程，线程与进程一致会存在pid，那么进程的pid是什么呢？linux中的方式就是将本线程组的pid设置会当前进程的pid，其实进程的pid就是线程组的tgid;</p>
</li>
<li><p>等待队列</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct wait_queue_t&#123;</span><br><span class="line">    unsigned int flags; // 0: 非互斥唤醒(将进程全部唤醒) 1:互斥唤醒(只唤醒一个等待的进程)</span><br><span class="line">    struct task_struct* task; //唤醒的具体的task</span><br><span class="line">    wait_queue_func_t func; // 等待队列中的睡眠进程应该用什么方式唤醒；</span><br><span class="line">    struct list_head task_list; // 等待线程链表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait_queue_t是等待队列的item;</span><br></pre></td></tr></table></figure>
<p>进程被阻塞或者等待的过程:</p>
<pre><code>1. 定义wait_queue_t的变量，然后使用init_waitqueue_entry来初始化变量
2. 将等待的变量加入到等待队列中去
3. schedule触发cpu调度
4. 当触发事件完成之后，回归到当前进程的第一件事就是删除等待队列这个变量；
</code></pre><p>wake_up的过程:如果某一个事件发生了,那么内核就会找到对应的等待队列，然后进行唤醒:</p>
<pre><code>1. 获得等待队列表头
2. 轮训队列
3. 如果等待的任务是非互斥的任务就进行唤醒
4. 如果等待的任务是互斥的，并且只是第一次被唤醒的话，那么就推出wake_up

这个任务等待队列有两个前提： 1. 非互斥的任务一定是放在互斥的任务之前 2. 任务可能会被超过一次唤醒，不过我猜应该可能保证是否已经被触发过；
</code></pre><ol start="5">
<li><p>进程切换（重点）</p>
<blockquote>
<p>进程切换、任务切换、context切换是指内核有能力挂起cpu上运行的进程，并恢复以前挂起的某一个进程的执行;</p>
</blockquote>
</li>
</ol>
<pre><code>&gt; cs: 代码段寄存器, ip: 指令指针寄存器，指向cpu下一条要运行的指令或者当前正在执行的指令;


进程切换首先需要了解，切换过程涉及到了什么呢？

* 硬件上下文：主要是指进程在恢复到cpu上运行的时候，必须恢复的寄存器数据; 硬件上下文仅仅只是进程切换的一个子集；这个上下文一部分存放在tss段，一部分存放在内核堆栈上;

    * 进程切换只发生在内核态，在进程进程切换之前，**用户态进程使用的所有寄存器**内容都会保存在**内核态堆栈**上，包括了ss和esp这对寄存器内存; 
    * 进程切换大部分是否是在时间中断的时候被触发，触发的过程会导致进程调度，所以才会只有在内核中存在；

* tss(task state segment): 任务状态段,虽然linux不使用硬件切换，但是强制每一个cpu会创建一个tss，原因:

    * 用户态到内核态切换的时候，可以从tss中获得内核堆栈的地址;
    * 进程IO性能的时候好，可以通过tss获得IO位图来检查权限;

    tss反映了CPU上的当前进程的特权级别; 因为linux不是每个进程一个tss，而是一个cpu一个tss，所以在切换的时候需要保存被替换的硬件上下文,这个和intel的原先设计有点出入;

* 进程描述符的thread字段，linux会被硬件上下文保存在这个字段中;

* Linux的进程切换的schedule函数

    1.切换页全局目录以安装一个新的地址空间
    2.切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程的所需要的所有信息，包括cpu寄存器

* switch_to(prev,next,last)

    * prev: 当前进程
    * next: 切换到目标的进程
    * last: 指向当前进程，其实就是prev的内存地址;

    1. 通常切换参数为prev,next,last,调用了switch_to之后这些参数通过压stack的方式保存在内核栈中;
    2. 将prev的内容写入到cpu的eax寄存器
    3. 恢复到next进程的内核栈；**注意注意：由于恢复到了next的内核栈，那么prev其实不在是真正的prev的，而是之前next在调用switch_to被切换出去的时候自己**，所以通过eax来将prev替换
    4. 将prev赋值给last

* switch_to 代码
</code></pre><ul>
<li><p>进程创建</p>
<blockquote>
<p>通用寄存器的值是在从用户态切换到内核态时被保存到内核态堆栈中的;</p>
</blockquote>
<p>  Linux进程创建的优化：</p>
<ul>
<li>子进程复制父进程的资源；并非是完全copy；而是使用了COW的方式进行优化</li>
<li>线程和进程，线程其实就是Linux中轻量级的进程，只不过使用了共享父进程的很多资源来保证高效创建；</li>
<li><p>vfork:共享父进程的内存地址空间，又不具有cow性质;</p>
<p>总结：进程创建过程中，子进程必须要申请的资源是task_struct和对应的内核栈的空间，所以内核栈是每个线程或者进程都会存在一个的; 虽然在空间上是分离的，但是在赋值的时候还是会将父进程的大部分东西赋值给子进程，尤其是在操作过程将描述符的很多字段进行赋值；这个过程中有几点需要明确:</p>
<ul>
<li>描述符进行了赋值、thread也进行了部分赋值；但是esp、eax这些寄存器值确是自己的；因为这        是很重要的,esp指向的是子进程内核, eax是存放系统调用的返回值,因为fork会返回两个值，返回父进程的是子进程的pid，而返回给子进程是0; eip用于存储下一条执行的指令;</li>
<li>执行完clone之后，进程就可以被调度了；当子进程被调度到的时候，就会将内核栈存储的硬件上下文装载到cpu，这样可以是cpu恢复到用户态模式；这个时候父进程和子进程有一些不一样的，1是进程描述符不一样，2. 进程内核栈不一样；3.eax不一样的； 但是代码段是共享的，所以通过eax（返回值不一样）可以判断是子进程还是父进程；虽然大部分的资源是共享的，但是通过修改寄存器的值来保证子进程的运行;</li>
</ul>
</li>
</ul>
</li>
<li><p>内核线程</p>
</li>
</ul>
<p>区别点：</p>
<pre><code>* 内核线程只会运行在内核态；普通进程可以在用户态也可以在内核态
* 内核线程只能访问PAGWE_OFFSET以上的线性地址，而普通线程可以是全部的线性地址；
</code></pre><p>自己的理解可能是这样的，内核线程之间是共享地址空间的；类似于一个进程下面的线程一样，使用了相同的地址空间; 所有的内核线程其实使用了一个地址空间，而且地址空间的范围也是一定的；创建内核线程与普通进程创建是一致的；</p>
<pre><code>* 进程0:所有进程的祖先，这个是linux初始化的时候静态分配的，而其他的进程都是动态分配
* 创建pid为1的进程，然后进程0开始执行cpu idle的函数，这个函数主要是用于没有runing进程的时候就开始执行cpuidle的任务
</code></pre><p>其他的内核线程</p>
<pre><code>* keventd(事件)：执行keventd_wq工作队列
* kaqmq：与电源相关的事件
* kswapd: 执行内存回收
* pdflush: pagecache脏页会写
* kblockd: 执行kblock_workqueue工作队列的函数。它周期性地激活块设备驱动
* ksoftirq: 执行tasklet，每个cpu都有这样的内核线程
</code></pre><ul>
<li><p>进程终止</p>
<p>  当父进程使用wait处理了子进程挂的信号，那么这个时候子进程的最后资源就会被回收，这部分资源主要是集中在进程描述符上面，还有就是thread对象和内核栈</p>
</li>
</ul>
<ul>
<li><p>线程和进程的区别在于：</p>
<ul>
<li>在linux下面线程其实被当作进程处理，有着自己的task_struct结构，只不过线程在创建过程中会共享父进程的内存空间地址;</li>
<li>因为是被当作单独的task来处理，所以线程有着自己的内核栈; 当线程因为某一种关系进入内核的时候需要内核栈来保存硬件上下文(寄存器等值)</li>
<li>线程有着自己的寄存器的值</li>
<li><p>线程有着自己的stack；如果公用主线程的stack就会破坏stack结构;</p>
<p>fork如果创建的是一个子进程，也就说flag没有带上CLONE_VM的话，那么就表示子进程有着自己独立的地址空间，只不过只不过一开始的时候内容是和父进程是一样的；但是但是这过程中有一个页表copy的过程；</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚拟地址、物理地址&lt;/p&gt;
&lt;p&gt; linux的内存管理模块将物理地址封装到了底层，也就是说物理地址只有操作系统内核在管理，而程序员或者程序本身能获得的地址都是虚拟地址； 这么做的好处是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个进程有着独立和相同范围的虚拟地址;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>整理</title>
    <link href="http://yoursite.com/2019/01/10/%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/10/整理/</id>
    <published>2019-01-10T02:11:15.000Z</published>
    <updated>2019-03-29T03:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年末2019年初，又开始新的一年面试;昨天晚上面了一个做存储的公司，全程基本上都是被压着问，通过这次面试给我最大的感悟就是基础知识需要扎实，并且要互联起来; 知识点除了要知道还要知道为什么这么设计; 这次面试对基础询问真的很多很多;</p>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ul>
<li>面试题: 对于一个有序数组，找到第一个大于等于目标value的index; </li>
</ul>
<blockquote>
<p>一看就是一个二分法查询的过程，但是我当时脑中一片混乱，实在是不知道怎么办; 这个对二分法需要进行改造，主要是在小于等于中间值的时候，需要去比较前面一个值的大小，如果小那就指定的值，如果大于目标值那就在二分查找一下;</p>
</blockquote>
<ul>
<li><p>C++系列的问题</p>
<ul>
<li><p>new、delete和free、malloc的区别; 为什么对于数组new和delete需要加上<code>[]</code>来做区别</p>
<ol>
<li>new 除了可以在堆上使用，也可以用户自定义内存地址来申请;</li>
<li>new即会申请内存空间也会调用数据类型的构造函数初始化;</li>
<li>为什么数组new需要带上<code>[]</code>, 本质上依然还是需要告诉编译器去调用构造函数; 而delete带有<code>[]</code>则是为了调用析构函数</li>
</ol>
</li>
</ul>
</li>
<li><p>右值引用是什么? 推出的目的又是什么?</p>
</li>
<li>vector的push_back的时间复杂度是多少? O(1), 均摊下来应该是常量</li>
<li><p>C++ 6种内存模型;</p>
<ul>
<li>内存模型用来解决什么问题</li>
<li>具体的区别什么</li>
</ul>
</li>
<li><p>linux的问题</p>
<ul>
<li>进程、线程、协程之前的区别点;<ul>
<li>进程、线程、协程切换上下文切换需要保存哪些信息</li>
</ul>
</li>
<li>load定义</li>
<li>虚拟地址空间的排布</li>
</ul>
</li>
<li><p>网络</p>
<ul>
<li>tcp三次握手和断开的4次握手;  这边深究了一下为什么三次握手需要三次而不是二次或者其他</li>
<li>epoll的作用，实现原理，为什么高效</li>
</ul>
</li>
<li><p>存储</p>
<ul>
<li>介绍一下LSM-Tree结构</li>
<li><p>rocksdb查询过程; </p>
<ul>
<li>假如没有分层会怎么样,都聚集在L0层查询效率会变差很多</li>
<li>compaction的过程？写放大是如何计算方式?</li>
<li>writeBatch的作用</li>
<li>writeBatch的原子性是如何实现的</li>
<li>rocksdb对读优化有哪些   </li>
</ul>
</li>
</ul>
</li>
<li><p>共识</p>
<ul>
<li>raft整体过程</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li>acid</li>
<li>隔离性的几种</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年末2019年初，又开始新的一年面试;昨天晚上面了一个做存储的公司，全程基本上都是被压着问，通过这次面试给我最大的感悟就是基础知识需要扎实，并且要互联起来; 知识点除了要知道还要知道为什么这么设计; 这次面试对基础询问真的很多很多;&lt;/p&gt;
&lt;h3 id=&quot;1-问题
    
    </summary>
    
      <category term="interview" scheme="http://yoursite.com/categories/interview/"/>
    
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>进程调度之死循环</title>
    <link href="http://yoursite.com/2017/04/12/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B9%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2017/04/12/进程调度之死循环/</id>
    <published>2017-04-12T14:21:34.000Z</published>
    <updated>2017-04-13T01:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲的是Linux的进程调度问题，但是能形象的解释其中的一系列的观点，所以找了一个比较经典问题来做载体. 在具体开始之前，先了解一下什么是进程调度呢？</p>
<blockquote>
<p>个人的理解是: 目前操作系统基本都是多任务操作系统，也就是说一个操作系统中存在有多个进程，但是CPU资源是有限的，不能让所有的进程都能一直在运行；所以调度系统就是一个将cpu资源合理分配给各个可运行状态的进程的内核子系统,是多任务操作系统的基础;</p>
</blockquote>
<p>貌似很复杂难懂的调度系统有着一个非常简单的目标: <strong>最大限度利用CPU的处理时间</strong>; 调度系统的基本任务就是: <strong>从多个可运行状态的进程中挑选出一个合适的进程来运行</strong>, 这里的<strong>合适</strong>也是调度系统的核心算法.</p>
<h4 id="1-提问"><a href="#1-提问" class="headerlink" title="1. 提问"></a>1. 提问</h4><p><em>为什么死循环能让CPU利用达到100%呢?</em> </p>
<p>这个问题也是困扰我多年的问题，当然可能就是因为对Linux操作系统的进程调度没有学好才导致这个问题一直困扰我. 针对上面的问题还能引出几个其他的问题?</p>
<ul>
<li>死循环是否会导致系统响应速度下降;</li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要讲的是Linux的进程调度问题，但是能形象的解释其中的一系列的观点，所以找了一个比较经典问题来做载体. 在具体开始之前，先了解一下什么是进程调度呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人的理解是: 目前操作系统基本都是多任务操作系统，也就是说一个操作系统
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="进程调度" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://yoursite.com/2017/04/07/Linux%E4%B9%8B%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/04/07/Linux之进程管理/</id>
    <published>2017-04-06T23:16:14.000Z</published>
    <updated>2017-04-10T13:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统本身没有对线程做出特殊的改造，在Linux中线程本身与创建进程的流程是一样的；唯一与进程的区别是在创建过程中，进程的创建是资源独立的，而线程在创建的过程中，会与其他的进程共享一些资源；所以在Linux中，线程本就是进程，一个有着一点点不同的进程.</p>
<p>Linux中每一个进程都会有一个统一的结构<code>task_struct(进程描述符)</code>, 这个结构包含了进程的所有的信息，包括状态、占有的资源、内存空间等一些; Linux将这些进程描述符放在任务队列中来分别进行调用.</p>
<h4 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1. 进程的状态"></a>1. 进程的状态</h4><ul>
<li>TASK_RUNNING(运行 or 就绪): 这个状态的进程要不就是正在运行或者在运行队列中等待运行; </li>
<li>TASK_INTERRUPTIBLE(中断): 表示当前进程处于等待状态，直到某一个条件为真或者传递一个信号都能唤醒进程;</li>
<li>TASK_UNINTERRUPTIBLE:与TASK_INTERRUPTIBLE类似，只是这个状态的进程不会因为信号而被唤醒;</li>
<li>TASK_STOPPED:进程执行被暂停，当收到到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号的时候;</li>
<li>TASK_ZOMBIE: 进程执行被终止，但是父进程还没有调用wait4或waitpid来收集信息;</li>
<li>TASK_DEAD:进程彻底死亡状态</li>
<li>TASK_TRACED:跟踪状态，用于debug</li>
</ul>
<h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>上面已经说了，Linux的进程和线程的创建几乎是一模一样的，只是后面会有点点小小的区别;Linux创建进程的过程主要依赖两个系统调用fork+exec; </p>
<h5 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h5><p>进程调用fork就可以创建子进程；之前的fork是比较粗暴，直接复制所有的资源给子进程，但是这样效率比较低效，因为子进程通过会通过exec来加载另外的程序，那么之前的copy过程就是无用功. 所谓的<code>copy-on-write</code>，就是在调用fork的时候只分配一些进程与进程之间必须独立的资源，比如task_struct结构体、页表(内容是copy父进程的)、内核栈等，其他的资源都是父进程的引用而已;通过这种方式来提高性能.</p>
<p>fork的基本流程是如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">fork=&gt;operation: fork</span><br><span class="line">clone=&gt;operation: clone</span><br><span class="line">dofork=&gt;operation: do_fork</span><br><span class="line">dup=&gt;operation: copy一个父进程的进程描述符(比如内核栈、task_struct、thread_info，这些可能是每一个进程所必须的结构)</span><br><span class="line">setstate=&gt;operation: 设置子进程状态，并且修改进程描述符做区别</span><br><span class="line">copy=&gt;operation: 根据clone传入的参数来进行资源copy</span><br><span class="line">run=&gt;operation: 平分时间片，然后将子进程唤醒</span><br><span class="line"></span><br><span class="line">st-&gt;fork-&gt;clone-&gt;dofork-&gt;dup-&gt;setstate-&gt;copy-&gt;run-&gt;e</span><br></pre></td></tr></table></figure>
<h5 id="2-2-关于Linux中的线程"><a href="#2-2-关于Linux中的线程" class="headerlink" title="2.2 关于Linux中的线程"></a>2.2 关于Linux中的线程</h5><p>上面说了，Linux的线程其实就是linux的进程，只是在创建的时候传给<code>clone</code>函数的参数上有一些不一样的; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</span><br></pre></td></tr></table></figure>
<p>线程在创建的时候通过传入以上的几个参数，这可能就是与进程创建区别了，这样创建的进程与父进程是共享地址空间、文件系统、打开的文件、信号处理函数；所以从这看出，Linux所谓的线程本质其实就是进程。</p>
<h5 id="2-3-内核线程-Kernal-thread"><a href="#2-3-内核线程-Kernal-thread" class="headerlink" title="2.3 内核线程(Kernal thread)"></a>2.3 内核线程(Kernal thread)</h5><p>内核线程与普通的进程的区别在于</p>
<pre><code>* 内核线程没有独立的地址空间
* 只运行在内核态，从不切换到用户态
</code></pre><p>其他是类似的，可以被抢占，也可以被调度;</p>
<h4 id="3-进程死亡"><a href="#3-进程死亡" class="headerlink" title="3. 进程死亡"></a>3. 进程死亡</h4><p>每一个进程总会面临死亡的过程，那么进程的死亡要经过哪几个步骤呢？一个进程的创建的过程是赋予资源，那么进程死亡就是归还资源的过程;</p>
<p>什么时候进程会面临终结呢? 显示的调用了<code>exit()</code>这个系统调用，或者是被动总结，不管怎么样触发，这个过程都有<code>do_exit</code>完成;</p>
<ul>
<li>释放各种资源</li>
<li>设置进程的状态为TASK_ZOMBIE</li>
<li>发送信号给父进程，说我快终结了</li>
<li>调用schedule函数，主动的放弃cpu</li>
</ul>
<p>到此为止，进程已经释放了大部分的资源，不过还保存着进程描述符、内核栈、thread_info等一些必要的数据结构，直到父进程调用<code>wait4()</code>系统收集子进程的一些状态，那么这进程就真正的终结;Linux将资源清理与进程描述符清理分开执行;</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><ul>
<li>进程状态</li>
<li>Linux 进程与线程是同样的东西;</li>
<li>进程的创建与死亡</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统本身没有对线程做出特殊的改造，在Linux中线程本身与创建进程的流程是一样的；唯一与进程的区别是在创建过程中，进程的创建是资源独立的，而线程在创建的过程中，会与其他的进程共享一些资源；所以在Linux中，线程本就是进程，一个有着一点点不同的进程.&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="书笔记" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>scylladb 官文安装译文</title>
    <link href="http://yoursite.com/2017/04/04/scylladb-%E5%AE%98%E6%96%87%E5%AE%89%E8%A3%85%E8%AF%91%E6%96%87/"/>
    <id>http://yoursite.com/2017/04/04/scylladb-官文安装译文/</id>
    <published>2017-04-04T11:56:06.000Z</published>
    <updated>2017-04-06T23:16:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要的依赖于官方的教程，这边主要是将一些细节进行串联描述，下次安装的时候会更加自动化;</p>
<p>我的安装环境如下：</p>
<ul>
<li>centos7.2</li>
<li>内核版本为3.18</li>
</ul>
<h4 id="1-关于scylladb几个rpm的介绍"><a href="#1-关于scylladb几个rpm的介绍" class="headerlink" title="1. 关于scylladb几个rpm的介绍"></a>1. 关于scylladb几个rpm的介绍</h4><ul>
<li>scylla-server(standard):scylladb主要的server端</li>
<li>scylla-server(debuginfo):scylladb server端并且带有debuginfo</li>
<li>scylla-jmx: 兼容cassandra通过jmx端口进行访问</li>
<li>scylla-tools: scylla为了兼容cassandra而提供的类似的功能:<ul>
<li>nodetool:很强大的功能，用来观察集群状态</li>
<li>cqlsh:</li>
<li>cassandra-stress:压测工具</li>
</ul>
</li>
</ul>
<h4 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2.前期准备"></a>2.前期准备</h4><ul>
<li>删除abrt,主要是这个与scylladb本身的coredump配置冲突; <code>yum remove -y abrt</code></li>
<li>必须有sudo权限</li>
<li>预安装的东西, <code>yum install -y wget epel-release</code>, <code>epel-release</code>是一个fedora维护的软件仓库，全名叫做<em>企业版Linux额外软件包</em></li>
</ul>
<h4 id="3-正式开始装"><a href="#3-正式开始装" class="headerlink" title="3. 正式开始装"></a>3. 正式开始装</h4><ul>
<li>下载最新的scylladb源，由于每次更新源都会有一定的变化，所以每一次更新的时候最好要更新一下源;下面的源是1.4版本的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/scylla.repo http://downloads.scylladb.com/rpm/centos/scylla-1.4.repo</span><br></pre></td></tr></table></figure>
<ul>
<li><p>是scylla yum源生效; <code>yum clean all; yum makecache</code></p>
</li>
<li><p>安装scylla; <code>yum install -y scylla</code></p>
</li>
</ul>
<p>如果一些顺利的话，到这一步scylladb就已经安装完毕了</p>
<h4 id="4-配置和脚本相关的"><a href="#4-配置和脚本相关的" class="headerlink" title="4. 配置和脚本相关的"></a>4. 配置和脚本相关的</h4><table>
<thead>
<tr>
<th>配置名字</th>
<th>配置作用</th>
<th>配置位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>scylladb的主要配置</td>
<td>设定一些主要的参数，比如存储位置、开放端口和ip，也会有一些性能参数设置</td>
<td>/etc/scylla/scylla.yaml</td>
</tr>
<tr>
<td>scylla启动脚本</td>
<td></td>
<td>/etc/sysconfig/scylla-server</td>
</tr>
<tr>
<td>系统资源限制</td>
<td>去掉对scylla用户的资源限制</td>
<td>/etc/security/limits.d/scylla.conf</td>
</tr>
<tr>
<td>启动脚本</td>
<td>设置参数、启动scylladb脚本</td>
<td>/etc/sysconfig/scylla-server</td>
</tr>
<tr>
<td>coredump配置文件</td>
<td>设置coredump的配置文件</td>
<td>/etc/sysconfig/sysctl.d/99-scylla.conf</td>
</tr>
<tr>
<td>collectd配置文件</td>
<td>设置collectd的一些配置</td>
<td>/etc/collectd.d/scylla.conf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>配置名字</th>
<th>配置作用</th>
<th>配置位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>内核设置</td>
<td>在bootloader中设置内核参数</td>
<td>/usr/lib/scylla/scylla_bootparam_setup</td>
</tr>
<tr>
<td>coredump配置文件生成器</td>
<td></td>
<td>/usr/lib/scylla/scylla_coredump_setup</td>
</tr>
<tr>
<td>ntp协议配置生成器</td>
<td></td>
<td>/usr/lib/scylla/scylla_ntp_setup</td>
</tr>
<tr>
<td>网络配置设定</td>
<td></td>
<td>/usr/lib/scylla/scylla_prepare</td>
</tr>
<tr>
<td>配置raid和文件系统的脚本</td>
<td></td>
<td>/usr/lib/scylla/scylla_raid_setup</td>
</tr>
<tr>
<td>压缩coredump脚本</td>
<td>only ubuntu有效</td>
<td>/usr/lib/scylla/save_coredump</td>
</tr>
<tr>
<td>重新设置网络模式</td>
<td>如果scylladb运行的virtio或者DPDK的话，就重新设置网络模式</td>
<td>/usr/lib/scylla/scylla_stop</td>
</tr>
<tr>
<td>重新设置网络参数</td>
<td></td>
<td>/usr/lib/scylla/posix_net_conf.sh</td>
</tr>
<tr>
<td>io.conf生成器</td>
<td>用于测试io性能，并且把文件提供给scylladb</td>
<td>/usr/lib/scylla/scylla_io_setup </td>
</tr>
</tbody>
</table>
<p>上面这些脚本都是在<code>/usr/lib/scylla</code>目录下面的，并且还有其他的脚本，这些脚本会在运行scylla_setup的时候会调用;详情请看<a href="http://www.scylladb.com/doc/system-configuration/" target="_blank" rel="noopener">url</a></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>端口值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cql</td>
<td>9042</td>
</tr>
<tr>
<td>内部rpc</td>
<td>7000</td>
</tr>
<tr>
<td>ssl内部rpc</td>
<td>7001</td>
</tr>
<tr>
<td>jmx 端口</td>
<td>7199</td>
</tr>
<tr>
<td>scylla rest api</td>
<td>10000</td>
</tr>
<tr>
<td>Scylla Prometheus API(不知道是什么)</td>
<td>9180</td>
</tr>
<tr>
<td>node_exporter</td>
<td>9100</td>
</tr>
</tbody>
</table>
<h4 id="5-具体的配置"><a href="#5-具体的配置" class="headerlink" title="5. 具体的配置"></a>5. 具体的配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>seeds</td>
<td>种子ip列表，建议多几个ip</td>
</tr>
<tr>
<td>listen_address</td>
<td>scylladb内部通信的ip</td>
</tr>
<tr>
<td>rpc_address</td>
<td>客户端连接scylladb的ip</td>
</tr>
<tr>
<td>broadcast_address</td>
<td>默认listen_address，从其他节点角度看这个node的ip，可能是不同网络之间不同，而通过外网来进行互联</td>
</tr>
<tr>
<td>broadcast_rpc_address</td>
<td>默认是rpc_address,从client角度上来你应该是什么ip，同上</td>
</tr>
</tbody>
</table>
<h4 id="6-scylladb管理命令"><a href="#6-scylladb管理命令" class="headerlink" title="6. scylladb管理命令"></a>6. scylladb管理命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scylla –version</td>
<td>查看版本</td>
</tr>
<tr>
<td>nodetool snapshot</td>
<td>将node数据进行快照;关于scylladb snapshot的原理是：通过linux的hardlink来进行备份，因为scylladb的文件产生之后会不会改变所以这样能很好的保证备份的作用，并且用来了hardlink保证文件的可用性，和不需要通过拷贝也加重系统的负载;</td>
</tr>
<tr>
<td>恢复备份</td>
<td>1. 清空commitlog 2. 清空data目录下面的数据文件 3. 把snapshot备份的文件mv过来即可 4. 重启</td>
</tr>
<tr>
<td>提供rest接口</td>
<td></td>
</tr>
<tr>
<td>scyllatop</td>
<td>scylla自己的top, 目测可以与collectd一起使用，并且提供比较好的功能</td>
</tr>
<tr>
<td>Prometheus</td>
<td>scylla自己的监控系统</td>
</tr>
<tr>
<td>collectd</td>
<td>scylladb本地会启动collectd的进程，用来接收scylladb抛送过来的数据，可以通过插件的方式来修改，比较方便，并且会增加scyllatop看到的数据</td>
</tr>
<tr>
<td>log</td>
<td>scylla log是通过centos7的 journalctl 来控制的；最常用的有<code>journalctl _COMM=scylla -p warning</code> 或者 <code>journalctl _COMM=scylla --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00</code> 或者 <code>journalctl _COMM=scylla -b(从最近一次重启的日志)</code></td>
</tr>
</tbody>
</table>
<p>node tool命令介绍</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodetool status</td>
<td>看集群的状态,<a href="http://www.scylladb.com/doc/nodetool-commands/status/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool snapshot</td>
<td>上面已提过</td>
</tr>
<tr>
<td>nodetool cfhistograms</td>
<td>提供每一个表的静态数据，包括sstable的个数、读写延迟、分区的尺寸和列簇的个数;<code>nodetoll sfhistograms keyspace tablename</code>,<a href="http://www.scylladb.com/doc/nodetool-commands/cfhistograms/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool cfstats</td>
<td>提供对特定的表的一个深层的分析;<code>nodetool cfstats keyspace.tablename</code>,<a href="http://www.scylladb.com/doc/nodetool-commands/cfstats/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool cleanup</td>
<td>立即触发清理不属于本机的key；<code>nodetool cleanup -h 127.0.0.1 keyspace</code></td>
</tr>
<tr>
<td>nodetool clearsnapshot</td>
<td>清理snapshot文件,<code>nodetool clearsnapshot keyspace</code>,不写keyspace就默认删除全部的snapshot </td>
</tr>
<tr>
<td>compactionhistory</td>
<td>打印compact的历史</td>
</tr>
<tr>
<td>compactionstats</td>
<td>打印目前正在compact的进度和一些信息</td>
</tr>
<tr>
<td>compact</td>
<td>对可能的keyspac而进行强制的compact操作; <code>nodetool compact keyspace</code></td>
</tr>
<tr>
<td>describecluster</td>
<td>打印一些信息</td>
</tr>
<tr>
<td>decommission</td>
<td></td>
</tr>
<tr>
<td>describering</td>
<td>打印某一个keyspace的一致性hash分布情况</td>
</tr>
<tr>
<td>disablebackup</td>
<td>关闭增量备份</td>
</tr>
<tr>
<td>disablebinary</td>
<td>关闭cql</td>
</tr>
<tr>
<td>statusbinary</td>
<td>看cql当前运行的状态</td>
</tr>
<tr>
<td>enablebinary</td>
<td>开启cql</td>
</tr>
<tr>
<td>statusgossip</td>
<td>gossip协议的运行状态</td>
</tr>
<tr>
<td>disablegossip</td>
<td>关闭gossip</td>
</tr>
<tr>
<td>enablegossip</td>
<td>开启gossip</td>
</tr>
<tr>
<td>drain</td>
<td>通常用于升级scylladb之前使用，主要的操作是将所有的memtable全部写入到sstable，然后停止listen各种端口，之后要恢复必须通过重启</td>
</tr>
<tr>
<td>flush</td>
<td>将当然的memtable刷成sstable</td>
</tr>
<tr>
<td>getendpoints</td>
<td><code>nodetool getendpoints keyspace tablename key</code>,现在还不知道用来做什么</td>
</tr>
<tr>
<td>getlogginglevels</td>
<td>获得运行时中的日志等级</td>
</tr>
<tr>
<td>gossipinfo</td>
<td>展示gossip协议中传播的东西</td>
</tr>
<tr>
<td>info</td>
<td>展现当前节点的一些信息; <a href="http://www.scylladb.com/doc/nodetool-commands/info/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>listsnapshots</td>
<td>展示所有的snapshot在磁盘上的占用率</td>
</tr>
<tr>
<td>move</td>
<td>将node 分配到新的token</td>
</tr>
<tr>
<td>netstats</td>
<td>打印一些网络信息</td>
</tr>
<tr>
<td>proxyhistograms</td>
<td>对于网络操作打印一些静态统计</td>
</tr>
<tr>
<td>rebuild <src-dc-name></src-dc-name></td>
<td>从另外一个节点重建数据</td>
</tr>
<tr>
<td>refrash <keyspace> <tablename></tablename></keyspace></td>
<td>在不重启的前提下，重新reload文件中的sstable</td>
</tr>
<tr>
<td>removenode <id></id></td>
<td>移除名为id的节点</td>
</tr>
<tr>
<td>repair</td>
<td>修复一个或者多个的列簇； 参数比较多，使用前查询;</td>
</tr>
<tr>
<td>ring</td>
<td>显示一致性hash的列表</td>
</tr>
<tr>
<td>setlogginglevel <class> <threshold></threshold></class></td>
<td>设置某一个类的运行时日志等级</td>
</tr>
<tr>
<td>settraceprobability – <value></value></td>
<td>设置跟踪请求的概率，value在0~1之间</td>
</tr>
<tr>
<td>snapshot [-t tag] [-cf tablename] <keyspace></keyspace></td>
<td>针对具体的表或keyspace做快照</td>
</tr>
<tr>
<td>statusbackup</td>
<td>增量backup的状态</td>
</tr>
<tr>
<td>stop</td>
<td>停止compact任务</td>
</tr>
<tr>
<td>version</td>
<td>db的版本  </td>
</tr>
</tbody>
</table>
<p>nodetool info几个参数介绍</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gossip active</td>
<td>gossip状态</td>
</tr>
<tr>
<td>Thrift active</td>
<td>thrift 状态</td>
</tr>
<tr>
<td>native transport active</td>
<td>cql的状态</td>
</tr>
<tr>
<td>Load</td>
<td>sstable占磁盘多少空间</td>
</tr>
<tr>
<td>Generation NO</td>
<td>主版本，当节点重启、token更新，这个版本就会往上增加</td>
</tr>
<tr>
<td>Uptime</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Heap Memory</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>off Heap memory (MB)</td>
<td>所有的memtables、bloom filters 、indexs、compression metadata占用的内存</td>
</tr>
<tr>
<td>Data center</td>
<td>这个节点所在的数据中心</td>
</tr>
<tr>
<td>Rack</td>
<td>？？、</td>
</tr>
<tr>
<td>Exception</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Key Cache</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Row Cache</td>
<td>Row cache的信息</td>
</tr>
<tr>
<td>Counter Cache</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Token</td>
<td>token展示</td>
</tr>
</tbody>
</table>
<h4 id="7-关于scylladb的monitor安装-由于官方教程变化太大-以官方为准"><a href="#7-关于scylladb的monitor安装-由于官方教程变化太大-以官方为准" class="headerlink" title="7. 关于scylladb的monitor安装[由于官方教程变化太大,以官方为准]"></a>7. 关于scylladb的monitor安装[由于官方教程变化太大,以官方为准]</h4><p>目前scylladb的监控是使用<a href="https://github.com/scylladb/scylla-grafana-monitoring" target="_blank" rel="noopener">Grafana and Prometheus
</a>, 具体的安装过程如下:</p>
<ol>
<li>首先安装docker在服务器上; <code>sudo yum install -y docker</code></li>
<li>启动docker服务;<code>sudo service docker start</code></li>
<li>验证docker安装情况; <code>sudo docker ps -a or sudo docker images</code></li>
</ol>
<p>其实监控安装比较简单，但是由于网络问题安装就变成很蛋疼的过程;</p>
<ul>
<li>首先通过mac翻墙下载docker 镜像; prom/prometheus and grafana/grafana</li>
</ul>
<pre><code>docker pull prom/prometheus:v1.5.2
docker pull grafana/grafana:4.1.1
</code></pre><ul>
<li>将镜像导出成tar格式的文件</li>
</ul>
<pre><code>docker save imageid -o xxx.tar
</code></pre><p>镜像id可以通过<code>docker images</code>来得到</p>
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
grafana/grafana     latest              a892c250adfa        11 days ago         266.2 MB
prom/prometheus     latest              bdeacb538ef9        2 weeks ago         79.25 MB
</code></pre><ul>
<li>将tar文件上传到服务器，然后导入服务器的docker</li>
</ul>
<pre><code>docker load -i xxx.tar
#修改对应的name和版本
docker tag imageId name:tag

sudo docker tag  047fd14b7251 prom/prometheus:v1.0.0
sudo docker tag d7528263f75a grafana/grafana:3.1.0
</code></pre><ul>
<li>下载 scylla-grafana-monitoring 项目</li>
</ul>
<pre><code>git clone https://github.com/scylladb/scylla-grafana-monitoring.git
</code></pre><ul>
<li>修改prometheus的配置文件</li>
</ul>
<pre><code>global:
# 采集周期
  scrape_interval: 15s # By default, scrape targets every 15 seconds.

  # Attach these labels to any time series or alerts when communicating with
  # external systems (federation, remote storage, Alertmanager).
  external_labels:
    monitor: &apos;scylla-monitor&apos;

scrape_configs:
    - job_name: scylla
  honor_labels: true
  static_configs:
  # 这个是scylladb服务的地址，这边是主动采集为主，不是被动上报，主要收集scylla的metric信息
      - targets: [&quot;10.19.11.23:9180&quot;]
    - job_name: node_exporter
  honor_labels: true
  static_configs:
  # 这部分主要是收集scylla的机器的信息，需要通过node_exporter 来开启这个上报;
      - targets: [&apos;10.19.11.23:9100&apos;]

## two servers example: - targets: [&quot;172.17.0.3:9103&quot;,&quot;172.17.0.2:9103&quot;]
</code></pre><ul>
<li>用启动脚本启动</li>
</ul>
<pre><code>sudo sh start-all.sh -d data_dir -v 1.6
</code></pre><p>data路径最好要配置一个，不然两次启动会把数据删除<br>-v: 用来表示加载哪个系统版本</p>
<p>这个可能会碰到一个问题，</p>
<pre><code>598cf3f9e16f0e5df2a1f0cf79df8be2ee0909f80307e392911d140b2ff6dac8
Wait for Prometheus container to start..        4721e32c86ea09f1e16d270a194eb979cbf61f249c066435234e7d5cafee8631
Wait for Grafana container to start........curl: (7) Failed connect to localhost:3000; Connection refused
curl: (7) Failed connect to localhost:3000; Connection refused
curl: (7) Failed connect to localhost:3000; Connection refused        curl: (7) Failed connect to localhost:3000; Connection refused
</code></pre><p>Grafana 没有起来 或者起来，但是还没有监听端口，然后脚本最多只是重试7次，这个时候就会报错，其实后期grafana是成功起来的；</p>
<p>解决方式有两个：</p>
<pre><code>1. 先执行脚本，然后等到grafana起来，然后关掉prometheus,然后修改start-all.sh中的脚本，把docker run grafana那个部分去掉，然后在执行start-all.sh, 这样就ok了
2. 将重试几次增大
</code></pre><ul>
<li>关闭监控</li>
</ul>
<pre><code>sudo sh kill-all.sh
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要的依赖于官方的教程，这边主要是将一些细节进行串联描述，下次安装的时候会更加自动化;&lt;/p&gt;
&lt;p&gt;我的安装环境如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;centos7.2&lt;/li&gt;
&lt;li&gt;内核版本为3.18&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-关于scylladb几个r
    
    </summary>
    
      <category term="scylladb" scheme="http://yoursite.com/categories/scylladb/"/>
    
    
      <category term="scylladb" scheme="http://yoursite.com/tags/scylladb/"/>
    
  </entry>
  
</feed>
