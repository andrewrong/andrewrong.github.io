<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nomoshen</title>
  <subtitle>尽可能努力一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-27T06:32:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>nomoshen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka broker的监控信息</title>
    <link href="http://yoursite.com/2017/03/26/kafka-broker%E7%9A%84%E7%9B%91%E6%8E%A7%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2017/03/26/kafka-broker的监控信息/</id>
    <published>2017-03-26T13:35:09.000Z</published>
    <updated>2017-03-27T06:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-broker的监控信息"><a href="#1-broker的监控信息" class="headerlink" title="1. broker的监控信息"></a>1. broker的监控信息</h3><table>
<thead>
<tr>
<th>标题</th>
<th>mbean name</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Message in rate</td>
<td><code>kafka.server:type=BrokerTopicMetrics,name=MessagesInPerSec</code></td>
<td>当前broker每秒的消息个数</td>
</tr>
<tr>
<td>Byte in rate</td>
<td><code>kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec</code></td>
<td>当前broker的每秒的入口流量</td>
</tr>
<tr>
<td>Byte out rate</td>
<td><code>kafka.server:type=BrokerTopicMetrics,name=BytesOutPerSec</code></td>
<td>当前broker的每秒的出口流量</td>
</tr>
<tr>
<td>Request rate</td>
<td><code>kafka.network:type=RequestMetrics,name=RequestsPerSec,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>当前broker的每秒的请求量; 根据request的不同会返回不同类型的数据</td>
</tr>
<tr>
<td>Log flush rate and time</td>
<td><code>kafka.log:type=LogFlushStats,name=LogFlushRateAndTimeMs</code></td>
<td>日志刷盘的频率和时间；其中<em>OneMinuteRate:表示一分钟内每秒钟的刷盘次数; </em>999thPercentile:99.9%的刷盘需要的时间</td>
</tr>
<tr>
<td>of under replicated partitions</td>
<td><code>kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions</code></td>
<td>ISR &lt; 备份次数的分区个数，这样的分区应该=0，如果大于0就进行报警最好;</td>
</tr>
<tr>
<td>Is controller active on broker</td>
<td><code>kafka.controller:type=KafkaController,name=ActiveControllerCount</code></td>
<td>当前集群中controller的个数,一个集群只能有一个controller</td>
</tr>
<tr>
<td>Leader election rate</td>
<td><code>kafka.controller:type=ControllerStats,name=LeaderElectionRateAndTimeMs</code></td>
<td>leader选举的频率和需要的时间；其中<em>OneMinuteRate:表示一分钟内出现选举的次数; </em>999thPercentile:99.9%的选举需要的时间</td>
</tr>
<tr>
<td>Unclean leader election rate</td>
<td><code>kafka.controller:type=ControllerStats,name=UncleanLeaderElectionsPerSec</code></td>
<td>非正常的备份被选举成leader的频率;</td>
</tr>
<tr>
<td>Partition counts</td>
<td><code>kafka.server:type=ReplicaManager,name=PartitionCount</code></td>
<td>当前broker的分区个数,就是在存储数据的目录下面的分区个数;</td>
</tr>
<tr>
<td>Leader replica counts</td>
<td><code>kafka.server:type=ReplicaManager,name=LeaderCount</code></td>
<td>当前broker中的leader分区的个数</td>
</tr>
<tr>
<td>ISR shrink rate</td>
<td><code>kafka.server:type=ReplicaManager,name=IsrShrinksPerSec</code></td>
<td>当前broker每分钟分区缩减的频率;</td>
</tr>
<tr>
<td>ISR expansion rate</td>
<td><code>kafka.server:type=ReplicaManager,name=IsrExpandsPerSec</code></td>
<td>当前broker每分钟分区扩展的频率;</td>
</tr>
<tr>
<td>Max lag in messages btw follower and leader replicas</td>
<td><code>kafka.server:type=ReplicaFetcherManager,name=MaxLag,clientId=Replica</code></td>
<td>当前broker中分区与leader之前同步的最大lag数</td>
</tr>
<tr>
<td>Lag in messages per follower replica</td>
<td><code>kafka.server:type=FetcherLagMetrics,name=ConsumerLag,clientId=([-.\w]+),topic=([-.\w]+),partition=([0-9]+)</code></td>
<td>当前broker中备本分区与leader之间的lag数</td>
</tr>
<tr>
<td>Requests waiting in the producer purgatory</td>
<td><code>kafka.server:type=DelayedOperationPurgatory,name=PurgatorySize,delayedOperation=Produce</code></td>
<td>broker中，在等待ack的producer请求个数;还有Fetch、topic、Rebalance、Heartbeat请求</td>
</tr>
<tr>
<td>Request total time</td>
<td><code>kafka.network:type=RequestMetrics,name=TotalTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>请求所需要的全部时间;根据不同的类型求个不一样的结果</td>
</tr>
<tr>
<td>Time the request waits in the request queue</td>
<td><code>kafka.network:type=RequestMetrics,name=RequestQueueTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>请求在队列中等待的时间</td>
</tr>
<tr>
<td>Time the request is processed at the leader</td>
<td><code>kafka.network:type=RequestMetrics,name=LocalTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>请求被leader节点处理的时间</td>
</tr>
<tr>
<td>Time the request waits for the follower</td>
<td><code>kafka.network:type=RequestMetrics,name=RemoteTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>一个请求等待follower的时间;假如ack=all，那么这个值就是非0</td>
</tr>
<tr>
<td>Time the request waits in the response queue</td>
<td><code>kafka.network:type=RequestMetrics,name=ResponseQueueTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>一个请求在response队列中的时间</td>
</tr>
<tr>
<td>Time to send the response</td>
<td><code>kafka.network:type=RequestMetrics,name=ResponseSendTimeMs,request={Produce or FetchConsumer or FetchFollower}</code></td>
<td>发送请求的时间</td>
</tr>
<tr>
<td>Number of messages the consumer lags behind the producer by. Published by the consumer, not broker.</td>
<td><code>Old consumer: kafka.consumer:type=ConsumerFetcherManager,name=MaxLag,clientId=([-.\w]+) New consumer: kafka.consumer:type=consumer-fetch-manager-metrics,client-id={client-id} Attribute: records-lag-max</code></td>
<td>consumer落后producer的lag</td>
</tr>
<tr>
<td>The average fraction of time the network processors are idle</td>
<td><code>kafka.network:type=SocketServer,name=NetworkProcessorAvgIdlePercent</code></td>
<td>网络处理空闲的因子，在0，1之间，通常是&gt; 0.3</td>
</tr>
<tr>
<td>The average fraction of time the request handler threads are idle</td>
<td><code>kafka.server:type=KafkaRequestHandlerPool,name=RequestHandlerAvgIdlePercent</code></td>
<td>网络请求线程空闲的平均值，在0，1之间，通常是&gt; 0.3</td>
</tr>
</tbody>
</table>
<h3 id="2-关于zookeeper相关的监控信息"><a href="#2-关于zookeeper相关的监控信息" class="headerlink" title="2. 关于zookeeper相关的监控信息"></a>2. 关于zookeeper相关的监控信息</h3><table>
<thead>
<tr>
<th>mbean name</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperDisconnectedPerSec</code></td>
<td>当前broker与zk之间的每秒断链的次数；也就是频率</td>
</tr>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperSyncConnectedPerSec</code></td>
<td>ZooKeeper client is connected to the ensemble and ready to execute operations</td>
</tr>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperAuthFailedPerSec</code></td>
<td>与zk进行连接并且是因为认证失败的每秒的次数</td>
</tr>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperConnectedReadOnlyPerSec</code></td>
<td>The server the client is connected to is currently LOOKING, which means that it is neither FOLLOWING nor LEADING. Consequently, the client can only read the ZooKeeper state, but not make any changes (create, delete, or set the data of znodes).</td>
</tr>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperSaslAuthenticatedPerSec</code></td>
<td>zkclient被验证成功每秒的次数</td>
</tr>
<tr>
<td><code>kafka.server:type=SessionExpireListener,name=ZooKeeperExpiredPerSec</code></td>
<td>当前zkclient被过期的每秒次数</td>
</tr>
</tbody>
</table>
<h3 id="3-consumer和producer的监控信息"><a href="#3-consumer和producer的监控信息" class="headerlink" title="3. consumer和producer的监控信息"></a>3. consumer和producer的监控信息</h3><ul>
<li><a href="http://docs.confluent.io/3.0.0/kafka/monitoring.html#producer-global-request-metrics" target="_blank" rel="external">confluent doc</a></li>
<li><a href="https://kafka.apache.org/documentation/#monitoring" target="_blank" rel="external">kafka doc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-broker的监控信息&quot;&gt;&lt;a href=&quot;#1-broker的监控信息&quot; class=&quot;headerlink&quot; title=&quot;1. broker的监控信息&quot;&gt;&lt;/a&gt;1. broker的监控信息&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标题
    
    </summary>
    
    
      <category term="kafka,monitor" scheme="http://yoursite.com/tags/kafka-monitor/"/>
    
  </entry>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞</title>
    <link href="http://yoursite.com/2017/03/03/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2017/03/03/同步、异步、阻塞、非阻塞/</id>
    <published>2017-03-03T09:35:52.000Z</published>
    <updated>2017-03-05T06:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>同步异步阻塞非阻塞这几个概念其实很早就出现在我的脑中，但是到现在为止都还是很难把它理解清楚，尤其是这几个概念总是会被混淆一起来讲。最近算是工作比较闲，在网上查询了大量的文章，发现一些人对这几个概念有着与众不同的解释，也正好能完美的解决我心中的疑云.</p>
<p>先引用几个别人对此的理解，我觉得他们理解的特别有理;</p>
<blockquote>
<pre><code>•    阻塞与非阻塞：区别在于完成一件事情时，当事情还没有完成时，处理这件事情的人除此之外不能再做别的事情；
•    同步与异步：是自己去做这件事情，还是等别人做好了来通知有结果，然后再自己去拿结果。注意这里说的是拿结果，如果只是别人告诉你可以做某事，然后自己去操作，这种情况下也是同步的操作;[link](http://h2ex.com/639)
</code></pre></blockquote>
<p>还有一个知乎上的回答，觉得<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">严肃回答</a>的也是特别好.</p>
<h5 id="阻塞非阻塞"><a href="#阻塞非阻塞" class="headerlink" title="阻塞非阻塞"></a>阻塞非阻塞</h5><p>是程序在等待调用的时候的状态; 说大白话就是: 程序调用了某一个接口的时候，他是否还有<strong>可能</strong>去做其他的事情, 如果有可能那就是非阻塞，如果没有可能那就是阻塞; 这里举个大家都知道的例子,比如<code>read</code>(反正大家都喜欢用这个例子):</p>
<p>这有两个角色:</p>
<pre><code>* 调用者: 调用read的线程或者进程
* 被调用者: read本身
</code></pre><p>Linux文件在open的过程可以选择(block | noblock)两种方式，而这两种方式的最大区别点在于：block模式下，调用read之后会阻塞(阻塞的原因在<a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="external">这篇文章</a>中有很详细的介绍), 就调用者在此时此刻它是会被操作系统挂起，它在此刻没有<strong>可能</strong>去做其他的事情, 这就是阻塞(<strong>没有可能性</strong>).</p>
<p>如果是在非阻塞的模式下，调用read之后会很快的返回, 这个返回有两种可能: error 或者 读到了数据; 虽然我们在使用非阻塞的时候，总是在外围加上while循环,类似于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">	read(fd, buf, count);</div><div class="line">&#125;while(errno == EWOULDBLOCK);</div></pre></td></tr></table></figure>
<p>通过这种方式去不断询问内核是否已经把数据准备好，而这个过程中，虽然大部分用法是选择不停的询问，但是这只是一种做法，调用者还是其他的更多的方式可以选择，比如调用者发现数据还没有准备好，那它可以把之前的数据排一个序什么的，这表示调用者在此刻是有选择做其他的事情的<strong>可能性</strong>的;</p>
<p>在思考阻塞和非阻塞的时候，需要先把角色分成为调用者与被调用者，这是一个很简单的一点，不要去思考被调用者内部是如何实现的，只需要在调用者与被调用者这个层面: <em>思考调用者调用的时候是否还有可能去做其他的事情为依据来进行区别</em>; 为什么要在同一个层面来看呢？因为层次不同得到的结果也不一样; 这里在举一个例子: 我封装了一个函数A，A内部的实现就是上面的实例代码，那A本身是否是阻塞呢？回答是:YES, 因为其他人在调用A时候，没有可能去做其他的事情了，这个时候它整体都在等待A的返回，所以这就是阻塞.</p>
<h5 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h5><ul>
<li>同步: 调用者为了获得结果，主动等待结果的返回(<strong>结果已经完成</strong>);</li>
<li>异步: 调用者获得的结果的方式被动通知，当接受到通知的时候就表示调用者需要的<strong>结果已经完成</strong>;</li>
</ul>
<p><code>结果已经完成</code>的定义是:调用者获得了一开始就想要的结果;</p>
<p>所以区别同步异步的关键点是在于:</p>
<ul>
<li>调用者是否主动等待</li>
<li>在被通知获得结果的时候，调用者想要获得结果是否已经完成</li>
</ul>
<p>按照上面的理论我们来分析几个调用是同步还是异步？还是分为两个角色:</p>
<ul>
<li>调用者</li>
<li>被调用者</li>
</ul>
<ol>
<li><p>read</p>
<p> 依然是上面的那个例子；当调用者调用read(被调用者)，这个时候调用者就主动在等待结果的返回，直到read返回，调用者才得到自己想要的东西; 所以是主动等待，所以这是同步操作</p>
</li>
<li><p>AIO(异步IO)</p>
<p> 应用层发起AIO操作之后，被调用者直接返回; 调用者这个时候就不在关心这个事情了; 当操作系统把数据准备好并且copy到对应的应用层内存之后，就会通过类似于事件通知的方式来通知应用程序; 这个过程中</p>
<ul>
<li>调用者是被动通知结果</li>
<li><p>调用者在收到通知的那时它想获得结果已经完成(需要读取的数据已经放在对应的应用层的内存中了)</p>
<p>所以AIO是异步的</p>
</li>
</ul>
</li>
<li><p>多路复用IO</p>
</li>
</ol>
<p>select、poll、epoll都是多路IO; 那么它们是同步还是异步呢？这可能是大部分人难以弄清楚的事情；而且很多文章本身也是没有搞清楚或者是错误的理论; 先说一个结果</p>
<blockquote>
<p>多路IO都是同步的</p>
</blockquote>
<p>下面分析一下原因:</p>
<p>通过多路IO本身是通过将读写事件注册到统一的地方，有内核通过某一种方式(select、poll、epoll的实现方式都不一样)来统一的做轮训，这样的好处就是一个线程管理多个连接; 如果不是这样的话每一个链接都需要阻塞，非常浪费资源; 但是从异步的两个关键点来说:</p>
<ul>
<li>多路IO是通知调用者的</li>
<li>多路IO在通知的时候，只是告诉你可以读写了，但没有真正的读写操作完成，还是需要调用者自己去完成读写操作;</li>
</ul>
<p>所以多路IO是同步,而非异步;</p>
<p>和阻塞非阻塞一样，同步与异步的也是有层次的划分的；就目前操作系统来说，真正的异步io就只有AIO，其他的IO都是同步IO，原因是不管怎么样从内核到应用层的内存copy都需要调用者自己也操作，所以都是同步io；但是如果将异步同步这个概念放宽一些，从不同层次上来思考的话，我们发现现在很多市面上的网络框架都能达到异步的一个概念；比如seastar、folly的future，node.js等，这些框架可能在实现上都不一样但是不管怎么样，在概念上都已经是异步了.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>个人感觉(对自己而言)思考的已经很清楚了；异步同步、阻塞非阻塞，虽然相关但是其实关注的维度是不一样的，所以谈论的过程中不要尝试混淆.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步异步阻塞非阻塞这几个概念其实很早就出现在我的脑中，但是到现在为止都还是很难把它理解清楚，尤其是这几个概念总是会被混淆一起来讲。最近算是工作比较闲，在网上查询了大量的文章，发现一些人对这几个概念有着与众不同的解释，也正好能完美的解决我心中的疑云.&lt;/p&gt;
&lt;p&gt;先引用几个
    
    </summary>
    
    
  </entry>
  
</feed>
