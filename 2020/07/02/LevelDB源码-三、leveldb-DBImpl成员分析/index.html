<!doctype html>
<html lang="en">
    <head><meta name="generator" content="Hexo 3.9.0">
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content>
        <link rel="shortcut icon" href="/asset/guolin.png">
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="nomoshen" href="/atom.xml">
        <title>LevelDB源码(三、leveldb DBImpl成员分析) | nomoshen</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    </head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/asset/guolin.png" alt="nomoshen"></a>
            <h1><a href="/">nomoshen</a></h1>
            <p>尽可能努力一点点</p>
            <div id="follow-icons">
                  <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  July 2, 2020
  
    <span class="taglist">  &middot; 
    
    
      <a href="/tags/leveldb/">leveldb</a> 
    
    </span>
  

  <h1 class="post-title">LevelDB源码(三、leveldb DBImpl成员分析)</h1>
  <section class="post-content article-entry">
    <p>系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤其在于Leveldb在被打开瞬间，数据如何恢复特别的重要.</p>
<h4 id="1-DBImpl类的数据成员"><a href="#1-DBImpl类的数据成员" class="headerlink" title="1. DBImpl类的数据成员"></a>1. DBImpl类的数据成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> DBImpl: <span class="keyword">public</span> DB &#123;</span><br><span class="line">  <span class="comment">//指定环境的工具类，比如文件操作之类的</span></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator internal_comparator_;</span><br><span class="line">  <span class="keyword">const</span> InternalFilterPolicy internal_filter_policy_;</span><br><span class="line">  <span class="keyword">const</span> Options options_;  <span class="comment">// options_.comparator == &amp;internal_comparator_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否是自己管理infolog和blockcache,通常都是leveldb自己去管理，而非调用者来传入</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_info_log_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_cache_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// table_cache_ provides its own synchronization</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提供对于leveldb的文件信息的管理，所以它的大小为最大打开文件个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock over the persistent DB state.  Non-null iff successfully acquired.</span></span><br><span class="line">  FileLock* db_lock_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State below is protected by mutex_</span></span><br><span class="line">  port::Mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; shutting_down_;</span><br><span class="line">  port::<span class="function">CondVar background_work_finished_signal_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; has_imm_;         <span class="comment">// So bg thread can detect non-null imm_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//WAL的文件，logFiles用在后面的log_上面</span></span><br><span class="line">  WritableFile* logfile_;</span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="function">logfile_number_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 感觉是WAL的类,用来存储put的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">log</span>::Writer* log_;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="function">seed_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// For sampling.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue of writers.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  leveldb是结合多个写入然后才操作memtable + wal；而这个对象就是WriteBatch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SnapshotList snapshots_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line">  <span class="comment">// part of ongoing compactions.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; <span class="function">pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Has a background compaction been scheduled or is running?</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> background_compaction_scheduled_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ManualCompaction* manual_compaction_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">VersionSet* <span class="keyword">const</span> versions_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Have we encountered a background error in paranoid mode?</span></span><br><span class="line">  <span class="function">Status bg_error_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只是展示了数据成员，没有写成员函数;想看具体在<code>db_impl.h</code>文件中;下面就具体分析这些数据成员：</p>
<ul>
<li>env_: 内部封装了一些与os相关的操作，主要是读写、生成文件之类的; 默认以default为主</li>
<li>internal_comparator_: 内部字符串的对比方式;默认字节序列比较</li>
<li>internal_filter_policy_: 默认是bloom过滤器，本身是为了减少对磁盘操作而产生的过滤器</li>
<li>options_：本系列的第二篇文章讲了关于db option的细节，大部分使用默认值，如果用户想修改的话，就需要在打开db的时候就赋值</li>
</ul>
<hr>
<ul>
<li>owns_info_log_: 是否使用的是内部自己的打日志的文件，如果是自己的话，需要在最后自己释放掉</li>
<li>owns_cache_：是否自己提供了blockcache的方式，默认是用了LRU的方式来实现这个</li>
<li>dbname_: leveldb的路径</li>
<li>table_cache_: 主要是一些经常打开的sstable的文件缓存，如果经常访问就不需要经常去open;也是使用了LRU的方式进行管理</li>
<li>db_lock_： 文件锁，其实也不是真的文件锁，只不过用一个文件来保存这个状态，方式两次打开相同的db;</li>
</ul>
<hr>
<ul>
<li>mutex_: 用于保护一些关键变量的线程安全</li>
<li>shutting_down_： 是否正在关闭</li>
<li>background_work_finished_signal_: 条件变量，用来通知背后工作线程已经运行关闭，到时候会进行通知;</li>
</ul>
<hr>
<ul>
<li>mem_: memtable; </li>
<li>imm_：不可变的memtable</li>
<li>has_imm_：是否有不可变的memtable</li>
</ul>
<hr>
<ul>
<li>logfile_: wal对应的文件</li>
<li>logfile_number: 表示当前的wal的文件名；在leveldb中文件名通常都是编号；leveldb通过增量的方式来保证唯一性；这样不需要保存文件名;</li>
<li>log_: 对logfile_的封装，可以读写操作</li>
<li>seed_： 看了后期使用的过程，主要是为了后期的随机数使用,可能是为了更加随机一些吧</li>
<li>writers_: deque的队列，是用来存放写操作的双端队列; 通过上面的mutex_来保证线程安全；通过用户调用put之后，会将写操作放到这里面; 后面有线程进行批量的写入;</li>
<li>tmp_batch_: writeBatch类型，用来做批量写入的时候使用，不过为什么需要一个这个成员变量，需要后面看到再来解答; TODO</li>
<li>snapshots_: 维持目前db返回给外界的snapshot的一个list;是一个双向链表</li>
<li>pending_outputs_: 看注解应该是一些被保护防止被删除的文件;  TODO</li>
<li>background_compaction_scheduled_： 是否开启自动compaction的调度worker</li>
<li>manual_compaction_： 记录当前db手动compaction的信息，主要起到管理作用</li>
<li>versions_: 版本管理器; 这是一个常量指针，也就是被赋值之后不能被修改，但是可以修改内容</li>
<li>bg_error_： 与option中的<code>paranoid mode</code>一起使用</li>
<li>stats_: leveldb多层结构中，每层的compaction的状态</li>
</ul>
<p>默认构造函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::DBImpl(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span><br><span class="line">    : env_(raw_options.env),</span><br><span class="line">      internal_comparator_(raw_options.comparator),</span><br><span class="line">      internal_filter_policy_(raw_options.filter_policy),</span><br><span class="line">      options_(SanitizeOptions(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      owns_info_log_(options_.info_log != raw_options.info_log),</span><br><span class="line">      owns_cache_(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      table_cache_(<span class="keyword">new</span> TableCache(dbname_, options_, TableCacheSize(options_))),</span><br><span class="line">      db_lock_(<span class="literal">nullptr</span>),</span><br><span class="line">      shutting_down_(<span class="literal">false</span>),</span><br><span class="line">      background_work_finished_signal_(&amp;mutex_),</span><br><span class="line">      mem_(<span class="literal">nullptr</span>),</span><br><span class="line">      imm_(<span class="literal">nullptr</span>),</span><br><span class="line">      has_imm_(<span class="literal">false</span>),</span><br><span class="line">      logfile_(<span class="literal">nullptr</span>),</span><br><span class="line">      logfile_number_(<span class="number">0</span>),</span><br><span class="line">      log_(<span class="literal">nullptr</span>),</span><br><span class="line">      seed_(<span class="number">0</span>),</span><br><span class="line">      tmp_batch_(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      background_compaction_scheduled_(<span class="literal">false</span>),</span><br><span class="line">      manual_compaction_(<span class="literal">nullptr</span>),</span><br><span class="line">      versions_(<span class="keyword">new</span> VersionSet(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化之后都是默认值，但是在<code>DB:open</code>函数调用之后都会从文件中恢复出之前持久化的数值;</p>
<h4 id="2-VersionSet，Leveldb的版本管理"><a href="#2-VersionSet，Leveldb的版本管理" class="headerlink" title="2. VersionSet，Leveldb的版本管理"></a>2. VersionSet，Leveldb的版本管理</h4><p>所谓版本管理，主要指的是Leveldb去管理sstable、wal、manifest等一些本地的文件；而这些文件会随着compaction的操作而变化，所以需要有版本管理器来管理这些;</p>
<p>在网上看到一<a href="https://sf-zhou.github.io/leveldb/leveldb_07_version.html" target="_blank" rel="noopener">文章</a>,里面有一个比喻会比较形象来描述这些概念:</p>
<ul>
<li>VersionEdit: 类似于git的一个commit，记录了本次的变化</li>
<li>Version: 表示git当前的版本；就是git log中展示的那个唯一id; 通常上一个version + VersionEdit = 当前的version</li>
<li>VersionSet: 初始version，以及之后的所有的VersionEdit，这个方式可以推演出所有的之后版本;</li>
</ul>
<h5 id="FileMetaData对象"><a href="#FileMetaData对象" class="headerlink" title="FileMetaData对象"></a>FileMetaData对象</h5><p>FileMetaData是用来管理sstatble的状态的;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FileMetaData &#123;</span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * refs: 当前sstable被引用的次数，如果次数=0的时候，就表示可以删除</span></span><br><span class="line"><span class="comment">   * allowed_seek: 查好次数,估计会通过这个来进行判断是否要compaction</span></span><br><span class="line"><span class="comment">   * number: 文件编号，通过编号找到文件</span></span><br><span class="line"><span class="comment">   * filesize: 文件size</span></span><br><span class="line"><span class="comment">   * smallest: 最小key的</span></span><br><span class="line"><span class="comment">   * largest: 最大key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key: level</span></span><br><span class="line"><span class="comment"> * value: 内部key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line"><span class="comment">//需要被删除的文件</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="comment">// 新增的文件</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure>
<ul>
<li>comparator_: 压缩方式</li>
<li>log_number_: 这次的变更对应的wal的文件ID</li>
<li>prev_log_number_： 上一个wal的文件ID</li>
<li>next_file_number_: 下一个sstable文件的id</li>
<li>last_sequence_： 最大的版本id是什么</li>
<li>compact_pointers_： 每一层level对应的compaction指针，目前还不清楚有什么用</li>
<li>deleted_files_: 本次更新需要被删除的文件</li>
<li>new_files_: 本次更新新增的文件</li>
</ul>
<p>对VersionEdit的理解，可以想个例子: memtable在被写入到sstable的时候，就会产生一个问题；这个时候这次的更新可以比较简单的认为是新增的一个sstable，这个时候的VersionEdit估计就是;</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"comparator_"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"log_number_"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"prev_log_number_"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"next_file_number_"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">"last_sequence_"</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">"new_files_"</span>: [<span class="string">"xxx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要保存wal的id呢，我觉得主要是在启动恢复的时候需要去知道当前哪些wal是需要被恢复的，至于为什么是要保存两个id呢？我看了后面再来记录TODO</p>
<h5 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Version &#123;</span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vset_: 当前version属于那个VersionSet</li>
<li>next_, prev_: 双向链表，指向上一个或者下一个的version</li>
<li>refs_：version是否被引用</li>
<li>files_： 当前这个version，每一个层关联的文件，估计排序的</li>
<li>file_to_compact_： 当前有哪些可能需要被compaction</li>
<li>file_to_compact_level_: 对应的层数</li>
<li>compaction_score_：TODO</li>
<li>compaction_level_：TODO</li>
</ul>
<p>从数据结构来说，Version包含了当前这个版本整体的文件结构，比如每次包含了哪些文件，哪些文件就可能需要进行compaction之类的; 上下版本的list;</p>
<h5 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> VersionSet &#123;</span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>env_: 同上</li>
<li>dbname_: leveldb路径</li>
<li>options_： 同上dbimpl_</li>
<li>icmp_: 同上</li>
<li>next_file_number_: 下一个文件id; 这个文件可能指sstable，目前还不确定</li>
<li>manifest_file_number_: manifest文件的ID</li>
<li>last_sequence_：最大序列号</li>
<li>log_number_： wal文件id</li>
<li>prev_log_number_： 同上</li>
<li>dummy_versions_: version双向链表的头</li>
<li>current_: dummy_versions_.prev_，表示当前version</li>
<li>compact_pointer_：TODO 未知</li>
</ul>
<p>构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),</span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">//提供的时候VersionSet就只有一个;</span></span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next_file_number_: 为什么初始化是2？？TODO</li>
</ul>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>nomoshen</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2020/07/06/LevelDB源码-四、leveldb-open流程/">
        ← prev <!--LevelDB源码(四、leveldb open流程)-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2020/06/28/LevelDB源码-二、leveldb-option分析/">
        <!--LevelDB源码(二、leveldb option分析)--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2020 nomoshen. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


