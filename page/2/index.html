<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="english">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="nomoshen" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="nomoshen">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="nomoshen">
<meta property="og:locale" content="english">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nomoshen">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>nomoshen</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="english">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nomoshen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">尽可能努力一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/02/LevelDB源码-三、leveldb-DBImpl成员分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/02/LevelDB源码-三、leveldb-DBImpl成员分析/" itemprop="url">LevelDB源码(三、leveldb DBImpl成员分析)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-02T22:36:07+08:00">
                2020-07-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-07-06T14:44:51+08:00">
                2020-07-06
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系列第三章，主要分析核心DBImpl的数据成员的含义, 并且会包含讲到Version、VersionSet、VersionEdit这几个版本管理的核心大类；为什么先讲这些呢？因为我在看后面的读写流程的时候，发现如果事先把这些定义都能理解清楚了，对流程上的关键点会更加清晰；尤其在于Leveldb在被打开瞬间，数据如何恢复特别的重要.</p>
<h4 id="1-DBImpl类的数据成员"><a href="#1-DBImpl类的数据成员" class="headerlink" title="1. DBImpl类的数据成员"></a>1. DBImpl类的数据成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> DBImpl: <span class="keyword">public</span> DB &#123;</span><br><span class="line">  <span class="comment">//指定环境的工具类，比如文件操作之类的</span></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator internal_comparator_;</span><br><span class="line">  <span class="keyword">const</span> InternalFilterPolicy internal_filter_policy_;</span><br><span class="line">  <span class="keyword">const</span> Options options_;  <span class="comment">// options_.comparator == &amp;internal_comparator_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否是自己管理infolog和blockcache,通常都是leveldb自己去管理，而非调用者来传入</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_info_log_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> owns_cache_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// table_cache_ provides its own synchronization</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提供对于leveldb的文件信息的管理，所以它的大小为最大打开文件个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lock over the persistent DB state.  Non-null iff successfully acquired.</span></span><br><span class="line">  FileLock* db_lock_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// State below is protected by mutex_</span></span><br><span class="line">  port::Mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; shutting_down_;</span><br><span class="line">  port::<span class="function">CondVar background_work_finished_signal_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; has_imm_;         <span class="comment">// So bg thread can detect non-null imm_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//WAL的文件，logFiles用在后面的log_上面</span></span><br><span class="line">  WritableFile* logfile_;</span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="function">logfile_number_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 感觉是WAL的类,用来存储put的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">log</span>::Writer* log_;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="function">seed_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// For sampling.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue of writers.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  leveldb是结合多个写入然后才操作memtable + wal；而这个对象就是WriteBatch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SnapshotList snapshots_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line">  <span class="comment">// part of ongoing compactions.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; <span class="function">pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Has a background compaction been scheduled or is running?</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> background_compaction_scheduled_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ManualCompaction* manual_compaction_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">VersionSet* <span class="keyword">const</span> versions_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Have we encountered a background error in paranoid mode?</span></span><br><span class="line">  <span class="function">Status bg_error_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只是展示了数据成员，没有写成员函数;想看具体在<code>db_impl.h</code>文件中;下面就具体分析这些数据成员：</p>
<ul>
<li>env_: 内部封装了一些与os相关的操作，主要是读写、生成文件之类的; 默认以default为主</li>
<li>internal_comparator_: 内部字符串的对比方式;默认字节序列比较</li>
<li>internal_filter_policy_: 默认是bloom过滤器，本身是为了减少对磁盘操作而产生的过滤器</li>
<li>options_：本系列的第二篇文章讲了关于db option的细节，大部分使用默认值，如果用户想修改的话，就需要在打开db的时候就赋值</li>
</ul>
<hr>
<ul>
<li>owns_info_log_: 是否使用的是内部自己的打日志的文件，如果是自己的话，需要在最后自己释放掉</li>
<li>owns_cache_：是否自己提供了blockcache的方式，默认是用了LRU的方式来实现这个</li>
<li>dbname_: leveldb的路径</li>
<li>table_cache_: 主要是一些经常打开的sstable的文件缓存，如果经常访问就不需要经常去open;也是使用了LRU的方式进行管理</li>
<li>db_lock_： 文件锁，其实也不是真的文件锁，只不过用一个文件来保存这个状态，方式两次打开相同的db;</li>
</ul>
<hr>
<ul>
<li>mutex_: 用于保护一些关键变量的线程安全</li>
<li>shutting_down_： 是否正在关闭</li>
<li>background_work_finished_signal_: 条件变量，用来通知背后工作线程已经运行关闭，到时候会进行通知;</li>
</ul>
<hr>
<ul>
<li>mem_: memtable; </li>
<li>imm_：不可变的memtable</li>
<li>has_imm_：是否有不可变的memtable</li>
</ul>
<hr>
<ul>
<li>logfile_: wal对应的文件</li>
<li>logfile_number: 表示当前的wal的文件名；在leveldb中文件名通常都是编号；leveldb通过增量的方式来保证唯一性；这样不需要保存文件名;</li>
<li>log_: 对logfile_的封装，可以读写操作</li>
<li>seed_： 看了后期使用的过程，主要是为了后期的随机数使用,可能是为了更加随机一些吧</li>
<li>writers_: deque的队列，是用来存放写操作的双端队列; 通过上面的mutex_来保证线程安全；通过用户调用put之后，会将写操作放到这里面; 后面有线程进行批量的写入;</li>
<li>tmp_batch_: writeBatch类型，用来做批量写入的时候使用，不过为什么需要一个这个成员变量，需要后面看到再来解答; TODO</li>
<li>snapshots_: 维持目前db返回给外界的snapshot的一个list;是一个双向链表</li>
<li>pending_outputs_: 看注解应该是一些被保护防止被删除的文件;  TODO</li>
<li>background_compaction_scheduled_： 是否开启自动compaction的调度worker</li>
<li>manual_compaction_： 记录当前db手动compaction的信息，主要起到管理作用</li>
<li>versions_: 版本管理器; 这是一个常量指针，也就是被赋值之后不能被修改，但是可以修改内容</li>
<li>bg_error_： 与option中的<code>paranoid mode</code>一起使用</li>
<li>stats_: leveldb多层结构中，每层的compaction的状态</li>
</ul>
<p>默认构造函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::DBImpl(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span><br><span class="line">    : env_(raw_options.env),</span><br><span class="line">      internal_comparator_(raw_options.comparator),</span><br><span class="line">      internal_filter_policy_(raw_options.filter_policy),</span><br><span class="line">      options_(SanitizeOptions(dbname, &amp;internal_comparator_,</span><br><span class="line">                               &amp;internal_filter_policy_, raw_options)),</span><br><span class="line">      owns_info_log_(options_.info_log != raw_options.info_log),</span><br><span class="line">      owns_cache_(options_.block_cache != raw_options.block_cache),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      table_cache_(<span class="keyword">new</span> TableCache(dbname_, options_, TableCacheSize(options_))),</span><br><span class="line">      db_lock_(<span class="literal">nullptr</span>),</span><br><span class="line">      shutting_down_(<span class="literal">false</span>),</span><br><span class="line">      background_work_finished_signal_(&amp;mutex_),</span><br><span class="line">      mem_(<span class="literal">nullptr</span>),</span><br><span class="line">      imm_(<span class="literal">nullptr</span>),</span><br><span class="line">      has_imm_(<span class="literal">false</span>),</span><br><span class="line">      logfile_(<span class="literal">nullptr</span>),</span><br><span class="line">      logfile_number_(<span class="number">0</span>),</span><br><span class="line">      log_(<span class="literal">nullptr</span>),</span><br><span class="line">      seed_(<span class="number">0</span>),</span><br><span class="line">      tmp_batch_(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">      background_compaction_scheduled_(<span class="literal">false</span>),</span><br><span class="line">      manual_compaction_(<span class="literal">nullptr</span>),</span><br><span class="line">      versions_(<span class="keyword">new</span> VersionSet(dbname_, &amp;options_, table_cache_,</span><br><span class="line">                               &amp;internal_comparator_)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化之后都是默认值，但是在<code>DB:open</code>函数调用之后都会从文件中恢复出之前持久化的数值;</p>
<h4 id="2-VersionSet，Leveldb的版本管理"><a href="#2-VersionSet，Leveldb的版本管理" class="headerlink" title="2. VersionSet，Leveldb的版本管理"></a>2. VersionSet，Leveldb的版本管理</h4><p>所谓版本管理，主要指的是Leveldb去管理sstable、wal、manifest等一些本地的文件；而这些文件会随着compaction的操作而变化，所以需要有版本管理器来管理这些;</p>
<p>在网上看到一<a href="https://sf-zhou.github.io/leveldb/leveldb_07_version.html" target="_blank" rel="noopener">文章</a>,里面有一个比喻会比较形象来描述这些概念:</p>
<ul>
<li>VersionEdit: 类似于git的一个commit，记录了本次的变化</li>
<li>Version: 表示git当前的版本；就是git log中展示的那个唯一id; 通常上一个version + VersionEdit = 当前的version</li>
<li>VersionSet: 初始version，以及之后的所有的VersionEdit，这个方式可以推演出所有的之后版本;</li>
</ul>
<h5 id="FileMetaData对象"><a href="#FileMetaData对象" class="headerlink" title="FileMetaData对象"></a>FileMetaData对象</h5><p>FileMetaData是用来管理sstatble的状态的;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FileMetaData &#123;</span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * refs: 当前sstable被引用的次数，如果次数=0的时候，就表示可以删除</span></span><br><span class="line"><span class="comment">   * allowed_seek: 查好次数,估计会通过这个来进行判断是否要compaction</span></span><br><span class="line"><span class="comment">   * number: 文件编号，通过编号找到文件</span></span><br><span class="line"><span class="comment">   * filesize: 文件size</span></span><br><span class="line"><span class="comment">   * smallest: 最小key的</span></span><br><span class="line"><span class="comment">   * largest: 最大key</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key: level</span></span><br><span class="line"><span class="comment"> * value: 内部key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line"><span class="comment">//需要被删除的文件</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="comment">// 新增的文件</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure>
<ul>
<li>comparator_: 压缩方式</li>
<li>log_number_: 这次的变更对应的wal的文件ID</li>
<li>prev_log_number_： 上一个wal的文件ID</li>
<li>next_file_number_: 下一个sstable文件的id</li>
<li>last_sequence_： 最大的版本id是什么</li>
<li>compact_pointers_： 每一层level对应的compaction指针，目前还不清楚有什么用</li>
<li>deleted_files_: 本次更新需要被删除的文件</li>
<li>new_files_: 本次更新新增的文件</li>
</ul>
<p>对VersionEdit的理解，可以想个例子: memtable在被写入到sstable的时候，就会产生一个问题；这个时候这次的更新可以比较简单的认为是新增的一个sstable，这个时候的VersionEdit估计就是;</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"comparator_"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="attr">"log_number_"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">"prev_log_number_"</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">"next_file_number_"</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">"last_sequence_"</span>: <span class="number">1000</span>,</span><br><span class="line"><span class="attr">"new_files_"</span>: [<span class="string">"xxx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要保存wal的id呢，我觉得主要是在启动恢复的时候需要去知道当前哪些wal是需要被恢复的，至于为什么是要保存两个id呢？我看了后面再来记录TODO</p>
<h5 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Version &#123;</span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vset_: 当前version属于那个VersionSet</li>
<li>next_, prev_: 双向链表，指向上一个或者下一个的version</li>
<li>refs_：version是否被引用</li>
<li>files_： 当前这个version，每一个层关联的文件，估计排序的</li>
<li>file_to_compact_： 当前有哪些可能需要被compaction</li>
<li>file_to_compact_level_: 对应的层数</li>
<li>compaction_score_：TODO</li>
<li>compaction_level_：TODO</li>
</ul>
<p>从数据结构来说，Version包含了当前这个版本整体的文件结构，比如每次包含了哪些文件，哪些文件就可能需要进行compaction之类的; 上下版本的list;</p>
<h5 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> VersionSet &#123;</span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>env_: 同上</li>
<li>dbname_: leveldb路径</li>
<li>options_： 同上dbimpl_</li>
<li>icmp_: 同上</li>
<li>next_file_number_: 下一个文件id; 这个文件可能指sstable，目前还不确定</li>
<li>manifest_file_number_: manifest文件的ID</li>
<li>last_sequence_：最大序列号</li>
<li>log_number_： wal文件id</li>
<li>prev_log_number_： 同上</li>
<li>dummy_versions_: version双向链表的头</li>
<li>current_: dummy_versions_.prev_，表示当前version</li>
<li>compact_pointer_：TODO 未知</li>
</ul>
<p>构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),</span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">//提供的时候VersionSet就只有一个;</span></span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>next_file_number_: 为什么初始化是2？？TODO</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/28/LevelDB源码-二、leveldb-option分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/28/LevelDB源码-二、leveldb-option分析/" itemprop="url">LevelDB源码(二、leveldb option分析)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-28T23:35:23+08:00">
                2020-06-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-06-29T00:59:10+08:00">
                2020-06-29
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本系列的第二篇文章主要是针对leveldb的option的参数进行介绍，option的参数其实不多，但是相对很重要，因为可以让用户进行自定义的一些操作; 了解清楚这些参数的含义就可以更加好的使用leveldb;</p>
<h3 id="1-option"><a href="#1-option" class="headerlink" title="1. option"></a>1. option</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT Options &#123;</span><br><span class="line">  <span class="comment">// Create an Options object with default values for all fields.</span></span><br><span class="line">  Options();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义比较器，默认使用字节序的方式进行排序比较</span></span><br><span class="line">  <span class="keyword">const</span> Comparator* comparator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如leveldb对应的目录不存在就创建 </span></span><br><span class="line">  <span class="keyword">bool</span> create_if_missing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假如对应的目录存在的时候就报错</span></span><br><span class="line">  <span class="keyword">bool</span> error_if_exists = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the implementation will do aggressive checking of the</span></span><br><span class="line">  <span class="comment">// data it is processing and will stop early if it detects any</span></span><br><span class="line">  <span class="comment">// errors.  This may have unforeseen ramifications: for example, a</span></span><br><span class="line">  <span class="comment">// corruption of one DB entry may cause a large number of entries to</span></span><br><span class="line">  <span class="comment">// become unreadable or for the entire DB to become unopenable.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在打开leveldb的时候是否检测db，如果有数据损坏的话就直接报错；但是通常默认false；因为大部分情况下即使数据损坏也可以用;</span></span><br><span class="line">  <span class="keyword">bool</span> paranoid_checks = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 默认Env::default(), Env封装的是操作系统相关的操作;</span></span><br><span class="line">  Env* env;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//leveldb自己的日志文件对象，用来记录leveldb本身在处理过程中的信息</span></span><br><span class="line">  Logger* info_log = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * memetable的大小;默认4MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">size_t</span> write_buffer_size = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * db能最大打开文件的个数;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> max_open_files = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Control over blocks (user data is stored in a set of blocks, and</span></span><br><span class="line">  <span class="comment">// a block is the unit of reading from disk).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If non-null, use the specified cache for blocks.</span></span><br><span class="line">  <span class="comment">// If null, leveldb will automatically create and use an 8MB internal cache.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * block缓存，如果为null，使用的是leveldb自己的lRU的缓存，默认8MB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Cache* block_cache = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认block的大小为4KB,真实数据为4KB，非压缩数据</span></span><br><span class="line">  <span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类似与时间戳的压缩算法一下，通过保存一个完整的时间戳，后面的时间戳用偏移量来存储，这样的好处就可以压缩空间</span></span><br><span class="line"><span class="comment">   * 问题在于如果数据损毁的话会损失很多数据，所以会每n隔时间戳重新记录一个完整时间戳，这样即使数据顺坏也不会丢失</span></span><br><span class="line"><span class="comment">   * 很多数据；，这个参数是key前缀压缩的方式;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> block_restart_interval = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sstable的大小为2M,除了0层是4M，其他的level都是2M的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compress blocks using the specified compression algorithm.  This</span></span><br><span class="line">  <span class="comment">// parameter can be changed dynamically.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Default: kSnappyCompression, which gives lightweight but fast</span></span><br><span class="line">  <span class="comment">// compression.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:</span></span><br><span class="line">  <span class="comment">//    ~200-500MB/s compression</span></span><br><span class="line">  <span class="comment">//    ~400-800MB/s decompression</span></span><br><span class="line">  <span class="comment">// Note that these speeds are significantly faster than most</span></span><br><span class="line">  <span class="comment">// persistent storage speeds, and therefore it is typically never</span></span><br><span class="line">  <span class="comment">// worth switching to kNoCompression.  Even if the input data is</span></span><br><span class="line">  <span class="comment">// incompressible, the kSnappyCompression implementation will</span></span><br><span class="line">  <span class="comment">// efficiently detect that and will switch to uncompressed mode.</span></span><br><span class="line">  CompressionType compression = kSnappyCompression;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过判断来发现manifest是否可以重用之前的；还不确定？？</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">bool</span> reuse_logs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置一个过滤器能用来减少磁盘的访问次数，默认用bloomfilter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* filter_policy = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-ReadOptions"><a href="#2-ReadOptions" class="headerlink" title="2. ReadOptions"></a>2. ReadOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Options that control read operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT ReadOptions &#123;</span><br><span class="line">  ReadOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, all data read from underlying storage will be</span></span><br><span class="line">  <span class="comment">// verified against corresponding checksums.</span></span><br><span class="line">  <span class="comment">//是否对结果进行checksum检查</span></span><br><span class="line">  <span class="keyword">bool</span> verify_checksums = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Should the data read for this iteration be cached in memory?</span></span><br><span class="line">  <span class="comment">// Callers may wish to set this field to false for bulk scans.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否将读出来数据缓存在内存里，如果你读很大的数据的时候，希望它不污染cache的话，可以设置false</span></span><br><span class="line">  <span class="keyword">bool</span> fill_cache = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If "snapshot" is non-null, read as of the supplied snapshot</span></span><br><span class="line">  <span class="comment">// (which must belong to the DB that is being read and which must</span></span><br><span class="line">  <span class="comment">// not have been released).  If "snapshot" is null, use an implicit</span></span><br><span class="line">  <span class="comment">// snapshot of the state at the beginning of this read operation.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对于db的getSnapshot的函数返回的对象，可以读指定snapshot的数据，如果为null，就读当前读操作最新的snapshot的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> Snapshot* snapshot = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-WriteOptions"><a href="#3-WriteOptions" class="headerlink" title="3. WriteOptions"></a>3. WriteOptions</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Options that control write operations</span></span><br><span class="line"><span class="keyword">struct</span> LEVELDB_EXPORT WriteOptions &#123;</span><br><span class="line">  WriteOptions() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If true, the write will be flushed from the operating system</span></span><br><span class="line">  <span class="comment">// buffer cache (by calling WritableFile::Sync()) before the write</span></span><br><span class="line">  <span class="comment">// is considered complete.  If this flag is true, writes will be</span></span><br><span class="line">  <span class="comment">// slower.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If this flag is false, and the machine crashes, some recent</span></span><br><span class="line">  <span class="comment">// writes may be lost.  Note that if it is just the process that</span></span><br><span class="line">  <span class="comment">// crashes (i.e., the machine does not reboot), no writes will be</span></span><br><span class="line">  <span class="comment">// lost even if sync==false.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In other words, a DB write with sync==false has similar</span></span><br><span class="line">  <span class="comment">// crash semantics as the "write()" system call.  A DB write</span></span><br><span class="line">  <span class="comment">// with sync==true has similar crash semantics to a "write()"</span></span><br><span class="line">  <span class="comment">// system call followed by "fsync()".</span></span><br><span class="line">  <span class="comment">//性能考虑，不会设置true</span></span><br><span class="line">  <span class="keyword">bool</span> sync = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/leveldb源码分析-db接口分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/27/leveldb源码分析-db接口分析/" itemprop="url">LevelDB源码(一、leveldb接口分析)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-27T23:28:31+08:00">
                2020-06-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-06-28T23:16:08+08:00">
                2020-06-28
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本系列文章主要是针对leveldb的源码分析; 个人也是重温这份源码，希望能在重新看的过程中学习到更多的知识;</p>
<h3 id="1-基本接口"><a href="#1-基本接口" class="headerlink" title="1. 基本接口"></a>1. 基本接口</h3><p><a href="https://github.com/google/leveldb/blob/master/include/leveldb/db.h" target="_blank" rel="noopener">db.h</a>这个头文件几乎包含了所有leveldb提供的所有功能；这套接口是标准的存储引擎的接口，接口非常简洁，主要提供了修改、删除、读取的三大基本功能；其他的接口主要是一些附带的功能;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/**</span><br><span class="line"> * 打开leveldb,</span><br><span class="line"> * @param options: 打开leveldb的一些参数</span><br><span class="line"> * @param name: 路径</span><br><span class="line"> * @param dbptr: 返回值,如果成功打开就会在这个参数中返回;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">static Status Open(const Options&amp; options, const std::string&amp; name,</span><br><span class="line">                   DB** dbptr);</span><br><span class="line"></span><br><span class="line">DB() = default;</span><br><span class="line"></span><br><span class="line">//db不能被copy或者赋值</span><br><span class="line">DB(const DB&amp;) = delete;</span><br><span class="line">DB&amp; operator=(const DB&amp;) = delete;</span><br><span class="line"></span><br><span class="line">virtual ~DB();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将key和value存储到db里面；</span><br><span class="line"> * @param options ： 写参数设置，默认可以空对象</span><br><span class="line"> * @param key </span><br><span class="line"> * @param value </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Put(const WriteOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   const Slice&amp; value) = 0;</span><br><span class="line"> </span><br><span class="line">//删除key</span><br><span class="line">virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line"> * 批量写的接口; </span><br><span class="line"> * @param options: 同Put接口 </span><br><span class="line"> * @param updates : 批量参数，里面可以包含有写、delete的操作; </span><br><span class="line"> * @return </span><br><span class="line"> */</span><br><span class="line">virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;</span><br><span class="line"></span><br><span class="line">//查询接口，指定key,返回结果在value中；状态看Status，如果为ok的话，value就是取到的值;</span><br><span class="line">virtual Status Get(const ReadOptions&amp; options, const Slice&amp; key,</span><br><span class="line">                   std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个iterator，这个需要调用者自己去清理掉的,</span><br><span class="line"> * 返回的iterator通常是无效的，需要在调用seek之后才有效</span><br><span class="line"> * @param options</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;</span><br></pre></td></tr></table></figure>
<p>上面这些接口机会是最为常用的接口,提供了打开db、读key、存储key的功能；存储引擎的功能就在于：</p>
<ul>
<li>存储数据</li>
<li>读取数据</li>
</ul>
<p>关于<code>NewIterator</code>接口需要注意的在于返回是一个指针类型的<code>Iterator*</code>,这个指针内存释放需要调用者来执行的，所以如果每次调用之后不调用delete的话，会出现内存泄露; 这是我第一次注意到这个问题，我发现自己在其他的代码中几乎都没有显示的delete的; 用shared_ptr来封装掉这个过程,这样就不需要手动去delete这个指针;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Iterator&gt; tmp = new std::shared_ptr&lt;Iterator&gt;(db-&gt;NewIterator(options), [](void* raw)&#123;</span><br><span class="line">  if (raw != nullptr) &#123;</span><br><span class="line">    delete static_cast&lt;Iterator*&gt;(raw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">tmp-&gt;SeekToFirst();</span><br></pre></td></tr></table></figure>
<h3 id="2-附加接口"><a href="#2-附加接口" class="headerlink" title="2. 附加接口"></a>2. 附加接口</h3><p>附加接口主要是一些其他功能的介绍；比如快照、如何获得leveldb的监控信息等等;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获得快照; 需要调用者负责清理;</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual const Snapshot* GetSnapshot() = 0;</span><br><span class="line"></span><br><span class="line">// Release a previously acquired snapshot.  The caller must not</span><br><span class="line">// use &quot;snapshot&quot; after this call.</span><br><span class="line">virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;</span><br><span class="line"></span><br><span class="line">// DB implementations can export properties about their state</span><br><span class="line">// via this method.  If &quot;property&quot; is a valid property understood by this</span><br><span class="line">// DB implementation, fills &quot;*value&quot; with its current value and returns</span><br><span class="line">// true.  Otherwise returns false.</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">// Valid property names include:</span><br><span class="line">//</span><br><span class="line">//  &quot;leveldb.num-files-at-level&lt;N&gt;&quot; - return the number of files at level &lt;N&gt;,</span><br><span class="line">//     where &lt;N&gt; is an ASCII representation of a level number (e.g. &quot;0&quot;).</span><br><span class="line">//  &quot;leveldb.stats&quot; - returns a multi-line string that describes statistics</span><br><span class="line">//     about the internal operation of the DB.</span><br><span class="line">//  &quot;leveldb.sstables&quot; - returns a multi-line string that describes all</span><br><span class="line">//     of the sstables that make up the db contents.</span><br><span class="line">//  &quot;leveldb.approximate-memory-usage&quot; - returns the approximate number of</span><br><span class="line">//     bytes of memory in use by the DB.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * leveldb会有自己的统计信息，这个函数可以获得这些信息;</span><br><span class="line"> * @param property</span><br><span class="line"> * @param value</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">virtual bool GetProperty(const Slice&amp; property, std::string* value) = 0;</span><br><span class="line"></span><br><span class="line">// For each i in [0,n-1], store in &quot;sizes[i]&quot;, the approximate</span><br><span class="line">// file system space used by keys in &quot;[range[i].start .. range[i].limit)&quot;.</span><br><span class="line">//</span><br><span class="line">// Note that the returned sizes measure file system space usage, so</span><br><span class="line">// if the user data compresses by a factor of ten, the returned</span><br><span class="line">// sizes will be one-tenth the size of the corresponding user data size.</span><br><span class="line">//</span><br><span class="line">// The results may not include the sizes of recently written data.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 给key的范围、给level的层数，获得这些key大概的磁盘占用空间</span><br><span class="line"> * @param range</span><br><span class="line"> * @param n</span><br><span class="line"> * @param sizes</span><br><span class="line"> */</span><br><span class="line">virtual void GetApproximateSizes(const Range* range, int n,</span><br><span class="line">                                 uint64_t* sizes) = 0;</span><br><span class="line"></span><br><span class="line">// Compact the underlying storage for the key range [*begin,*end].</span><br><span class="line">// In particular, deleted and overwritten versions are discarded,</span><br><span class="line">// and the data is rearranged to reduce the cost of operations</span><br><span class="line">// needed to access the data.  This operation should typically only</span><br><span class="line">// be invoked by users who understand the underlying implementation.</span><br><span class="line">//</span><br><span class="line">// begin==nullptr is treated as a key before all keys in the database.</span><br><span class="line">// end==nullptr is treated as a key after all keys in the database.</span><br><span class="line">// Therefore the following call will compact the entire database:</span><br><span class="line">//    db-&gt;CompactRange(nullptr, nullptr);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 手动触发指定key范围的compaction</span><br><span class="line"> * @param begin</span><br><span class="line"> * @param end</span><br><span class="line"> */</span><br><span class="line">virtual void CompactRange(const Slice* begin, const Slice* end) = 0;</span><br></pre></td></tr></table></figure>
<p><code>ReleaseSnapshot</code>这个也可以通过<code>shared_ptr</code>来进行封装，这样就省的自己操作了; <code>GetProperty</code>这个函数对后期真正线上使用的时候会特别有用，因为可以让leveldb吐出来很多leveldb自身的信息，方便查问题并且调整leveldb; 对于db来说，能清楚的知道db的状态是非常重要的;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/何为国债/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/何为国债/" itemprop="url">何为债券</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-03T18:51:53+08:00">
                2020-03-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-03-03T20:36:32+08:00">
                2020-03-03
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/财经/" itemprop="url" rel="index">
                    <span itemprop="name">财经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-债券"><a href="#1-债券" class="headerlink" title="1. 债券"></a>1. 债券</h3><ul>
<li>wiki-定义</li>
</ul>
<blockquote>
<p>债券(Notes)是政府、金融机构、工商企业等机构直接向社会借债筹措资金时，向投资者发行，承诺按一定利率支付利息并按约定条件偿还本金的债权债务凭证。债券的本质是债的证明书，具有法律效力。债券购买者与发行者之间是一种债权债务关系，债券发行人即债务人(Debtors)，投资者（或债券持有人）即债权人(Creditors)。最常见的债券为定息债券、浮息债券以及零息债券。</p>
</blockquote>
<ul>
<li>与银行贷款的不同</li>
</ul>
<blockquote>
<p>与银行信贷不同的是，债券是一种直接债务关系。银行信贷通过存款人——银行，银行——贷款人形成间接的债务关系。</p>
</blockquote>
<h4 id="债券的特性"><a href="#债券的特性" class="headerlink" title="债券的特性"></a>债券的特性</h4><ol>
<li>债券属于有价证券</li>
<li>债券是一种虚拟资本</li>
<li>债券是债权的表现</li>
</ol>
<h4 id="债券的基本要素"><a href="#债券的基本要素" class="headerlink" title="债券的基本要素"></a>债券的基本要素</h4><ul>
<li>债券价格：也就是债券的面值; 面值是固定的，但是购买这些债券的花费的价值是不固定的，有时候高有时候低;</li>
<li>债券利息: 债券利率是<strong>债券利息</strong>与<strong>债券面值</strong>的比率。债券利率分为固定利率和浮动利率两种。债券利率一般为年利率，面值与利率相乘可得出年利息。债券利率直接关系到债券的收益。影响债券利率的因素主要有银行利率水平、发行者的资信状况、债券的偿还期限和资金市场的供求情况等</li>
<li><p>债券还本期限与方式</p>
<ul>
<li>债券还本期限是指从债券发行到归还本金之间的时间</li>
<li>债券还本方式是指一次还本还是分期还本等，还本方式也应在债券票面上注明。</li>
</ul>
</li>
</ul>
<h4 id="债券的特征"><a href="#债券的特征" class="headerlink" title="债券的特征"></a>债券的特征</h4><ul>
<li>期限性</li>
<li>流动性: 仅仅次于储蓄存款；流动性非常好</li>
<li>收益性: 票息（债券利息） + 债券买卖价格差 = 债券收益率</li>
<li><p>安全性</p>
<p>  <strong>市场风险是指债券的市场价格随资本市场的利率上涨而下跌，因为债券的价格是与市场利率呈反方向变动的。当利率下跌时，债券的市场价格便上涨；而当利率上升时，债券的市场价格就下跌。而债券距离到期日越远，其价格受利率变动的影响越大。</strong></p>
</li>
<li><p>自主性</p>
</li>
</ul>
<h4 id="债券类型"><a href="#债券类型" class="headerlink" title="债券类型"></a>债券类型</h4><ul>
<li><p>按照发行主体分类</p>
<ul>
<li>政府</li>
<li>金融债券</li>
<li>企业债券</li>
</ul>
</li>
<li><p>按付息方式划分</p>
<ul>
<li><strong>贴现债券</strong>: 购买债券的时候，按照折扣来进行买；这样折扣就是利息;</li>
<li><strong>零息债券</strong>: 零息债券指债券到期时和本金一起一次性付息、利随本清，也可称为到期付息债券。付息特点一是利息一次性支付。二是债券到期时支付。</li>
<li><strong>附息债券</strong>: 附息债券指债券券面上附有息票的债券，是按照债券票面载明的利率及支付方式支付利息的债券。息票上标有利息额、支付利息的期限和债券号码等内容。持有人可从债券上剪下息票，并据此领取利息。附息国债的利息支付方式一般是在偿还期内按期付息，如每半年或一年付息一次。</li>
<li><strong>固定利率债券</strong>: 是在偿还期内利率固定的债券</li>
<li><strong>浮动利率债券</strong>: 浮动利率债券是指利率可以变动的债券。这种债券的利率确定与市场利率挂钩，一般高于市场利率的一定百分点。</li>
</ul>
</li>
<li><p>按照偿还期限划分</p>
<ul>
<li>长期：&gt; 10年; 我国是5年为分割点</li>
<li>中期:1 ~ 10年</li>
<li>短期: &lt; 1年</li>
</ul>
</li>
<li><p>按照是否可转换来区分</p>
<ul>
<li>可转债债券</li>
<li><p>不可转换债券</p>
<p>可转换债券是能按一定条件转换为其他金融工具的债券，而不可转换债券就是不能转化为其他金融工具的债券。可转换债券一般都是指的可转换公司债券，这种债券的持有者可按一定的条件根据自己的意愿将持有的债券转换成股票。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-债券市场"><a href="#2-债券市场" class="headerlink" title="2. 债券市场"></a>2. 债券市场</h3><p>债券市场, 分为一级市场和二级市场; 其实一开始我很不能理解，为什么会存在债券这种东西? 它存在的形式有的时候和股票那么像，可能买来买去，而且竟然价格还会那么不一致；这主要原因在于: </p>
<blockquote>
<p>债券市场，一个将债券变成可以交易的东西，而不再是只有两个人的关系; 现在的金融市场的基础是信用; 而债券本身就是信用证明，证明了其实期限一到就可以获得一笔钱; 这样以来，其实被借人可以将债券证明卖掉，来提前获得钱;</p>
<p>就这样,债券市场就产生了；那为什么会有价格高低呢? 原因在于每个时间点的利率是不一样的，与国家的基本利率有关系; 比如去年借钱利率是5%，但是今年就只有1%，那么如果5%的债券出来卖的时候价格肯定是高的，因为买走这个债券是有稳定的可预见的收益;</p>
</blockquote>
<h3 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h3><ol>
<li>2010年，利率为5%, A为B借了100元; 那么就产生了借条: 100元，年利率为5%</li>
<li>2013年, B已经拿了两年的利息, 也就是10元；但是由于他比较缺钱，他需要把这个借条卖掉; 这年的利率是1%；</li>
<li>因为2013年的利率很低，所以B卖出这个债券的价格就比债券本身的面值(100)要高; 比如卖出的价格是105元; </li>
<li>那么B总共赚的钱是 10 + 5 = 15; 那么他的年华收益率100 <em> (1 + x) </em> (1 + x) = 115; 年化利率大概是7%； 这个利率比银行高好多啊; </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/04/关于Linux内存的一些知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/关于Linux内存的一些知识/" itemprop="url">关于Linux内存的一些知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-04T11:50:57+08:00">
                2019-04-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-04-18T14:24:26+08:00">
                2019-04-18
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>页表</p>
<p> 每个进程都会有自己的页表，页表的主要的作用就是将虚拟地址转化为真实的物理地址；通过页表的架构是这样的：</p>
<p> <img src="media/9C2C6E33-E0C4-4EEC-9F24-37C2C6E6917E.png" alt="9C2C6E33-E0C4-4EEC-9F24-37C2C6E6917E"></p>
</li>
</ol>
<p>有三个部分组成</p>
<pre><code>* 页表目录
* 页表
* 偏移量
</code></pre><p>多级的好处是节省内存占用率，如果只有一级的话，那么即使不用全部的线程地址，也会占用很多无效内存; 所以多级可以有效的介绍这部分的开销;</p>
<p>那不同进程是如何找到自己的页表的物理地址呢？那么就要靠<code>cr3(控制寄存器)</code>，每次进程切换会把这个寄存器恢复，那么每次查找页表的时候就可以轻而易举的找到页表；</p>
<ol start="2">
<li><p>页表和页的权限控制</p>
<p> 根据User/Supervisor这个flag来设置权限;这个flag是存在页表项的;</p>
<ul>
<li>0: 必须是内核态才能访问</li>
<li><p>1: 总能访问</p>
<p>通过这个就可以保护内存的访问，有的只有内核态的进程才能访问;</p>
</li>
</ul>
</li>
<li><p>PAE（物理地址扩展）</p>
<p> 明明地址空间只有32bit，如何能使用超过4GB的物理内存空间呢；就出现了PAE了; 其本质在于在cr3这个寄存器上做了手段；cr3本身指向页表的物理地址，所以cr3可以变化，可以指向多个页表的物理地址就可以访问多个物理地址了；<br> 寻址空间依然是4GB，只不过通过切换来使用更多的内存；但是由于用户态的进程不能修改页表，所以它无法使用超过4GB的物理内存；</p>
</li>
<li><p>高速缓存和TLB</p>
<p> 高速缓存主要解决的是cpu与ram速度的巨大差异，用来缓解这个过程；在cpu和ram之间加入高速缓存，cpu直接访问cache而不是RAM；使用的原理当时就是局部性原理；</p>
<pre><code>* 时间局部性: 在一定返回内会重复执行某一些东西
* 空间局部性: 访问了一个地址空间的内容，有极大的概率会访问周边的内存
</code></pre><p> 高速缓存的组成是cacheline，每一个cacheline大概是64kb; 那么如果确定当前地址是否在cache中呢，其实方式依然还是用虚拟地址中的各个地址位来进行判断;目前有三种；</p>
<p> TLB: 我们知道虚拟地址转为物理地址需要通过查找页表来进行；那么我们也知道RAM的速率和cpu相比很慢，如果每次都走一次RAM那基本上就没得玩了；所以TLB就是一个保存virtual-&gt;phyical的一个kv硬件缓存；但是当cr3这个寄存器修改的时候，TLB就会失效；so 切换进程是多么耗时的事情;</p>
</li>
<li><p>物理内存分布</p>
<p> 内核会将下面的页框保留下来，不会被动态分配和交换到磁盘上去 </p>
<ul>
<li>在不可用的物理地址范围内的页框</li>
<li><p>含有内核代码和已初始化的数据结构的页框</p>
<p>内核通常为了能保存在物理内存上连续存储，会选择跳过第一个MB，从0x00100000的物理地址开始使用;</p>
</li>
</ul>
</li>
<li><p>内核页表</p>
<p> 进程的页表在内核部分的页表是公用的；通过的方式是每次生成一个新的进程的时候，新的页表中内核页表是指向原来的进程是一样的；而用户态的页表是使用cow的方式，虽然也是一样的，从一开始来说;</p>
</li>
<li><p>缓存和tlb</p>
<ul>
<li><p>TLB高速缓存的刷新是内核而不是硬件；</p>
<p>  通常情况来说，进程切换的时候就会让tlb失效；内核在进行cr3变更的时候就会触发这个操作; 下面的几个情况，内核会避免TLB切换:</p>
<ul>
<li>当两个使用相同页表集的普通进程之间执行切换的时候；比如线程的切换</li>
<li>当一个普通进程和一个内核线程间进行切换的时候；因为内核线程是没有自己单独的页表的，而是内核统一的页表；所以切换的时候内核其实还是用进程之前的页表;</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/关于线程、进程、协程的了解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/关于线程、进程、协程的了解/" itemprop="url">关于线程、进程、协程的了解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-29T11:02:16+08:00">
                2019-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-04-02T23:11:10+08:00">
                2019-04-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>虚拟地址、物理地址</p>
<p> linux的内存管理模块将物理地址封装到了底层，也就是说物理地址只有操作系统内核在管理，而程序员或者程序本身能获得的地址都是虚拟地址； 这么做的好处是:</p>
<ul>
<li>每一个进程有着独立和相同范围的虚拟地址; 与物理地址的关系有os来管理，每一个进程都会维护一个页表，这就是对应关系;</li>
<li>对权限管理会更加好做，防止进程访问相互的内存地址空间;</li>
</ul>
</li>
<li><p>进程之间的fork</p>
<p> linux的进程通过fork的方式创建子进程，当子进程创建初期，子进程和父进程是一样的；一样主要体现在页表内容是一致的；也就是表示两个进程的虚拟地址指向的物理地址一样的；如果一致一样肯定是不行的；所以当两个进程谁修改了对应的数据，就会以copy-on-write的方式来进行修改，其实本质就是修改虚拟地址指向其他的物理页;</p>
</li>
<li><p>进程描述符(每一个进程的一生的档案)</p>
<p> linux虽有线程概念，其本质依然还是进程，每一个线程都有进程描述符，但是线程与进程的区别在于有一些东西可以共享；每一个进程(线程)都存在一个pid；操作系统为了能更加好管理pid的空闲状态，通常会使用bitmap来保存使用状态；32bit的操作系统，通过会使用一个页来保存这些信息，这些信息会永久的存放在内存中; 64bit就会更加多一些;</p>
<p> 一个进程通常会有多个线程，线程与进程一致会存在pid，那么进程的pid是什么呢？linux中的方式就是将本线程组的pid设置会当前进程的pid，其实进程的pid就是线程组的tgid;</p>
</li>
<li><p>等待队列</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct wait_queue_t&#123;</span><br><span class="line">    unsigned int flags; // 0: 非互斥唤醒(将进程全部唤醒) 1:互斥唤醒(只唤醒一个等待的进程)</span><br><span class="line">    struct task_struct* task; //唤醒的具体的task</span><br><span class="line">    wait_queue_func_t func; // 等待队列中的睡眠进程应该用什么方式唤醒；</span><br><span class="line">    struct list_head task_list; // 等待线程链表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait_queue_t是等待队列的item;</span><br></pre></td></tr></table></figure>
<p>进程被阻塞或者等待的过程:</p>
<pre><code>1. 定义wait_queue_t的变量，然后使用init_waitqueue_entry来初始化变量
2. 将等待的变量加入到等待队列中去
3. schedule触发cpu调度
4. 当触发事件完成之后，回归到当前进程的第一件事就是删除等待队列这个变量；
</code></pre><p>wake_up的过程:如果某一个事件发生了,那么内核就会找到对应的等待队列，然后进行唤醒:</p>
<pre><code>1. 获得等待队列表头
2. 轮训队列
3. 如果等待的任务是非互斥的任务就进行唤醒
4. 如果等待的任务是互斥的，并且只是第一次被唤醒的话，那么就推出wake_up

这个任务等待队列有两个前提： 1. 非互斥的任务一定是放在互斥的任务之前 2. 任务可能会被超过一次唤醒，不过我猜应该可能保证是否已经被触发过；
</code></pre><ol start="5">
<li><p>进程切换（重点）</p>
<blockquote>
<p>进程切换、任务切换、context切换是指内核有能力挂起cpu上运行的进程，并恢复以前挂起的某一个进程的执行;</p>
</blockquote>
</li>
</ol>
<pre><code>&gt; cs: 代码段寄存器, ip: 指令指针寄存器，指向cpu下一条要运行的指令或者当前正在执行的指令;


进程切换首先需要了解，切换过程涉及到了什么呢？

* 硬件上下文：主要是指进程在恢复到cpu上运行的时候，必须恢复的寄存器数据; 硬件上下文仅仅只是进程切换的一个子集；这个上下文一部分存放在tss段，一部分存放在内核堆栈上;

    * 进程切换只发生在内核态，在进程进程切换之前，**用户态进程使用的所有寄存器**内容都会保存在**内核态堆栈**上，包括了ss和esp这对寄存器内存; 
    * 进程切换大部分是否是在时间中断的时候被触发，触发的过程会导致进程调度，所以才会只有在内核中存在；

* tss(task state segment): 任务状态段,虽然linux不使用硬件切换，但是强制每一个cpu会创建一个tss，原因:

    * 用户态到内核态切换的时候，可以从tss中获得内核堆栈的地址;
    * 进程IO性能的时候好，可以通过tss获得IO位图来检查权限;

    tss反映了CPU上的当前进程的特权级别; 因为linux不是每个进程一个tss，而是一个cpu一个tss，所以在切换的时候需要保存被替换的硬件上下文,这个和intel的原先设计有点出入;

* 进程描述符的thread字段，linux会被硬件上下文保存在这个字段中;

* Linux的进程切换的schedule函数

    1.切换页全局目录以安装一个新的地址空间
    2.切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程的所需要的所有信息，包括cpu寄存器

* switch_to(prev,next,last)

    * prev: 当前进程
    * next: 切换到目标的进程
    * last: 指向当前进程，其实就是prev的内存地址;

    1. 通常切换参数为prev,next,last,调用了switch_to之后这些参数通过压stack的方式保存在内核栈中;
    2. 将prev的内容写入到cpu的eax寄存器
    3. 恢复到next进程的内核栈；**注意注意：由于恢复到了next的内核栈，那么prev其实不在是真正的prev的，而是之前next在调用switch_to被切换出去的时候自己**，所以通过eax来将prev替换
    4. 将prev赋值给last

* switch_to 代码
</code></pre><ul>
<li><p>进程创建</p>
<blockquote>
<p>通用寄存器的值是在从用户态切换到内核态时被保存到内核态堆栈中的;</p>
</blockquote>
<p>  Linux进程创建的优化：</p>
<ul>
<li>子进程复制父进程的资源；并非是完全copy；而是使用了COW的方式进行优化</li>
<li>线程和进程，线程其实就是Linux中轻量级的进程，只不过使用了共享父进程的很多资源来保证高效创建；</li>
<li><p>vfork:共享父进程的内存地址空间，又不具有cow性质;</p>
<p>总结：进程创建过程中，子进程必须要申请的资源是task_struct和对应的内核栈的空间，所以内核栈是每个线程或者进程都会存在一个的; 虽然在空间上是分离的，但是在赋值的时候还是会将父进程的大部分东西赋值给子进程，尤其是在操作过程将描述符的很多字段进行赋值；这个过程中有几点需要明确:</p>
<ul>
<li>描述符进行了赋值、thread也进行了部分赋值；但是esp、eax这些寄存器值确是自己的；因为这        是很重要的,esp指向的是子进程内核, eax是存放系统调用的返回值,因为fork会返回两个值，返回父进程的是子进程的pid，而返回给子进程是0; eip用于存储下一条执行的指令;</li>
<li>执行完clone之后，进程就可以被调度了；当子进程被调度到的时候，就会将内核栈存储的硬件上下文装载到cpu，这样可以是cpu恢复到用户态模式；这个时候父进程和子进程有一些不一样的，1是进程描述符不一样，2. 进程内核栈不一样；3.eax不一样的； 但是代码段是共享的，所以通过eax（返回值不一样）可以判断是子进程还是父进程；虽然大部分的资源是共享的，但是通过修改寄存器的值来保证子进程的运行;</li>
</ul>
</li>
</ul>
</li>
<li><p>内核线程</p>
</li>
</ul>
<p>区别点：</p>
<pre><code>* 内核线程只会运行在内核态；普通进程可以在用户态也可以在内核态
* 内核线程只能访问PAGWE_OFFSET以上的线性地址，而普通线程可以是全部的线性地址；
</code></pre><p>自己的理解可能是这样的，内核线程之间是共享地址空间的；类似于一个进程下面的线程一样，使用了相同的地址空间; 所有的内核线程其实使用了一个地址空间，而且地址空间的范围也是一定的；创建内核线程与普通进程创建是一致的；</p>
<pre><code>* 进程0:所有进程的祖先，这个是linux初始化的时候静态分配的，而其他的进程都是动态分配
* 创建pid为1的进程，然后进程0开始执行cpu idle的函数，这个函数主要是用于没有runing进程的时候就开始执行cpuidle的任务
</code></pre><p>其他的内核线程</p>
<pre><code>* keventd(事件)：执行keventd_wq工作队列
* kaqmq：与电源相关的事件
* kswapd: 执行内存回收
* pdflush: pagecache脏页会写
* kblockd: 执行kblock_workqueue工作队列的函数。它周期性地激活块设备驱动
* ksoftirq: 执行tasklet，每个cpu都有这样的内核线程
</code></pre><ul>
<li><p>进程终止</p>
<p>  当父进程使用wait处理了子进程挂的信号，那么这个时候子进程的最后资源就会被回收，这部分资源主要是集中在进程描述符上面，还有就是thread对象和内核栈</p>
</li>
</ul>
<ul>
<li><p>线程和进程的区别在于：</p>
<ul>
<li>在linux下面线程其实被当作进程处理，有着自己的task_struct结构，只不过线程在创建过程中会共享父进程的内存空间地址;</li>
<li>因为是被当作单独的task来处理，所以线程有着自己的内核栈; 当线程因为某一种关系进入内核的时候需要内核栈来保存硬件上下文(寄存器等值)</li>
<li>线程有着自己的寄存器的值</li>
<li><p>线程有着自己的stack；如果公用主线程的stack就会破坏stack结构;</p>
<p>fork如果创建的是一个子进程，也就说flag没有带上CLONE_VM的话，那么就表示子进程有着自己独立的地址空间，只不过只不过一开始的时候内容是和父进程是一样的；但是但是这过程中有一个页表copy的过程；</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/整理/" itemprop="url">整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T10:11:15+08:00">
                2019-01-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-03-29T11:00:40+08:00">
                2019-03-29
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2018年末2019年初，又开始新的一年面试;昨天晚上面了一个做存储的公司，全程基本上都是被压着问，通过这次面试给我最大的感悟就是基础知识需要扎实，并且要互联起来; 知识点除了要知道还要知道为什么这么设计; 这次面试对基础询问真的很多很多;</p>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><ul>
<li>面试题: 对于一个有序数组，找到第一个大于等于目标value的index; </li>
</ul>
<blockquote>
<p>一看就是一个二分法查询的过程，但是我当时脑中一片混乱，实在是不知道怎么办; 这个对二分法需要进行改造，主要是在小于等于中间值的时候，需要去比较前面一个值的大小，如果小那就指定的值，如果大于目标值那就在二分查找一下;</p>
</blockquote>
<ul>
<li><p>C++系列的问题</p>
<ul>
<li><p>new、delete和free、malloc的区别; 为什么对于数组new和delete需要加上<code>[]</code>来做区别</p>
<ol>
<li>new 除了可以在堆上使用，也可以用户自定义内存地址来申请;</li>
<li>new即会申请内存空间也会调用数据类型的构造函数初始化;</li>
<li>为什么数组new需要带上<code>[]</code>, 本质上依然还是需要告诉编译器去调用构造函数; 而delete带有<code>[]</code>则是为了调用析构函数</li>
</ol>
</li>
</ul>
</li>
<li><p>右值引用是什么? 推出的目的又是什么?</p>
</li>
<li>vector的push_back的时间复杂度是多少? O(1), 均摊下来应该是常量</li>
<li><p>C++ 6种内存模型;</p>
<ul>
<li>内存模型用来解决什么问题</li>
<li>具体的区别什么</li>
</ul>
</li>
<li><p>linux的问题</p>
<ul>
<li>进程、线程、协程之前的区别点;<ul>
<li>进程、线程、协程切换上下文切换需要保存哪些信息</li>
</ul>
</li>
<li>load定义</li>
<li>虚拟地址空间的排布</li>
</ul>
</li>
<li><p>网络</p>
<ul>
<li>tcp三次握手和断开的4次握手;  这边深究了一下为什么三次握手需要三次而不是二次或者其他</li>
<li>epoll的作用，实现原理，为什么高效</li>
</ul>
</li>
<li><p>存储</p>
<ul>
<li>介绍一下LSM-Tree结构</li>
<li><p>rocksdb查询过程; </p>
<ul>
<li>假如没有分层会怎么样,都聚集在L0层查询效率会变差很多</li>
<li>compaction的过程？写放大是如何计算方式?</li>
<li>writeBatch的作用</li>
<li>writeBatch的原子性是如何实现的</li>
<li>rocksdb对读优化有哪些   </li>
</ul>
</li>
</ul>
</li>
<li><p>共识</p>
<ul>
<li>raft整体过程</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li>acid</li>
<li>隔离性的几种</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/进程调度之死循环/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/12/进程调度之死循环/" itemprop="url">进程调度之死循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-12T22:21:34+08:00">
                2017-04-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2017-04-13T09:52:30+08:00">
                2017-04-13
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要讲的是Linux的进程调度问题，但是能形象的解释其中的一系列的观点，所以找了一个比较经典问题来做载体. 在具体开始之前，先了解一下什么是进程调度呢？</p>
<blockquote>
<p>个人的理解是: 目前操作系统基本都是多任务操作系统，也就是说一个操作系统中存在有多个进程，但是CPU资源是有限的，不能让所有的进程都能一直在运行；所以调度系统就是一个将cpu资源合理分配给各个可运行状态的进程的内核子系统,是多任务操作系统的基础;</p>
</blockquote>
<p>貌似很复杂难懂的调度系统有着一个非常简单的目标: <strong>最大限度利用CPU的处理时间</strong>; 调度系统的基本任务就是: <strong>从多个可运行状态的进程中挑选出一个合适的进程来运行</strong>, 这里的<strong>合适</strong>也是调度系统的核心算法.</p>
<h4 id="1-提问"><a href="#1-提问" class="headerlink" title="1. 提问"></a>1. 提问</h4><p><em>为什么死循环能让CPU利用达到100%呢?</em> </p>
<p>这个问题也是困扰我多年的问题，当然可能就是因为对Linux操作系统的进程调度没有学好才导致这个问题一直困扰我. 针对上面的问题还能引出几个其他的问题?</p>
<ul>
<li>死循环是否会导致系统响应速度下降;</li>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/07/Linux之进程管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/07/Linux之进程管理/" itemprop="url">Linux进程管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-07T07:16:14+08:00">
                2017-04-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2017-04-10T21:48:43+08:00">
                2017-04-10
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux系统本身没有对线程做出特殊的改造，在Linux中线程本身与创建进程的流程是一样的；唯一与进程的区别是在创建过程中，进程的创建是资源独立的，而线程在创建的过程中，会与其他的进程共享一些资源；所以在Linux中，线程本就是进程，一个有着一点点不同的进程.</p>
<p>Linux中每一个进程都会有一个统一的结构<code>task_struct(进程描述符)</code>, 这个结构包含了进程的所有的信息，包括状态、占有的资源、内存空间等一些; Linux将这些进程描述符放在任务队列中来分别进行调用.</p>
<h4 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1. 进程的状态"></a>1. 进程的状态</h4><ul>
<li>TASK_RUNNING(运行 or 就绪): 这个状态的进程要不就是正在运行或者在运行队列中等待运行; </li>
<li>TASK_INTERRUPTIBLE(中断): 表示当前进程处于等待状态，直到某一个条件为真或者传递一个信号都能唤醒进程;</li>
<li>TASK_UNINTERRUPTIBLE:与TASK_INTERRUPTIBLE类似，只是这个状态的进程不会因为信号而被唤醒;</li>
<li>TASK_STOPPED:进程执行被暂停，当收到到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号的时候;</li>
<li>TASK_ZOMBIE: 进程执行被终止，但是父进程还没有调用wait4或waitpid来收集信息;</li>
<li>TASK_DEAD:进程彻底死亡状态</li>
<li>TASK_TRACED:跟踪状态，用于debug</li>
</ul>
<h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>上面已经说了，Linux的进程和线程的创建几乎是一模一样的，只是后面会有点点小小的区别;Linux创建进程的过程主要依赖两个系统调用fork+exec; </p>
<h5 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h5><p>进程调用fork就可以创建子进程；之前的fork是比较粗暴，直接复制所有的资源给子进程，但是这样效率比较低效，因为子进程通过会通过exec来加载另外的程序，那么之前的copy过程就是无用功. 所谓的<code>copy-on-write</code>，就是在调用fork的时候只分配一些进程与进程之间必须独立的资源，比如task_struct结构体、页表(内容是copy父进程的)、内核栈等，其他的资源都是父进程的引用而已;通过这种方式来提高性能.</p>
<p>fork的基本流程是如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">fork=&gt;operation: fork</span><br><span class="line">clone=&gt;operation: clone</span><br><span class="line">dofork=&gt;operation: do_fork</span><br><span class="line">dup=&gt;operation: copy一个父进程的进程描述符(比如内核栈、task_struct、thread_info，这些可能是每一个进程所必须的结构)</span><br><span class="line">setstate=&gt;operation: 设置子进程状态，并且修改进程描述符做区别</span><br><span class="line">copy=&gt;operation: 根据clone传入的参数来进行资源copy</span><br><span class="line">run=&gt;operation: 平分时间片，然后将子进程唤醒</span><br><span class="line"></span><br><span class="line">st-&gt;fork-&gt;clone-&gt;dofork-&gt;dup-&gt;setstate-&gt;copy-&gt;run-&gt;e</span><br></pre></td></tr></table></figure>
<h5 id="2-2-关于Linux中的线程"><a href="#2-2-关于Linux中的线程" class="headerlink" title="2.2 关于Linux中的线程"></a>2.2 关于Linux中的线程</h5><p>上面说了，Linux的线程其实就是linux的进程，只是在创建的时候传给<code>clone</code>函数的参数上有一些不一样的; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);</span><br></pre></td></tr></table></figure>
<p>线程在创建的时候通过传入以上的几个参数，这可能就是与进程创建区别了，这样创建的进程与父进程是共享地址空间、文件系统、打开的文件、信号处理函数；所以从这看出，Linux所谓的线程本质其实就是进程。</p>
<h5 id="2-3-内核线程-Kernal-thread"><a href="#2-3-内核线程-Kernal-thread" class="headerlink" title="2.3 内核线程(Kernal thread)"></a>2.3 内核线程(Kernal thread)</h5><p>内核线程与普通的进程的区别在于</p>
<pre><code>* 内核线程没有独立的地址空间
* 只运行在内核态，从不切换到用户态
</code></pre><p>其他是类似的，可以被抢占，也可以被调度;</p>
<h4 id="3-进程死亡"><a href="#3-进程死亡" class="headerlink" title="3. 进程死亡"></a>3. 进程死亡</h4><p>每一个进程总会面临死亡的过程，那么进程的死亡要经过哪几个步骤呢？一个进程的创建的过程是赋予资源，那么进程死亡就是归还资源的过程;</p>
<p>什么时候进程会面临终结呢? 显示的调用了<code>exit()</code>这个系统调用，或者是被动总结，不管怎么样触发，这个过程都有<code>do_exit</code>完成;</p>
<ul>
<li>释放各种资源</li>
<li>设置进程的状态为TASK_ZOMBIE</li>
<li>发送信号给父进程，说我快终结了</li>
<li>调用schedule函数，主动的放弃cpu</li>
</ul>
<p>到此为止，进程已经释放了大部分的资源，不过还保存着进程描述符、内核栈、thread_info等一些必要的数据结构，直到父进程调用<code>wait4()</code>系统收集子进程的一些状态，那么这进程就真正的终结;Linux将资源清理与进程描述符清理分开执行;</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><ul>
<li>进程状态</li>
<li>Linux 进程与线程是同样的东西;</li>
<li>进程的创建与死亡</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/scylladb-官文安装译文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nomoshen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nomoshen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/04/scylladb-官文安装译文/" itemprop="url">scylladb 官文安装译文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T19:56:06+08:00">
                2017-04-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2017-04-07T07:16:49+08:00">
                2017-04-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scylladb/" itemprop="url" rel="index">
                    <span itemprop="name">scylladb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要的依赖于官方的教程，这边主要是将一些细节进行串联描述，下次安装的时候会更加自动化;</p>
<p>我的安装环境如下：</p>
<ul>
<li>centos7.2</li>
<li>内核版本为3.18</li>
</ul>
<h4 id="1-关于scylladb几个rpm的介绍"><a href="#1-关于scylladb几个rpm的介绍" class="headerlink" title="1. 关于scylladb几个rpm的介绍"></a>1. 关于scylladb几个rpm的介绍</h4><ul>
<li>scylla-server(standard):scylladb主要的server端</li>
<li>scylla-server(debuginfo):scylladb server端并且带有debuginfo</li>
<li>scylla-jmx: 兼容cassandra通过jmx端口进行访问</li>
<li>scylla-tools: scylla为了兼容cassandra而提供的类似的功能:<ul>
<li>nodetool:很强大的功能，用来观察集群状态</li>
<li>cqlsh:</li>
<li>cassandra-stress:压测工具</li>
</ul>
</li>
</ul>
<h4 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2.前期准备"></a>2.前期准备</h4><ul>
<li>删除abrt,主要是这个与scylladb本身的coredump配置冲突; <code>yum remove -y abrt</code></li>
<li>必须有sudo权限</li>
<li>预安装的东西, <code>yum install -y wget epel-release</code>, <code>epel-release</code>是一个fedora维护的软件仓库，全名叫做<em>企业版Linux额外软件包</em></li>
</ul>
<h4 id="3-正式开始装"><a href="#3-正式开始装" class="headerlink" title="3. 正式开始装"></a>3. 正式开始装</h4><ul>
<li>下载最新的scylladb源，由于每次更新源都会有一定的变化，所以每一次更新的时候最好要更新一下源;下面的源是1.4版本的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/scylla.repo http://downloads.scylladb.com/rpm/centos/scylla-1.4.repo</span><br></pre></td></tr></table></figure>
<ul>
<li><p>是scylla yum源生效; <code>yum clean all; yum makecache</code></p>
</li>
<li><p>安装scylla; <code>yum install -y scylla</code></p>
</li>
</ul>
<p>如果一些顺利的话，到这一步scylladb就已经安装完毕了</p>
<h4 id="4-配置和脚本相关的"><a href="#4-配置和脚本相关的" class="headerlink" title="4. 配置和脚本相关的"></a>4. 配置和脚本相关的</h4><table>
<thead>
<tr>
<th>配置名字</th>
<th>配置作用</th>
<th>配置位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>scylladb的主要配置</td>
<td>设定一些主要的参数，比如存储位置、开放端口和ip，也会有一些性能参数设置</td>
<td>/etc/scylla/scylla.yaml</td>
</tr>
<tr>
<td>scylla启动脚本</td>
<td></td>
<td>/etc/sysconfig/scylla-server</td>
</tr>
<tr>
<td>系统资源限制</td>
<td>去掉对scylla用户的资源限制</td>
<td>/etc/security/limits.d/scylla.conf</td>
</tr>
<tr>
<td>启动脚本</td>
<td>设置参数、启动scylladb脚本</td>
<td>/etc/sysconfig/scylla-server</td>
</tr>
<tr>
<td>coredump配置文件</td>
<td>设置coredump的配置文件</td>
<td>/etc/sysconfig/sysctl.d/99-scylla.conf</td>
</tr>
<tr>
<td>collectd配置文件</td>
<td>设置collectd的一些配置</td>
<td>/etc/collectd.d/scylla.conf</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>配置名字</th>
<th>配置作用</th>
<th>配置位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>内核设置</td>
<td>在bootloader中设置内核参数</td>
<td>/usr/lib/scylla/scylla_bootparam_setup</td>
</tr>
<tr>
<td>coredump配置文件生成器</td>
<td></td>
<td>/usr/lib/scylla/scylla_coredump_setup</td>
</tr>
<tr>
<td>ntp协议配置生成器</td>
<td></td>
<td>/usr/lib/scylla/scylla_ntp_setup</td>
</tr>
<tr>
<td>网络配置设定</td>
<td></td>
<td>/usr/lib/scylla/scylla_prepare</td>
</tr>
<tr>
<td>配置raid和文件系统的脚本</td>
<td></td>
<td>/usr/lib/scylla/scylla_raid_setup</td>
</tr>
<tr>
<td>压缩coredump脚本</td>
<td>only ubuntu有效</td>
<td>/usr/lib/scylla/save_coredump</td>
</tr>
<tr>
<td>重新设置网络模式</td>
<td>如果scylladb运行的virtio或者DPDK的话，就重新设置网络模式</td>
<td>/usr/lib/scylla/scylla_stop</td>
</tr>
<tr>
<td>重新设置网络参数</td>
<td></td>
<td>/usr/lib/scylla/posix_net_conf.sh</td>
</tr>
<tr>
<td>io.conf生成器</td>
<td>用于测试io性能，并且把文件提供给scylladb</td>
<td>/usr/lib/scylla/scylla_io_setup </td>
</tr>
</tbody>
</table>
<p>上面这些脚本都是在<code>/usr/lib/scylla</code>目录下面的，并且还有其他的脚本，这些脚本会在运行scylla_setup的时候会调用;详情请看<a href="http://www.scylladb.com/doc/system-configuration/" target="_blank" rel="noopener">url</a></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>端口值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cql</td>
<td>9042</td>
</tr>
<tr>
<td>内部rpc</td>
<td>7000</td>
</tr>
<tr>
<td>ssl内部rpc</td>
<td>7001</td>
</tr>
<tr>
<td>jmx 端口</td>
<td>7199</td>
</tr>
<tr>
<td>scylla rest api</td>
<td>10000</td>
</tr>
<tr>
<td>Scylla Prometheus API(不知道是什么)</td>
<td>9180</td>
</tr>
<tr>
<td>node_exporter</td>
<td>9100</td>
</tr>
</tbody>
</table>
<h4 id="5-具体的配置"><a href="#5-具体的配置" class="headerlink" title="5. 具体的配置"></a>5. 具体的配置</h4><table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>seeds</td>
<td>种子ip列表，建议多几个ip</td>
</tr>
<tr>
<td>listen_address</td>
<td>scylladb内部通信的ip</td>
</tr>
<tr>
<td>rpc_address</td>
<td>客户端连接scylladb的ip</td>
</tr>
<tr>
<td>broadcast_address</td>
<td>默认listen_address，从其他节点角度看这个node的ip，可能是不同网络之间不同，而通过外网来进行互联</td>
</tr>
<tr>
<td>broadcast_rpc_address</td>
<td>默认是rpc_address,从client角度上来你应该是什么ip，同上</td>
</tr>
</tbody>
</table>
<h4 id="6-scylladb管理命令"><a href="#6-scylladb管理命令" class="headerlink" title="6. scylladb管理命令"></a>6. scylladb管理命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scylla –version</td>
<td>查看版本</td>
</tr>
<tr>
<td>nodetool snapshot</td>
<td>将node数据进行快照;关于scylladb snapshot的原理是：通过linux的hardlink来进行备份，因为scylladb的文件产生之后会不会改变所以这样能很好的保证备份的作用，并且用来了hardlink保证文件的可用性，和不需要通过拷贝也加重系统的负载;</td>
</tr>
<tr>
<td>恢复备份</td>
<td>1. 清空commitlog 2. 清空data目录下面的数据文件 3. 把snapshot备份的文件mv过来即可 4. 重启</td>
</tr>
<tr>
<td>提供rest接口</td>
<td></td>
</tr>
<tr>
<td>scyllatop</td>
<td>scylla自己的top, 目测可以与collectd一起使用，并且提供比较好的功能</td>
</tr>
<tr>
<td>Prometheus</td>
<td>scylla自己的监控系统</td>
</tr>
<tr>
<td>collectd</td>
<td>scylladb本地会启动collectd的进程，用来接收scylladb抛送过来的数据，可以通过插件的方式来修改，比较方便，并且会增加scyllatop看到的数据</td>
</tr>
<tr>
<td>log</td>
<td>scylla log是通过centos7的 journalctl 来控制的；最常用的有<code>journalctl _COMM=scylla -p warning</code> 或者 <code>journalctl _COMM=scylla --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00</code> 或者 <code>journalctl _COMM=scylla -b(从最近一次重启的日志)</code></td>
</tr>
</tbody>
</table>
<p>node tool命令介绍</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodetool status</td>
<td>看集群的状态,<a href="http://www.scylladb.com/doc/nodetool-commands/status/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool snapshot</td>
<td>上面已提过</td>
</tr>
<tr>
<td>nodetool cfhistograms</td>
<td>提供每一个表的静态数据，包括sstable的个数、读写延迟、分区的尺寸和列簇的个数;<code>nodetoll sfhistograms keyspace tablename</code>,<a href="http://www.scylladb.com/doc/nodetool-commands/cfhistograms/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool cfstats</td>
<td>提供对特定的表的一个深层的分析;<code>nodetool cfstats keyspace.tablename</code>,<a href="http://www.scylladb.com/doc/nodetool-commands/cfstats/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>nodetool cleanup</td>
<td>立即触发清理不属于本机的key；<code>nodetool cleanup -h 127.0.0.1 keyspace</code></td>
</tr>
<tr>
<td>nodetool clearsnapshot</td>
<td>清理snapshot文件,<code>nodetool clearsnapshot keyspace</code>,不写keyspace就默认删除全部的snapshot </td>
</tr>
<tr>
<td>compactionhistory</td>
<td>打印compact的历史</td>
</tr>
<tr>
<td>compactionstats</td>
<td>打印目前正在compact的进度和一些信息</td>
</tr>
<tr>
<td>compact</td>
<td>对可能的keyspac而进行强制的compact操作; <code>nodetool compact keyspace</code></td>
</tr>
<tr>
<td>describecluster</td>
<td>打印一些信息</td>
</tr>
<tr>
<td>decommission</td>
<td></td>
</tr>
<tr>
<td>describering</td>
<td>打印某一个keyspace的一致性hash分布情况</td>
</tr>
<tr>
<td>disablebackup</td>
<td>关闭增量备份</td>
</tr>
<tr>
<td>disablebinary</td>
<td>关闭cql</td>
</tr>
<tr>
<td>statusbinary</td>
<td>看cql当前运行的状态</td>
</tr>
<tr>
<td>enablebinary</td>
<td>开启cql</td>
</tr>
<tr>
<td>statusgossip</td>
<td>gossip协议的运行状态</td>
</tr>
<tr>
<td>disablegossip</td>
<td>关闭gossip</td>
</tr>
<tr>
<td>enablegossip</td>
<td>开启gossip</td>
</tr>
<tr>
<td>drain</td>
<td>通常用于升级scylladb之前使用，主要的操作是将所有的memtable全部写入到sstable，然后停止listen各种端口，之后要恢复必须通过重启</td>
</tr>
<tr>
<td>flush</td>
<td>将当然的memtable刷成sstable</td>
</tr>
<tr>
<td>getendpoints</td>
<td><code>nodetool getendpoints keyspace tablename key</code>,现在还不知道用来做什么</td>
</tr>
<tr>
<td>getlogginglevels</td>
<td>获得运行时中的日志等级</td>
</tr>
<tr>
<td>gossipinfo</td>
<td>展示gossip协议中传播的东西</td>
</tr>
<tr>
<td>info</td>
<td>展现当前节点的一些信息; <a href="http://www.scylladb.com/doc/nodetool-commands/info/" target="_blank" rel="noopener">详情</a></td>
</tr>
<tr>
<td>listsnapshots</td>
<td>展示所有的snapshot在磁盘上的占用率</td>
</tr>
<tr>
<td>move</td>
<td>将node 分配到新的token</td>
</tr>
<tr>
<td>netstats</td>
<td>打印一些网络信息</td>
</tr>
<tr>
<td>proxyhistograms</td>
<td>对于网络操作打印一些静态统计</td>
</tr>
<tr>
<td>rebuild <src-dc-name></src-dc-name></td>
<td>从另外一个节点重建数据</td>
</tr>
<tr>
<td>refrash <keyspace> <tablename></tablename></keyspace></td>
<td>在不重启的前提下，重新reload文件中的sstable</td>
</tr>
<tr>
<td>removenode <id></id></td>
<td>移除名为id的节点</td>
</tr>
<tr>
<td>repair</td>
<td>修复一个或者多个的列簇； 参数比较多，使用前查询;</td>
</tr>
<tr>
<td>ring</td>
<td>显示一致性hash的列表</td>
</tr>
<tr>
<td>setlogginglevel <class> <threshold></threshold></class></td>
<td>设置某一个类的运行时日志等级</td>
</tr>
<tr>
<td>settraceprobability – <value></value></td>
<td>设置跟踪请求的概率，value在0~1之间</td>
</tr>
<tr>
<td>snapshot [-t tag] [-cf tablename] <keyspace></keyspace></td>
<td>针对具体的表或keyspace做快照</td>
</tr>
<tr>
<td>statusbackup</td>
<td>增量backup的状态</td>
</tr>
<tr>
<td>stop</td>
<td>停止compact任务</td>
</tr>
<tr>
<td>version</td>
<td>db的版本  </td>
</tr>
</tbody>
</table>
<p>nodetool info几个参数介绍</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gossip active</td>
<td>gossip状态</td>
</tr>
<tr>
<td>Thrift active</td>
<td>thrift 状态</td>
</tr>
<tr>
<td>native transport active</td>
<td>cql的状态</td>
</tr>
<tr>
<td>Load</td>
<td>sstable占磁盘多少空间</td>
</tr>
<tr>
<td>Generation NO</td>
<td>主版本，当节点重启、token更新，这个版本就会往上增加</td>
</tr>
<tr>
<td>Uptime</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Heap Memory</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>off Heap memory (MB)</td>
<td>所有的memtables、bloom filters 、indexs、compression metadata占用的内存</td>
</tr>
<tr>
<td>Data center</td>
<td>这个节点所在的数据中心</td>
</tr>
<tr>
<td>Rack</td>
<td>？？、</td>
</tr>
<tr>
<td>Exception</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Key Cache</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Row Cache</td>
<td>Row cache的信息</td>
</tr>
<tr>
<td>Counter Cache</td>
<td>scylla没有这个</td>
</tr>
<tr>
<td>Token</td>
<td>token展示</td>
</tr>
</tbody>
</table>
<h4 id="7-关于scylladb的monitor安装-由于官方教程变化太大-以官方为准"><a href="#7-关于scylladb的monitor安装-由于官方教程变化太大-以官方为准" class="headerlink" title="7. 关于scylladb的monitor安装[由于官方教程变化太大,以官方为准]"></a>7. 关于scylladb的monitor安装[由于官方教程变化太大,以官方为准]</h4><p>目前scylladb的监控是使用<a href="https://github.com/scylladb/scylla-grafana-monitoring" target="_blank" rel="noopener">Grafana and Prometheus
</a>, 具体的安装过程如下:</p>
<ol>
<li>首先安装docker在服务器上; <code>sudo yum install -y docker</code></li>
<li>启动docker服务;<code>sudo service docker start</code></li>
<li>验证docker安装情况; <code>sudo docker ps -a or sudo docker images</code></li>
</ol>
<p>其实监控安装比较简单，但是由于网络问题安装就变成很蛋疼的过程;</p>
<ul>
<li>首先通过mac翻墙下载docker 镜像; prom/prometheus and grafana/grafana</li>
</ul>
<pre><code>docker pull prom/prometheus:v1.5.2
docker pull grafana/grafana:4.1.1
</code></pre><ul>
<li>将镜像导出成tar格式的文件</li>
</ul>
<pre><code>docker save imageid -o xxx.tar
</code></pre><p>镜像id可以通过<code>docker images</code>来得到</p>
<pre><code>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
grafana/grafana     latest              a892c250adfa        11 days ago         266.2 MB
prom/prometheus     latest              bdeacb538ef9        2 weeks ago         79.25 MB
</code></pre><ul>
<li>将tar文件上传到服务器，然后导入服务器的docker</li>
</ul>
<pre><code>docker load -i xxx.tar
#修改对应的name和版本
docker tag imageId name:tag

sudo docker tag  047fd14b7251 prom/prometheus:v1.0.0
sudo docker tag d7528263f75a grafana/grafana:3.1.0
</code></pre><ul>
<li>下载 scylla-grafana-monitoring 项目</li>
</ul>
<pre><code>git clone https://github.com/scylladb/scylla-grafana-monitoring.git
</code></pre><ul>
<li>修改prometheus的配置文件</li>
</ul>
<pre><code>global:
# 采集周期
  scrape_interval: 15s # By default, scrape targets every 15 seconds.

  # Attach these labels to any time series or alerts when communicating with
  # external systems (federation, remote storage, Alertmanager).
  external_labels:
    monitor: &apos;scylla-monitor&apos;

scrape_configs:
    - job_name: scylla
  honor_labels: true
  static_configs:
  # 这个是scylladb服务的地址，这边是主动采集为主，不是被动上报，主要收集scylla的metric信息
      - targets: [&quot;10.19.11.23:9180&quot;]
    - job_name: node_exporter
  honor_labels: true
  static_configs:
  # 这部分主要是收集scylla的机器的信息，需要通过node_exporter 来开启这个上报;
      - targets: [&apos;10.19.11.23:9100&apos;]

## two servers example: - targets: [&quot;172.17.0.3:9103&quot;,&quot;172.17.0.2:9103&quot;]
</code></pre><ul>
<li>用启动脚本启动</li>
</ul>
<pre><code>sudo sh start-all.sh -d data_dir -v 1.6
</code></pre><p>data路径最好要配置一个，不然两次启动会把数据删除<br>-v: 用来表示加载哪个系统版本</p>
<p>这个可能会碰到一个问题，</p>
<pre><code>598cf3f9e16f0e5df2a1f0cf79df8be2ee0909f80307e392911d140b2ff6dac8
Wait for Prometheus container to start..        4721e32c86ea09f1e16d270a194eb979cbf61f249c066435234e7d5cafee8631
Wait for Grafana container to start........curl: (7) Failed connect to localhost:3000; Connection refused
curl: (7) Failed connect to localhost:3000; Connection refused
curl: (7) Failed connect to localhost:3000; Connection refused        curl: (7) Failed connect to localhost:3000; Connection refused
</code></pre><p>Grafana 没有起来 或者起来，但是还没有监听端口，然后脚本最多只是重试7次，这个时候就会报错，其实后期grafana是成功起来的；</p>
<p>解决方式有两个：</p>
<pre><code>1. 先执行脚本，然后等到grafana起来，然后关掉prometheus,然后修改start-all.sh中的脚本，把docker run grafana那个部分去掉，然后在执行start-all.sh, 这样就ok了
2. 将重试几次增大
</code></pre><ul>
<li>关闭监控</li>
</ul>
<pre><code>sudo sh kill-all.sh
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">nomoshen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nomoshen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
